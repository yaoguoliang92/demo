! function(t, e) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : t.L = e()
}(this, function() {
    "use strict";

    function t(t, e) {
        return e = {
            exports: {}
        }, t(e, e.exports), e.exports
    }
    var e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {},
        n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        },
        i = t(function(t, e) {
            ! function(t, i) {
                ! function(t) {
                    function e(t) {
                        var e, n, i, o;
                        for (n = 1, i = arguments.length; n < i; n++) {
                            o = arguments[n];
                            for (e in o) t[e] = o[e]
                        }
                        return t
                    }

                    function i(t, e) {
                        var n = Array.prototype.slice;
                        if (t.bind) return t.bind.apply(t, n.call(arguments, 1));
                        var i = n.call(arguments, 2);
                        return function() {
                            return t.apply(e, i.length ? i.concat(n.call(arguments)) : arguments)
                        }
                    }

                    function o(t) {
                        return t._leaflet_id = t._leaflet_id || ++_e, t._leaflet_id
                    }

                    function r(t, e, n) {
                        var i, o, r, s;
                        return s = function() {
                            i = !1, o && (r.apply(n, o), o = !1)
                        }, r = function() {
                            i ? o = arguments : (t.apply(n, arguments), setTimeout(s, e), i = !0)
                        }
                    }

                    function s(t, e, n) {
                        var i = e[1],
                            o = e[0],
                            r = i - o;
                        return t === i && n ? t : ((t - o) % r + r) % r + o
                    }

                    function a() {
                        return !1
                    }

                    function h(t, e) {
                        var n = Math.pow(10, void 0 === e ? 6 : e);
                        return Math.round(t * n) / n
                    }

                    function u(t) {
                        return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
                    }

                    function l(t) {
                        return u(t).split(/\s+/)
                    }

                    function c(t, e) {
                        t.hasOwnProperty("options") || (t.options = t.options ? de(t.options) : {});
                        for (var n in e) t.options[n] = e[n];
                        return t.options
                    }

                    function p(t, e, n) {
                        var i = [];
                        for (var o in t) i.push(encodeURIComponent(n ? o.toUpperCase() : o) + "=" + encodeURIComponent(t[o]));
                        return (e && -1 !== e.indexOf("?") ? "&" : "?") + i.join("&")
                    }

                    function f(t, e) {
                        return t.replace(ge, function(t, n) {
                            var i = e[n];
                            if (void 0 === i) throw new Error("No value provided for variable " + t);
                            return "function" == typeof i && (i = i(e)), i
                        })
                    }

                    function d(t, e) {
                        for (var n = 0; n < t.length; n++)
                            if (t[n] === e) return n;
                        return -1
                    }

                    function _(t) {
                        return window["webkit" + t] || window["moz" + t] || window["ms" + t]
                    }

                    function g(t) {
                        var e = +new Date,
                            n = Math.max(0, 16 - (e - ve));
                        return ve = e + n, window.setTimeout(t, n)
                    }

                    function m(t, e, n) {
                        if (!n || Le !== g) return Le.call(window, i(t, e));
                        t.call(e)
                    }

                    function y(t) {
                        t && xe.call(window, t)
                    }

                    function v() {}

                    function x(t) {
                        if ("undefined" != typeof L && L && L.Mixin) {
                            t = me(t) ? t : [t];
                            for (var e = 0; e < t.length; e++) t[e] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", (new Error).stack)
                        }
                    }

                    function b(t, e, n) {
                        this.x = n ? Math.round(t) : t, this.y = n ? Math.round(e) : e
                    }

                    function E(t, e, i) {
                        return t instanceof b ? t : me(t) ? new b(t[0], t[1]) : void 0 === t || null === t ? t : "object" === (void 0 === t ? "undefined" : n(t)) && "x" in t && "y" in t ? new b(t.x, t.y) : new b(t, e, i)
                    }

                    function C(t, e) {
                        if (t)
                            for (var n = e ? [t, e] : t, i = 0, o = n.length; i < o; i++) this.extend(n[i])
                    }

                    function I(t, e) {
                        return !t || t instanceof C ? t : new C(t, e)
                    }

                    function w(t, e) {
                        if (t)
                            for (var n = e ? [t, e] : t, i = 0, o = n.length; i < o; i++) this.extend(n[i])
                    }

                    function M(t, e) {
                        return t instanceof w ? t : new w(t, e)
                    }

                    function S(t, e, n) {
                        if (isNaN(t) || isNaN(e)) throw new Error("Invalid LatLng object: (" + t + ", " + e + ")");
                        this.lat = +t, this.lng = +e, void 0 !== n && (this.alt = +n)
                    }

                    function P(t, e, i) {
                        return t instanceof S ? t : me(t) && "object" !== n(t[0]) ? 3 === t.length ? new S(t[0], t[1], t[2]) : 2 === t.length ? new S(t[0], t[1]) : null : void 0 === t || null === t ? t : "object" === (void 0 === t ? "undefined" : n(t)) && "lat" in t ? new S(t.lat, "lng" in t ? t.lng : t.lon, t.alt) : void 0 === e ? null : new S(t, e, i)
                    }

                    function N(t, e, n, i) {
                        if (me(t)) return this._a = t[0], this._b = t[1], this._c = t[2], void(this._d = t[3]);
                        this._a = t, this._b = e, this._c = n, this._d = i
                    }

                    function T(t, e, n, i) {
                        return new N(t, e, n, i)
                    }

                    function O(t) {
                        return document.createElementNS("http://www.w3.org/2000/svg", t)
                    }

                    function A(t, e) {
                        var n, i, o, r, s, a, h = "";
                        for (n = 0, o = t.length; n < o; n++) {
                            for (s = t[n], i = 0, r = s.length; i < r; i++) a = s[i], h += (i ? "L" : "M") + a.x + " " + a.y;
                            h += e ? pn ? "z" : "x" : ""
                        }
                        return h || "M0 0"
                    }

                    function R(t) {
                        return navigator.userAgent.toLowerCase().indexOf(t) >= 0
                    }

                    function D(t, e, n, i) {
                        return "touchstart" === e ? F(t, n, i) : "touchmove" === e ? j(t, n, i) : "touchend" === e && q(t, n, i), this
                    }

                    function k(t, e, n) {
                        var i = t["_leaflet_" + e + n];
                        return "touchstart" === e ? t.removeEventListener(_n, i, !1) : "touchmove" === e ? t.removeEventListener(gn, i, !1) : "touchend" === e && (t.removeEventListener(mn, i, !1), t.removeEventListener(yn, i, !1)), this
                    }

                    function F(t, e, n) {
                        var o = i(function(t) {
                            if ("mouse" !== t.pointerType && t.MSPOINTER_TYPE_MOUSE && t.pointerType !== t.MSPOINTER_TYPE_MOUSE) {
                                if (!(vn.indexOf(t.target.tagName) < 0)) return;
                                $(t)
                            }
                            U(t, e)
                        });
                        t["_leaflet_touchstart" + n] = o, t.addEventListener(_n, o, !1), xn || (document.documentElement.addEventListener(_n, z, !0), document.documentElement.addEventListener(gn, B, !0), document.documentElement.addEventListener(mn, G, !0), document.documentElement.addEventListener(yn, G, !0), xn = !0)
                    }

                    function z(t) {
                        Ln[t.pointerId] = t, bn++
                    }

                    function B(t) {
                        Ln[t.pointerId] && (Ln[t.pointerId] = t)
                    }

                    function G(t) {
                        delete Ln[t.pointerId], bn--
                    }

                    function U(t, e) {
                        t.touches = [];
                        for (var n in Ln) t.touches.push(Ln[n]);
                        t.changedTouches = [t], e(t)
                    }

                    function j(t, e, n) {
                        var i = function(t) {
                            (t.pointerType !== t.MSPOINTER_TYPE_MOUSE && "mouse" !== t.pointerType || 0 !== t.buttons) && U(t, e)
                        };
                        t["_leaflet_touchmove" + n] = i, t.addEventListener(gn, i, !1)
                    }

                    function q(t, e, n) {
                        var i = function(t) {
                            U(t, e)
                        };
                        t["_leaflet_touchend" + n] = i, t.addEventListener(mn, i, !1), t.addEventListener(yn, i, !1)
                    }

                    function Z(t, e, n) {
                        function i(t) {
                            var e;
                            if (sn) {
                                if (!ze || "mouse" === t.pointerType) return;
                                e = bn
                            } else e = t.touches.length; if (!(e > 1)) {
                                var n = Date.now(),
                                    i = n - (r || n);
                                s = t.touches ? t.touches[0] : t, a = i > 0 && i <= h, r = n
                            }
                        }

                        function o(t) {
                            if (a && !s.cancelBubble) {
                                if (sn) {
                                    if (!ze || "mouse" === t.pointerType) return;
                                    var n, i, o = {};
                                    for (i in s) n = s[i], o[i] = n && n.bind ? n.bind(s) : n;
                                    s = o
                                }
                                s.type = "dblclick", e(s), r = null
                            }
                        }
                        var r, s, a = !1,
                            h = 250;
                        return t[In + En + n] = i, t[In + Cn + n] = o, t[In + "dblclick" + n] = e, t.addEventListener(En, i, !1), t.addEventListener(Cn, o, !1), t.addEventListener("dblclick", e, !1), this
                    }

                    function V(t, e) {
                        var n = t[In + En + e],
                            i = t[In + Cn + e],
                            o = t[In + "dblclick" + e];
                        return t.removeEventListener(En, n, !1), t.removeEventListener(Cn, i, !1), ze || t.removeEventListener("dblclick", o, !1), this
                    }

                    function H(t, e, i, o) {
                        if ("object" === (void 0 === e ? "undefined" : n(e)))
                            for (var r in e) W(t, r, e[r], i);
                        else {
                            e = l(e);
                            for (var s = 0, a = e.length; s < a; s++) W(t, e[s], i, o)
                        }
                        return this
                    }

                    function Y(t, e, i, o) {
                        if ("object" === (void 0 === e ? "undefined" : n(e)))
                            for (var r in e) X(t, r, e[r], i);
                        else if (e) {
                            e = l(e);
                            for (var s = 0, a = e.length; s < a; s++) X(t, e[s], i, o)
                        } else {
                            for (var h in t[wn]) X(t, h, t[wn][h]);
                            delete t[wn]
                        }
                        return this
                    }

                    function W(t, e, n, i) {
                        var r = e + o(n) + (i ? "_" + o(i) : "");
                        if (t[wn] && t[wn][r]) return this;
                        var s = function(e) {
                                return n.call(i || t, e || window.event)
                            },
                            a = s;
                        sn && 0 === e.indexOf("touch") ? D(t, e, s, r) : !an || "dblclick" !== e || !Z || sn && Ve ? "addEventListener" in t ? "mousewheel" === e ? t.addEventListener("onwheel" in t ? "wheel" : "mousewheel", s, !1) : "mouseenter" === e || "mouseleave" === e ? (s = function(e) {
                            e = e || window.event, rt(t, e) && a(e)
                        }, t.addEventListener("mouseenter" === e ? "mouseover" : "mouseout", s, !1)) : ("click" === e && Ge && (s = function(t) {
                            st(t, a)
                        }), t.addEventListener(e, s, !1)) : "attachEvent" in t && t.attachEvent("on" + e, s) : Z(t, s, r), t[wn] = t[wn] || {}, t[wn][r] = s
                    }

                    function X(t, e, n, i) {
                        var r = e + o(n) + (i ? "_" + o(i) : ""),
                            s = t[wn] && t[wn][r];
                        if (!s) return this;
                        sn && 0 === e.indexOf("touch") ? k(t, e, r) : !an || "dblclick" !== e || !V || sn && Ve ? "removeEventListener" in t ? "mousewheel" === e ? t.removeEventListener("onwheel" in t ? "wheel" : "mousewheel", s, !1) : t.removeEventListener("mouseenter" === e ? "mouseover" : "mouseleave" === e ? "mouseout" : e, s, !1) : "detachEvent" in t && t.detachEvent("on" + e, s) : V(t, r), t[wn][r] = null
                    }

                    function J(t) {
                        return t.stopPropagation ? t.stopPropagation() : t.originalEvent ? t.originalEvent._stopped = !0 : t.cancelBubble = !0, ot(t), this
                    }

                    function K(t) {
                        return W(t, "mousewheel", J), this
                    }

                    function Q(t) {
                        return H(t, "mousedown touchstart dblclick", J), W(t, "click", it), this
                    }

                    function $(t) {
                        return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this
                    }

                    function tt(t) {
                        return $(t), J(t), this
                    }

                    function et(t, e) {
                        if (!e) return new b(t.clientX, t.clientY);
                        var n = e.getBoundingClientRect(),
                            i = n.width / e.offsetWidth || 1,
                            o = n.height / e.offsetHeight || 1;
                        return new b(t.clientX / i - n.left - e.clientLeft, t.clientY / o - n.top - e.clientTop)
                    }

                    function nt(t) {
                        return ze ? t.wheelDeltaY / 2 : t.deltaY && 0 === t.deltaMode ? -t.deltaY / Mn : t.deltaY && 1 === t.deltaMode ? 20 * -t.deltaY : t.deltaY && 2 === t.deltaMode ? 60 * -t.deltaY : t.deltaX || t.deltaZ ? 0 : t.wheelDelta ? (t.wheelDeltaY || t.wheelDelta) / 2 : t.detail && Math.abs(t.detail) < 32765 ? 20 * -t.detail : t.detail ? t.detail / -32765 * 60 : 0
                    }

                    function it(t) {
                        Sn[t.type] = !0
                    }

                    function ot(t) {
                        var e = Sn[t.type];
                        return Sn[t.type] = !1, e
                    }

                    function rt(t, e) {
                        var n = e.relatedTarget;
                        if (!n) return !0;
                        try {
                            for (; n && n !== t;) n = n.parentNode
                        } catch (t) {
                            return !1
                        }
                        return n !== t
                    }

                    function st(t, e) {
                        var n = t.timeStamp || t.originalEvent && t.originalEvent.timeStamp,
                            i = Pe && n - Pe;
                        if (i && i > 100 && i < 500 || t.target._simulatedClick && !t._simulated) return void tt(t);
                        Pe = n, e(t)
                    }

                    function at(t) {
                        return "string" == typeof t ? document.getElementById(t) : t
                    }

                    function ht(t, e) {
                        var n = t.style[e] || t.currentStyle && t.currentStyle[e];
                        if ((!n || "auto" === n) && document.defaultView) {
                            var i = document.defaultView.getComputedStyle(t, null);
                            n = i ? i[e] : null
                        }
                        return "auto" === n ? null : n
                    }

                    function ut(t, e, n) {
                        var i = document.createElement(t);
                        return i.className = e || "", n && n.appendChild(i), i
                    }

                    function lt(t) {
                        var e = t.parentNode;
                        e && e.removeChild(t)
                    }

                    function ct(t) {
                        for (; t.firstChild;) t.removeChild(t.firstChild)
                    }

                    function pt(t) {
                        var e = t.parentNode;
                        e.lastChild !== t && e.appendChild(t)
                    }

                    function ft(t) {
                        var e = t.parentNode;
                        e.firstChild !== t && e.insertBefore(t, e.firstChild)
                    }

                    function dt(t, e) {
                        if (void 0 !== t.classList) return t.classList.contains(e);
                        var n = yt(t);
                        return n.length > 0 && new RegExp("(^|\\s)" + e + "(\\s|$)").test(n)
                    }

                    function _t(t, e) {
                        if (void 0 !== t.classList)
                            for (var n = l(e), i = 0, o = n.length; i < o; i++) t.classList.add(n[i]);
                        else if (!dt(t, e)) {
                            var r = yt(t);
                            mt(t, (r ? r + " " : "") + e)
                        }
                    }

                    function gt(t, e) {
                        void 0 !== t.classList ? t.classList.remove(e) : mt(t, u((" " + yt(t) + " ").replace(" " + e + " ", " ")))
                    }

                    function mt(t, e) {
                        void 0 === t.className.baseVal ? t.className = e : t.className.baseVal = e
                    }

                    function yt(t) {
                        return void 0 === t.className.baseVal ? t.className : t.className.baseVal
                    }

                    function vt(t, e) {
                        "opacity" in t.style ? t.style.opacity = e : "filter" in t.style && Lt(t, e)
                    }

                    function Lt(t, e) {
                        var n = !1,
                            i = "DXImageTransform.Microsoft.Alpha";
                        try {
                            n = t.filters.item(i)
                        } catch (t) {
                            if (1 === e) return
                        }
                        e = Math.round(100 * e), n ? (n.Enabled = 100 !== e, n.Opacity = e) : t.style.filter += " progid:" + i + "(opacity=" + e + ")"
                    }

                    function xt(t) {
                        for (var e = document.documentElement.style, n = 0; n < t.length; n++)
                            if (t[n] in e) return t[n];
                        return !1
                    }

                    function bt(t, e, n) {
                        var i = e || new b(0, 0);
                        t.style[Nn] = (Ke ? "translate(" + i.x + "px," + i.y + "px)" : "translate3d(" + i.x + "px," + i.y + "px,0)") + (n ? " scale(" + n + ")" : "")
                    }

                    function Et(t, e) {
                        t._leaflet_pos = e, tn ? bt(t, e) : (t.style.left = e.x + "px", t.style.top = e.y + "px")
                    }

                    function Ct(t) {
                        return t._leaflet_pos || new b(0, 0)
                    }

                    function It() {
                        H(window, "dragstart", $)
                    }

                    function wt() {
                        Y(window, "dragstart", $)
                    }

                    function Mt(t) {
                        for (; - 1 === t.tabIndex;) t = t.parentNode;
                        t.style && (St(), Rn = t, Dn = t.style.outline, t.style.outline = "none", H(window, "keydown", St))
                    }

                    function St() {
                        Rn && (Rn.style.outline = Dn, Rn = void 0, Dn = void 0, Y(window, "keydown", St))
                    }

                    function Pt(t, e) {
                        return new zn(t, e)
                    }

                    function Nt(t, e) {
                        if (!e || !t.length) return t.slice();
                        var n = e * e;
                        return t = Dt(t, n), t = At(t, n)
                    }

                    function Tt(t, e, n) {
                        return Math.sqrt(Gt(t, e, n, !0))
                    }

                    function Ot(t, e, n) {
                        return Gt(t, e, n)
                    }

                    function At(t, e) {
                        var i = t.length,
                            o = ("undefined" == typeof Uint8Array ? "undefined" : n(Uint8Array)) !== void 0 + "" ? Uint8Array : Array,
                            r = new o(i);
                        r[0] = r[i - 1] = 1, Rt(t, r, e, 0, i - 1);
                        var s, a = [];
                        for (s = 0; s < i; s++) r[s] && a.push(t[s]);
                        return a
                    }

                    function Rt(t, e, n, i, o) {
                        var r, s, a, h = 0;
                        for (s = i + 1; s <= o - 1; s++)(a = Gt(t[s], t[i], t[o], !0)) > h && (r = s, h = a);
                        h > n && (e[r] = 1, Rt(t, e, n, i, r), Rt(t, e, n, r, o))
                    }

                    function Dt(t, e) {
                        for (var n = [t[0]], i = 1, o = 0, r = t.length; i < r; i++) Bt(t[i], t[o]) > e && (n.push(t[i]), o = i);
                        return o < r - 1 && n.push(t[r - 1]), n
                    }

                    function kt(t, e, n, i, o) {
                        var r, s, a, h = i ? Jn : zt(t, n),
                            u = zt(e, n);
                        for (Jn = u;;) {
                            if (!(h | u)) return [t, e];
                            if (h & u) return !1;
                            r = h || u, s = Ft(t, e, r, n, o), a = zt(s, n), r === h ? (t = s, h = a) : (e = s, u = a)
                        }
                    }

                    function Ft(t, e, n, i, o) {
                        var r, s, a = e.x - t.x,
                            h = e.y - t.y,
                            u = i.min,
                            l = i.max;
                        return 8 & n ? (r = t.x + a * (l.y - t.y) / h, s = l.y) : 4 & n ? (r = t.x + a * (u.y - t.y) / h, s = u.y) : 2 & n ? (r = l.x, s = t.y + h * (l.x - t.x) / a) : 1 & n && (r = u.x, s = t.y + h * (u.x - t.x) / a), new b(r, s, o)
                    }

                    function zt(t, e) {
                        var n = 0;
                        return t.x < e.min.x ? n |= 1 : t.x > e.max.x && (n |= 2), t.y < e.min.y ? n |= 4 : t.y > e.max.y && (n |= 8), n
                    }

                    function Bt(t, e) {
                        var n = e.x - t.x,
                            i = e.y - t.y;
                        return n * n + i * i
                    }

                    function Gt(t, e, n, i) {
                        var o, r = e.x,
                            s = e.y,
                            a = n.x - r,
                            h = n.y - s,
                            u = a * a + h * h;
                        return u > 0 && (o = ((t.x - r) * a + (t.y - s) * h) / u, o > 1 ? (r = n.x, s = n.y) : o > 0 && (r += a * o, s += h * o)), a = t.x - r, h = t.y - s, i ? a * a + h * h : new b(r, s)
                    }

                    function Ut(t) {
                        return !me(t[0]) || "object" !== n(t[0][0]) && void 0 !== t[0][0]
                    }

                    function jt(t) {
                        return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), Ut(t)
                    }

                    function qt(t, e, n) {
                        var i, o, r, s, a, h, u, l, c, p = [1, 4, 2, 8];
                        for (o = 0, u = t.length; o < u; o++) t[o]._code = zt(t[o], e);
                        for (s = 0; s < 4; s++) {
                            for (l = p[s], i = [], o = 0, u = t.length, r = u - 1; o < u; r = o++) a = t[o], h = t[r], a._code & l ? h._code & l || (c = Ft(h, a, l, e, n), c._code = zt(c, e), i.push(c)) : (h._code & l && (c = Ft(h, a, l, e, n), c._code = zt(c, e), i.push(c)), i.push(a));
                            t = i
                        }
                        return t
                    }

                    function Zt(t) {
                        return new _i(t)
                    }

                    function Vt(t, e) {
                        return new yi(t, e)
                    }

                    function Ht(t, e) {
                        return new Li(t, e)
                    }

                    function Yt(t, e, n) {
                        return new xi(t, e, n)
                    }

                    function Wt(t, e) {
                        return new bi(t, e)
                    }

                    function Xt(t, e) {
                        return new Ei(t, e)
                    }

                    function Jt(t, e) {
                        var n, i, o, r, s = "Feature" === t.type ? t.geometry : t,
                            a = s ? s.coordinates : null,
                            h = [],
                            u = e && e.pointToLayer,
                            l = e && e.coordsToLatLng || Kt;
                        if (!a && !s) return null;
                        switch (s.type) {
                            case "Point":
                                return n = l(a), u ? u(t, n) : new yi(n);
                            case "MultiPoint":
                                for (o = 0, r = a.length; o < r; o++) n = l(a[o]), h.push(u ? u(t, n) : new yi(n));
                                return new fi(h);
                            case "LineString":
                            case "MultiLineString":
                                return i = Qt(a, "LineString" === s.type ? 0 : 1, l), new bi(i, e);
                            case "Polygon":
                            case "MultiPolygon":
                                return i = Qt(a, "Polygon" === s.type ? 1 : 2, l), new Ei(i, e);
                            case "GeometryCollection":
                                for (o = 0, r = s.geometries.length; o < r; o++) {
                                    var c = Jt({
                                        geometry: s.geometries[o],
                                        type: "Feature",
                                        properties: t.properties
                                    }, e);
                                    c && h.push(c)
                                }
                                return new fi(h);
                            default:
                                throw new Error("Invalid GeoJSON object.")
                        }
                    }

                    function Kt(t) {
                        return new S(t[1], t[0], t[2])
                    }

                    function Qt(t, e, n) {
                        for (var i, o = [], r = 0, s = t.length; r < s; r++) i = e ? Qt(t[r], e - 1, n) : (n || Kt)(t[r]), o.push(i);
                        return o
                    }

                    function $t(t, e) {
                        return e = "number" == typeof e ? e : 6, void 0 !== t.alt ? [h(t.lng, e), h(t.lat, e), h(t.alt, e)] : [h(t.lng, e), h(t.lat, e)]
                    }

                    function te(t, e, n, i) {
                        for (var o = [], r = 0, s = t.length; r < s; r++) o.push(e ? te(t[r], e - 1, n, i) : $t(t[r], i));
                        return !e && n && o.push(o[0]), o
                    }

                    function ee(t, n) {
                        return t.feature ? e({}, t.feature, {
                            geometry: n
                        }) : ne(n)
                    }

                    function ne(t) {
                        return "Feature" === t.type || "FeatureCollection" === t.type ? t : {
                            type: "Feature",
                            properties: {},
                            geometry: t
                        }
                    }

                    function ie(t, e) {
                        return new Ci(t, e)
                    }

                    function oe(t, e, n) {
                        return new Pi(t, e, n)
                    }

                    function re(t) {
                        return new Di(t)
                    }

                    function se(t) {
                        return new ki(t)
                    }

                    function ae(t, e) {
                        return new Fi(t, e)
                    }

                    function he(t, e) {
                        return new zi(t, e)
                    }

                    function ue(t) {
                        return cn ? new Gi(t) : null
                    }

                    function le(t) {
                        return pn || fn ? new Zi(t) : null
                    }

                    function ce(t, e) {
                        return new Vi(t, e)
                    }

                    function pe() {
                        return window.L = $i, this
                    }
                    var fe = Object.freeze;
                    Object.freeze = function(t) {
                        return t
                    };
                    var de = Object.create || function() {
                            function t() {}
                            return function(e) {
                                return t.prototype = e, new t
                            }
                        }(),
                        _e = 0,
                        ge = /\{ *([\w_-]+) *\}/g,
                        me = Array.isArray || function(t) {
                            return "[object Array]" === Object.prototype.toString.call(t)
                        },
                        ye = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=",
                        ve = 0,
                        Le = window.requestAnimationFrame || _("RequestAnimationFrame") || g,
                        xe = window.cancelAnimationFrame || _("CancelAnimationFrame") || _("CancelRequestAnimationFrame") || function(t) {
                            window.clearTimeout(t)
                        },
                        be = (Object.freeze || Object)({
                            freeze: fe,
                            extend: e,
                            create: de,
                            bind: i,
                            lastId: _e,
                            stamp: o,
                            throttle: r,
                            wrapNum: s,
                            falseFn: a,
                            formatNum: h,
                            trim: u,
                            splitWords: l,
                            setOptions: c,
                            getParamString: p,
                            template: f,
                            isArray: me,
                            indexOf: d,
                            emptyImageUrl: ye,
                            requestFn: Le,
                            cancelFn: xe,
                            requestAnimFrame: m,
                            cancelAnimFrame: y
                        });
                    v.extend = function(t) {
                        var n = function() {
                                this.initialize && this.initialize.apply(this, arguments), this.callInitHooks()
                            },
                            i = n.__super__ = this.prototype,
                            o = de(i);
                        o.constructor = n, n.prototype = o;
                        for (var r in this) this.hasOwnProperty(r) && "prototype" !== r && "__super__" !== r && (n[r] = this[r]);
                        return t.statics && (e(n, t.statics), delete t.statics), t.includes && (x(t.includes), e.apply(null, [o].concat(t.includes)), delete t.includes), o.options && (t.options = e(de(o.options), t.options)), e(o, t), o._initHooks = [], o.callInitHooks = function() {
                            if (!this._initHooksCalled) {
                                i.callInitHooks && i.callInitHooks.call(this), this._initHooksCalled = !0;
                                for (var t = 0, e = o._initHooks.length; t < e; t++) o._initHooks[t].call(this)
                            }
                        }, n
                    }, v.include = function(t) {
                        return e(this.prototype, t), this
                    }, v.mergeOptions = function(t) {
                        return e(this.prototype.options, t), this
                    }, v.addInitHook = function(t) {
                        var e = Array.prototype.slice.call(arguments, 1),
                            n = "function" == typeof t ? t : function() {
                                this[t].apply(this, e)
                            };
                        return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(n), this
                    };
                    var Ee = {
                        on: function(t, e, i) {
                            if ("object" === (void 0 === t ? "undefined" : n(t)))
                                for (var o in t) this._on(o, t[o], e);
                            else {
                                t = l(t);
                                for (var r = 0, s = t.length; r < s; r++) this._on(t[r], e, i)
                            }
                            return this
                        },
                        off: function(t, e, i) {
                            if (t)
                                if ("object" === (void 0 === t ? "undefined" : n(t)))
                                    for (var o in t) this._off(o, t[o], e);
                                else {
                                    t = l(t);
                                    for (var r = 0, s = t.length; r < s; r++) this._off(t[r], e, i)
                                } else delete this._events;
                            return this
                        },
                        _on: function(t, e, n) {
                            this._events = this._events || {};
                            var i = this._events[t];
                            i || (i = [], this._events[t] = i), n === this && (n = void 0);
                            for (var o = {
                                fn: e,
                                ctx: n
                            }, r = i, s = 0, a = r.length; s < a; s++)
                                if (r[s].fn === e && r[s].ctx === n) return;
                            r.push(o)
                        },
                        _off: function(t, e, n) {
                            var i, o, r;
                            if (this._events && (i = this._events[t])) {
                                if (!e) {
                                    for (o = 0, r = i.length; o < r; o++) i[o].fn = a;
                                    return void delete this._events[t]
                                }
                                if (n === this && (n = void 0), i)
                                    for (o = 0, r = i.length; o < r; o++) {
                                        var s = i[o];
                                        if (s.ctx === n && s.fn === e) return s.fn = a, this._firingCount && (this._events[t] = i = i.slice()), void i.splice(o, 1)
                                    }
                            }
                        },
                        fire: function(t, n, i) {
                            if (!this.listens(t, i)) return this;
                            var o = e({}, n, {
                                type: t,
                                target: this,
                                sourceTarget: n && n.sourceTarget || this
                            });
                            if (this._events) {
                                var r = this._events[t];
                                if (r) {
                                    this._firingCount = this._firingCount + 1 || 1;
                                    for (var s = 0, a = r.length; s < a; s++) {
                                        var h = r[s];
                                        h.fn.call(h.ctx || this, o)
                                    }
                                    this._firingCount--
                                }
                            }
                            return i && this._propagateEvent(o), this
                        },
                        listens: function(t, e) {
                            var n = this._events && this._events[t];
                            if (n && n.length) return !0;
                            if (e)
                                for (var i in this._eventParents)
                                    if (this._eventParents[i].listens(t, e)) return !0;
                            return !1
                        },
                        once: function(t, e, o) {
                            if ("object" === (void 0 === t ? "undefined" : n(t))) {
                                for (var r in t) this.once(r, t[r], e);
                                return this
                            }
                            var s = i(function() {
                                this.off(t, e, o).off(t, s, o)
                            }, this);
                            return this.on(t, e, o).on(t, s, o)
                        },
                        addEventParent: function(t) {
                            return this._eventParents = this._eventParents || {}, this._eventParents[o(t)] = t, this
                        },
                        removeEventParent: function(t) {
                            return this._eventParents && delete this._eventParents[o(t)], this
                        },
                        _propagateEvent: function(t) {
                            for (var n in this._eventParents) this._eventParents[n].fire(t.type, e({
                                layer: t.target,
                                propagatedFrom: t.target
                            }, t), !0)
                        }
                    };
                    Ee.addEventListener = Ee.on, Ee.removeEventListener = Ee.clearAllEventListeners = Ee.off, Ee.addOneTimeEventListener = Ee.once, Ee.fireEvent = Ee.fire, Ee.hasEventListeners = Ee.listens;
                    var Ce = v.extend(Ee),
                        Ie = Math.trunc || function(t) {
                            return t > 0 ? Math.floor(t) : Math.ceil(t)
                        };
                    b.prototype = {
                        clone: function() {
                            return new b(this.x, this.y)
                        },
                        add: function(t) {
                            return this.clone()._add(E(t))
                        },
                        _add: function(t) {
                            return this.x += t.x, this.y += t.y, this
                        },
                        subtract: function(t) {
                            return this.clone()._subtract(E(t))
                        },
                        _subtract: function(t) {
                            return this.x -= t.x, this.y -= t.y, this
                        },
                        divideBy: function(t) {
                            return this.clone()._divideBy(t)
                        },
                        _divideBy: function(t) {
                            return this.x /= t, this.y /= t, this
                        },
                        multiplyBy: function(t) {
                            return this.clone()._multiplyBy(t)
                        },
                        _multiplyBy: function(t) {
                            return this.x *= t, this.y *= t, this
                        },
                        scaleBy: function(t) {
                            return new b(this.x * t.x, this.y * t.y)
                        },
                        unscaleBy: function(t) {
                            return new b(this.x / t.x, this.y / t.y)
                        },
                        round: function() {
                            return this.clone()._round()
                        },
                        _round: function() {
                            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                        },
                        floor: function() {
                            return this.clone()._floor()
                        },
                        _floor: function() {
                            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                        },
                        ceil: function() {
                            return this.clone()._ceil()
                        },
                        _ceil: function() {
                            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                        },
                        trunc: function() {
                            return this.clone()._trunc()
                        },
                        _trunc: function() {
                            return this.x = Ie(this.x), this.y = Ie(this.y), this
                        },
                        distanceTo: function(t) {
                            t = E(t);
                            var e = t.x - this.x,
                                n = t.y - this.y;
                            return Math.sqrt(e * e + n * n)
                        },
                        equals: function(t) {
                            return t = E(t), t.x === this.x && t.y === this.y
                        },
                        contains: function(t) {
                            return t = E(t), Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y)
                        },
                        toString: function() {
                            return "Point(" + h(this.x) + ", " + h(this.y) + ")"
                        }
                    }, C.prototype = {
                        extend: function(t) {
                            return t = E(t), this.min || this.max ? (this.min.x = Math.min(t.x, this.min.x), this.max.x = Math.max(t.x, this.max.x), this.min.y = Math.min(t.y, this.min.y), this.max.y = Math.max(t.y, this.max.y)) : (this.min = t.clone(), this.max = t.clone()), this
                        },
                        getCenter: function(t) {
                            return new b((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t)
                        },
                        getBottomLeft: function() {
                            return new b(this.min.x, this.max.y)
                        },
                        getTopRight: function() {
                            return new b(this.max.x, this.min.y)
                        },
                        getTopLeft: function() {
                            return this.min
                        },
                        getBottomRight: function() {
                            return this.max
                        },
                        getSize: function() {
                            return this.max.subtract(this.min)
                        },
                        contains: function(t) {
                            var e, n;
                            return t = "number" == typeof t[0] || t instanceof b ? E(t) : I(t), t instanceof C ? (e = t.min, n = t.max) : e = n = t, e.x >= this.min.x && n.x <= this.max.x && e.y >= this.min.y && n.y <= this.max.y
                        },
                        intersects: function(t) {
                            t = I(t);
                            var e = this.min,
                                n = this.max,
                                i = t.min,
                                o = t.max,
                                r = o.x >= e.x && i.x <= n.x,
                                s = o.y >= e.y && i.y <= n.y;
                            return r && s
                        },
                        overlaps: function(t) {
                            t = I(t);
                            var e = this.min,
                                n = this.max,
                                i = t.min,
                                o = t.max,
                                r = o.x > e.x && i.x < n.x,
                                s = o.y > e.y && i.y < n.y;
                            return r && s
                        },
                        isValid: function() {
                            return !(!this.min || !this.max)
                        }
                    }, w.prototype = {
                        extend: function(t) {
                            var e, n, i = this._southWest,
                                o = this._northEast;
                            if (t instanceof S) e = t, n = t;
                            else {
                                if (!(t instanceof w)) return t ? this.extend(P(t) || M(t)) : this;
                                if (e = t._southWest, n = t._northEast, !e || !n) return this
                            }
                            return i || o ? (i.lat = Math.min(e.lat, i.lat), i.lng = Math.min(e.lng, i.lng), o.lat = Math.max(n.lat, o.lat), o.lng = Math.max(n.lng, o.lng)) : (this._southWest = new S(e.lat, e.lng), this._northEast = new S(n.lat, n.lng)), this
                        },
                        pad: function(t) {
                            var e = this._southWest,
                                n = this._northEast,
                                i = Math.abs(e.lat - n.lat) * t,
                                o = Math.abs(e.lng - n.lng) * t;
                            return new w(new S(e.lat - i, e.lng - o), new S(n.lat + i, n.lng + o))
                        },
                        getCenter: function() {
                            return new S((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2)
                        },
                        getSouthWest: function() {
                            return this._southWest
                        },
                        getNorthEast: function() {
                            return this._northEast
                        },
                        getNorthWest: function() {
                            return new S(this.getNorth(), this.getWest())
                        },
                        getSouthEast: function() {
                            return new S(this.getSouth(), this.getEast())
                        },
                        getWest: function() {
                            return this._southWest.lng
                        },
                        getSouth: function() {
                            return this._southWest.lat
                        },
                        getEast: function() {
                            return this._northEast.lng
                        },
                        getNorth: function() {
                            return this._northEast.lat
                        },
                        contains: function(t) {
                            t = "number" == typeof t[0] || t instanceof S || "lat" in t ? P(t) : M(t);
                            var e, n, i = this._southWest,
                                o = this._northEast;
                            return t instanceof w ? (e = t.getSouthWest(), n = t.getNorthEast()) : e = n = t, e.lat >= i.lat && n.lat <= o.lat && e.lng >= i.lng && n.lng <= o.lng
                        },
                        intersects: function(t) {
                            t = M(t);
                            var e = this._southWest,
                                n = this._northEast,
                                i = t.getSouthWest(),
                                o = t.getNorthEast(),
                                r = o.lat >= e.lat && i.lat <= n.lat,
                                s = o.lng >= e.lng && i.lng <= n.lng;
                            return r && s
                        },
                        overlaps: function(t) {
                            t = M(t);
                            var e = this._southWest,
                                n = this._northEast,
                                i = t.getSouthWest(),
                                o = t.getNorthEast(),
                                r = o.lat > e.lat && i.lat < n.lat,
                                s = o.lng > e.lng && i.lng < n.lng;
                            return r && s
                        },
                        toBBoxString: function() {
                            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",")
                        },
                        equals: function(t, e) {
                            return !!t && (t = M(t), this._southWest.equals(t.getSouthWest(), e) && this._northEast.equals(t.getNorthEast(), e))
                        },
                        isValid: function() {
                            return !(!this._southWest || !this._northEast)
                        }
                    }, S.prototype = {
                        equals: function(t, e) {
                            return !!t && (t = P(t), Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng)) <= (void 0 === e ? 1e-9 : e))
                        },
                        toString: function(t) {
                            return "LatLng(" + h(this.lat, t) + ", " + h(this.lng, t) + ")"
                        },
                        distanceTo: function(t) {
                            return Me.distance(this, P(t))
                        },
                        wrap: function() {
                            return Me.wrapLatLng(this)
                        },
                        toBounds: function(t) {
                            var e = 180 * t / 40075017,
                                n = e / Math.cos(Math.PI / 180 * this.lat);
                            return M([this.lat - e, this.lng - n], [this.lat + e, this.lng + n])
                        },
                        clone: function() {
                            return new S(this.lat, this.lng, this.alt)
                        }
                    };
                    var we = {
                            latLngToPoint: function(t, e) {
                                var n = this.projection.project(t),
                                    i = this.scale(e);
                                return this.transformation._transform(n, i)
                            },
                            pointToLatLng: function(t, e) {
                                var n = this.scale(e),
                                    i = this.transformation.untransform(t, n);
                                return this.projection.unproject(i)
                            },
                            project: function(t) {
                                return this.projection.project(t)
                            },
                            unproject: function(t) {
                                return this.projection.unproject(t)
                            },
                            scale: function(t) {
                                return 256 * Math.pow(2, t)
                            },
                            zoom: function(t) {
                                return Math.log(t / 256) / Math.LN2
                            },
                            getProjectedBounds: function(t) {
                                if (this.infinite) return null;
                                var e = this.projection.bounds,
                                    n = this.scale(t);
                                return new C(this.transformation.transform(e.min, n), this.transformation.transform(e.max, n))
                            },
                            infinite: !1,
                            wrapLatLng: function(t) {
                                var e = this.wrapLng ? s(t.lng, this.wrapLng, !0) : t.lng;
                                return new S(this.wrapLat ? s(t.lat, this.wrapLat, !0) : t.lat, e, t.alt)
                            },
                            wrapLatLngBounds: function(t) {
                                var e = t.getCenter(),
                                    n = this.wrapLatLng(e),
                                    i = e.lat - n.lat,
                                    o = e.lng - n.lng;
                                if (0 === i && 0 === o) return t;
                                var r = t.getSouthWest(),
                                    s = t.getNorthEast();
                                return new w(new S(r.lat - i, r.lng - o), new S(s.lat - i, s.lng - o))
                            }
                        },
                        Me = e({}, we, {
                            wrapLng: [-180, 180],
                            R: 6371e3,
                            distance: function(t, e) {
                                var n = Math.PI / 180,
                                    i = t.lat * n,
                                    o = e.lat * n,
                                    r = Math.sin((e.lat - t.lat) * n / 2),
                                    s = Math.sin((e.lng - t.lng) * n / 2),
                                    a = r * r + Math.cos(i) * Math.cos(o) * s * s,
                                    h = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                                return this.R * h
                            }
                        }),
                        Se = {
                            R: 6378137,
                            MAX_LATITUDE: 85.0511287798,
                            project: function(t) {
                                var e = Math.PI / 180,
                                    n = this.MAX_LATITUDE,
                                    i = Math.max(Math.min(n, t.lat), -n),
                                    o = Math.sin(i * e);
                                return new b(this.R * t.lng * e, this.R * Math.log((1 + o) / (1 - o)) / 2)
                            },
                            unproject: function(t) {
                                var e = 180 / Math.PI;
                                return new S((2 * Math.atan(Math.exp(t.y / this.R)) - Math.PI / 2) * e, t.x * e / this.R)
                            },
                            bounds: function() {
                                var t = 6378137 * Math.PI;
                                return new C([-t, -t], [t, t])
                            }()
                        };
                    N.prototype = {
                        transform: function(t, e) {
                            return this._transform(t.clone(), e)
                        },
                        _transform: function(t, e) {
                            return e = e || 1, t.x = e * (this._a * t.x + this._b), t.y = e * (this._c * t.y + this._d), t
                        },
                        untransform: function(t, e) {
                            return e = e || 1, new b((t.x / e - this._b) / this._a, (t.y / e - this._d) / this._c)
                        }
                    };
                    var Pe, Ne, Te, Oe, Ae = e({}, Me, {
                            code: "EPSG:3857",
                            projection: Se,
                            transformation: function() {
                                var t = .5 / (Math.PI * Se.R);
                                return T(t, .5, -t, .5)
                            }()
                        }),
                        Re = e({}, Ae, {
                            code: "EPSG:900913"
                        }),
                        De = document.documentElement.style,
                        ke = "ActiveXObject" in window,
                        Fe = ke && !document.addEventListener,
                        ze = "msLaunchUri" in navigator && !("documentMode" in document),
                        Be = R("webkit"),
                        Ge = R("android"),
                        Ue = R("android 2") || R("android 3"),
                        je = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10),
                        qe = Ge && R("Google") && je < 537 && !("AudioNode" in window),
                        Ze = !!window.opera,
                        Ve = R("chrome"),
                        He = R("gecko") && !Be && !Ze && !ke,
                        Ye = !Ve && R("safari"),
                        We = R("phantom"),
                        Xe = "OTransition" in De,
                        Je = 0 === navigator.platform.indexOf("Win"),
                        Ke = ke && "transition" in De,
                        Qe = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix && !Ue,
                        $e = "MozPerspective" in De,
                        tn = !window.L_DISABLE_3D && (Ke || Qe || $e) && !Xe && !We,
                        en = "undefined" != typeof orientation || R("mobile"),
                        nn = en && Be,
                        on = en && Qe,
                        rn = !window.PointerEvent && window.MSPointerEvent,
                        sn = !(!window.PointerEvent && !rn),
                        an = !window.L_NO_TOUCH && (sn || "ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch),
                        hn = en && Ze,
                        un = en && He,
                        ln = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1,
                        cn = function() {
                            return !!document.createElement("canvas").getContext
                        }(),
                        pn = !(!document.createElementNS || !O("svg").createSVGRect),
                        fn = !pn && function() {
                            try {
                                var t = document.createElement("div");
                                t.innerHTML = '<v:shape adj="1"/>';
                                var e = t.firstChild;
                                return e.style.behavior = "url(#default#VML)", e && "object" === n(e.adj)
                            } catch (t) {
                                return !1
                            }
                        }(),
                        dn = (Object.freeze || Object)({
                            ie: ke,
                            ielt9: Fe,
                            edge: ze,
                            webkit: Be,
                            android: Ge,
                            android23: Ue,
                            androidStock: qe,
                            opera: Ze,
                            chrome: Ve,
                            gecko: He,
                            safari: Ye,
                            phantom: We,
                            opera12: Xe,
                            win: Je,
                            ie3d: Ke,
                            webkit3d: Qe,
                            gecko3d: $e,
                            any3d: tn,
                            mobile: en,
                            mobileWebkit: nn,
                            mobileWebkit3d: on,
                            msPointer: rn,
                            pointer: sn,
                            touch: an,
                            mobileOpera: hn,
                            mobileGecko: un,
                            retina: ln,
                            canvas: cn,
                            svg: pn,
                            vml: fn
                        }),
                        _n = rn ? "MSPointerDown" : "pointerdown",
                        gn = rn ? "MSPointerMove" : "pointermove",
                        mn = rn ? "MSPointerUp" : "pointerup",
                        yn = rn ? "MSPointerCancel" : "pointercancel",
                        vn = ["INPUT", "SELECT", "OPTION"],
                        Ln = {},
                        xn = !1,
                        bn = 0,
                        En = rn ? "MSPointerDown" : sn ? "pointerdown" : "touchstart",
                        Cn = rn ? "MSPointerUp" : sn ? "pointerup" : "touchend",
                        In = "_leaflet_",
                        wn = "_leaflet_events",
                        Mn = Je && Ve ? 2 * window.devicePixelRatio : He ? window.devicePixelRatio : 1,
                        Sn = {},
                        Pn = (Object.freeze || Object)({
                            on: H,
                            off: Y,
                            stopPropagation: J,
                            disableScrollPropagation: K,
                            disableClickPropagation: Q,
                            preventDefault: $,
                            stop: tt,
                            getMousePosition: et,
                            getWheelDelta: nt,
                            fakeStop: it,
                            skipped: ot,
                            isExternalTarget: rt,
                            addListener: H,
                            removeListener: Y
                        }),
                        Nn = xt(["transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform"]),
                        Tn = xt(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]),
                        On = "webkitTransition" === Tn || "OTransition" === Tn ? Tn + "End" : "transitionend";
                    if ("onselectstart" in document) Ne = function() {
                        H(window, "selectstart", $)
                    }, Te = function() {
                        Y(window, "selectstart", $)
                    };
                    else {
                        var An = xt(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
                        Ne = function() {
                            if (An) {
                                var t = document.documentElement.style;
                                Oe = t[An], t[An] = "none"
                            }
                        }, Te = function() {
                            An && (document.documentElement.style[An] = Oe, Oe = void 0)
                        }
                    }
                    var Rn, Dn, kn = (Object.freeze || Object)({
                            TRANSFORM: Nn,
                            TRANSITION: Tn,
                            TRANSITION_END: On,
                            get: at,
                            getStyle: ht,
                            create: ut,
                            remove: lt,
                            empty: ct,
                            toFront: pt,
                            toBack: ft,
                            hasClass: dt,
                            addClass: _t,
                            removeClass: gt,
                            setClass: mt,
                            getClass: yt,
                            setOpacity: vt,
                            testProp: xt,
                            setTransform: bt,
                            setPosition: Et,
                            getPosition: Ct,
                            disableTextSelection: Ne,
                            enableTextSelection: Te,
                            disableImageDrag: It,
                            enableImageDrag: wt,
                            preventOutline: Mt,
                            restoreOutline: St
                        }),
                        Fn = Ce.extend({
                            run: function(t, e, n, i) {
                                this.stop(), this._el = t, this._inProgress = !0, this._duration = n || .25, this._easeOutPower = 1 / Math.max(i || .5, .2), this._startPos = Ct(t), this._offset = e.subtract(this._startPos), this._startTime = +new Date, this.fire("start"), this._animate()
                            },
                            stop: function() {
                                this._inProgress && (this._step(!0), this._complete())
                            },
                            _animate: function() {
                                this._animId = m(this._animate, this), this._step()
                            },
                            _step: function(t) {
                                var e = +new Date - this._startTime,
                                    n = 1e3 * this._duration;
                                e < n ? this._runFrame(this._easeOut(e / n), t) : (this._runFrame(1), this._complete())
                            },
                            _runFrame: function(t, e) {
                                var n = this._startPos.add(this._offset.multiplyBy(t));
                                e && n._round(), Et(this._el, n), this.fire("step")
                            },
                            _complete: function() {
                                y(this._animId), this._inProgress = !1, this.fire("end")
                            },
                            _easeOut: function(t) {
                                return 1 - Math.pow(1 - t, this._easeOutPower)
                            }
                        }),
                        zn = Ce.extend({
                            options: {
                                crs: Ae,
                                center: void 0,
                                zoom: void 0,
                                minZoom: void 0,
                                maxZoom: void 0,
                                layers: [],
                                maxBounds: void 0,
                                renderer: void 0,
                                zoomAnimation: !0,
                                zoomAnimationThreshold: 4,
                                fadeAnimation: !0,
                                markerZoomAnimation: !0,
                                transform3DLimit: 8388608,
                                zoomSnap: 1,
                                zoomDelta: 1,
                                trackResize: !0
                            },
                            initialize: function(t, e) {
                                e = c(this, e), this._initContainer(t), this._initLayout(), this._onResize = i(this._onResize, this), this._initEvents(), e.maxBounds && this.setMaxBounds(e.maxBounds), void 0 !== e.zoom && (this._zoom = this._limitZoom(e.zoom)), e.center && void 0 !== e.zoom && this.setView(P(e.center), e.zoom, {
                                    reset: !0
                                }), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = !0, this.callInitHooks(), this._zoomAnimated = Tn && tn && !hn && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), H(this._proxy, On, this._catchTransitionEnd, this)), this._addLayers(this.options.layers)
                            },
                            setView: function(t, n, i) {
                                if (n = void 0 === n ? this._zoom : this._limitZoom(n), t = this._limitCenter(P(t), n, this.options.maxBounds), i = i || {}, this._stop(), this._loaded && !i.reset && !0 !== i) {
                                    void 0 !== i.animate && (i.zoom = e({
                                        animate: i.animate
                                    }, i.zoom), i.pan = e({
                                        animate: i.animate,
                                        duration: i.duration
                                    }, i.pan));
                                    if (this._zoom !== n ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, n, i.zoom) : this._tryAnimatedPan(t, i.pan)) return clearTimeout(this._sizeTimer), this
                                }
                                return this._resetView(t, n), this
                            },
                            setZoom: function(t, e) {
                                return this._loaded ? this.setView(this.getCenter(), t, {
                                    zoom: e
                                }) : (this._zoom = t, this)
                            },
                            zoomIn: function(t, e) {
                                return t = t || (tn ? this.options.zoomDelta : 1), this.setZoom(this._zoom + t, e)
                            },
                            zoomOut: function(t, e) {
                                return t = t || (tn ? this.options.zoomDelta : 1), this.setZoom(this._zoom - t, e)
                            },
                            setZoomAround: function(t, e, n) {
                                var i = this.getZoomScale(e),
                                    o = this.getSize().divideBy(2),
                                    r = t instanceof b ? t : this.latLngToContainerPoint(t),
                                    s = r.subtract(o).multiplyBy(1 - 1 / i),
                                    a = this.containerPointToLatLng(o.add(s));
                                return this.setView(a, e, {
                                    zoom: n
                                })
                            },
                            _getBoundsCenterZoom: function(t, e) {
                                e = e || {}, t = t.getBounds ? t.getBounds() : M(t);
                                var n = E(e.paddingTopLeft || e.padding || [0, 0]),
                                    i = E(e.paddingBottomRight || e.padding || [0, 0]),
                                    o = this.getBoundsZoom(t, !1, n.add(i));
                                if ((o = "number" == typeof e.maxZoom ? Math.min(e.maxZoom, o) : o) === 1 / 0) return {
                                    center: t.getCenter(),
                                    zoom: o
                                };
                                var r = i.subtract(n).divideBy(2),
                                    s = this.project(t.getSouthWest(), o),
                                    a = this.project(t.getNorthEast(), o);
                                return {
                                    center: this.unproject(s.add(a).divideBy(2).add(r), o),
                                    zoom: o
                                }
                            },
                            fitBounds: function(t, e) {
                                if (t = M(t), !t.isValid()) throw new Error("Bounds are not valid.");
                                var n = this._getBoundsCenterZoom(t, e);
                                return this.setView(n.center, n.zoom, e)
                            },
                            fitWorld: function(t) {
                                return this.fitBounds([
                                    [-90, -180],
                                    [90, 180]
                                ], t)
                            },
                            panTo: function(t, e) {
                                return this.setView(t, this._zoom, {
                                    pan: e
                                })
                            },
                            panBy: function(t, e) {
                                if (t = E(t).round(), e = e || {}, !t.x && !t.y) return this.fire("moveend");
                                if (!0 !== e.animate && !this.getSize().contains(t)) return this._resetView(this.unproject(this.project(this.getCenter()).add(t)), this.getZoom()), this;
                                if (this._panAnim || (this._panAnim = new Fn, this._panAnim.on({
                                    step: this._onPanTransitionStep,
                                    end: this._onPanTransitionEnd
                                }, this)), e.noMoveStart || this.fire("movestart"), !1 !== e.animate) {
                                    _t(this._mapPane, "leaflet-pan-anim");
                                    var n = this._getMapPanePos().subtract(t).round();
                                    this._panAnim.run(this._mapPane, n, e.duration || .25, e.easeLinearity)
                                } else this._rawPanBy(t), this.fire("move").fire("moveend");
                                return this
                            },
                            flyTo: function(t, e, n) {
                                function i(t) {
                                    var e = t ? -1 : 1,
                                        n = t ? g : _,
                                        i = g * g - _ * _ + e * L * L * y * y,
                                        o = 2 * n * L * y,
                                        r = i / o,
                                        s = Math.sqrt(r * r + 1) - r;
                                    return s < 1e-9 ? -18 : Math.log(s)
                                }

                                function o(t) {
                                    return (Math.exp(t) - Math.exp(-t)) / 2
                                }

                                function r(t) {
                                    return (Math.exp(t) + Math.exp(-t)) / 2
                                }

                                function s(t) {
                                    return o(t) / r(t)
                                }

                                function a(t) {
                                    return _ * (r(x) / r(x + v * t))
                                }

                                function h(t) {
                                    return _ * (r(x) * s(x + v * t) - o(x)) / L
                                }

                                function u(t) {
                                    return 1 - Math.pow(1 - t, 1.5)
                                }

                                function l() {
                                    var n = (Date.now() - b) / C,
                                        i = u(n) * E;
                                    n <= 1 ? (this._flyToFrame = m(l, this), this._move(this.unproject(c.add(p.subtract(c).multiplyBy(h(i) / y)), d), this.getScaleZoom(_ / a(i), d), {
                                        flyTo: !0
                                    })) : this._move(t, e)._moveEnd(!0)
                                }
                                if (n = n || {}, !1 === n.animate || !tn) return this.setView(t, e, n);
                                this._stop();
                                var c = this.project(this.getCenter()),
                                    p = this.project(t),
                                    f = this.getSize(),
                                    d = this._zoom;
                                t = P(t), e = void 0 === e ? d : e;
                                var _ = Math.max(f.x, f.y),
                                    g = _ * this.getZoomScale(d, e),
                                    y = p.distanceTo(c) || 1,
                                    v = 1.42,
                                    L = v * v,
                                    x = i(0),
                                    b = Date.now(),
                                    E = (i(1) - x) / v,
                                    C = n.duration ? 1e3 * n.duration : 1e3 * E * .8;
                                return this._moveStart(!0, n.noMoveStart), l.call(this), this
                            },
                            flyToBounds: function(t, e) {
                                var n = this._getBoundsCenterZoom(t, e);
                                return this.flyTo(n.center, n.zoom, e)
                            },
                            setMaxBounds: function(t) {
                                return t = M(t), t.isValid() ? (this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), this.options.maxBounds = t, this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null, this.off("moveend", this._panInsideMaxBounds))
                            },
                            setMinZoom: function(t) {
                                var e = this.options.minZoom;
                                return this.options.minZoom = t, this._loaded && e !== t && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(t) : this
                            },
                            setMaxZoom: function(t) {
                                var e = this.options.maxZoom;
                                return this.options.maxZoom = t, this._loaded && e !== t && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(t) : this
                            },
                            panInsideBounds: function(t, e) {
                                this._enforcingBounds = !0;
                                var n = this.getCenter(),
                                    i = this._limitCenter(n, this._zoom, M(t));
                                return n.equals(i) || this.panTo(i, e), this._enforcingBounds = !1, this
                            },
                            invalidateSize: function(t) {
                                if (!this._loaded) return this;
                                t = e({
                                    animate: !1,
                                    pan: !0
                                }, !0 === t ? {
                                    animate: !0
                                } : t);
                                var n = this.getSize();
                                this._sizeChanged = !0, this._lastCenter = null;
                                var o = this.getSize(),
                                    r = n.divideBy(2).round(),
                                    s = o.divideBy(2).round(),
                                    a = r.subtract(s);
                                return a.x || a.y ? (t.animate && t.pan ? this.panBy(a) : (t.pan && this._rawPanBy(a), this.fire("move"), t.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(i(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", {
                                    oldSize: n,
                                    newSize: o
                                })) : this
                            },
                            stop: function() {
                                return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire("viewreset"), this._stop()
                            },
                            locate: function(t) {
                                if (t = this._locateOptions = e({
                                    timeout: 1e4,
                                    watch: !1
                                }, t), !("geolocation" in navigator)) return this._handleGeolocationError({
                                    code: 0,
                                    message: "Geolocation not supported."
                                }), this;
                                var n = i(this._handleGeolocationResponse, this),
                                    o = i(this._handleGeolocationError, this);
                                return t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(n, o, t) : navigator.geolocation.getCurrentPosition(n, o, t), this
                            },
                            stopLocate: function() {
                                return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this
                            },
                            _handleGeolocationError: function(t) {
                                var e = t.code,
                                    n = t.message || (1 === e ? "permission denied" : 2 === e ? "position unavailable" : "timeout");
                                this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", {
                                    code: e,
                                    message: "Geolocation error: " + n + "."
                                })
                            },
                            _handleGeolocationResponse: function(t) {
                                var e = t.coords.latitude,
                                    n = t.coords.longitude,
                                    i = new S(e, n),
                                    o = i.toBounds(t.coords.accuracy),
                                    r = this._locateOptions;
                                if (r.setView) {
                                    var s = this.getBoundsZoom(o);
                                    this.setView(i, r.maxZoom ? Math.min(s, r.maxZoom) : s)
                                }
                                var a = {
                                    latlng: i,
                                    bounds: o,
                                    timestamp: t.timestamp
                                };
                                for (var h in t.coords) "number" == typeof t.coords[h] && (a[h] = t.coords[h]);
                                this.fire("locationfound", a)
                            },
                            addHandler: function(t, e) {
                                if (!e) return this;
                                var n = this[t] = new e(this);
                                return this._handlers.push(n), this.options[t] && n.enable(), this
                            },
                            remove: function() {
                                if (this._initEvents(!0), this._containerId !== this._container._leaflet_id) throw new Error("Map container is being reused by another instance");
                                try {
                                    delete this._container._leaflet_id, delete this._containerId
                                } catch (t) {
                                    this._container._leaflet_id = void 0, this._containerId = void 0
                                }
                                void 0 !== this._locationWatchId && this.stopLocate(), this._stop(), lt(this._mapPane), this._clearControlPos && this._clearControlPos(), this._clearHandlers(), this._loaded && this.fire("unload");
                                var t;
                                for (t in this._layers) this._layers[t].remove();
                                for (t in this._panes) lt(this._panes[t]);
                                return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this
                            },
                            createPane: function(t, e) {
                                var n = "leaflet-pane" + (t ? " leaflet-" + t.replace("Pane", "") + "-pane" : ""),
                                    i = ut("div", n, e || this._mapPane);
                                return t && (this._panes[t] = i), i
                            },
                            getCenter: function() {
                                return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter : this.layerPointToLatLng(this._getCenterLayerPoint())
                            },
                            getZoom: function() {
                                return this._zoom
                            },
                            getBounds: function() {
                                var t = this.getPixelBounds();
                                return new w(this.unproject(t.getBottomLeft()), this.unproject(t.getTopRight()))
                            },
                            getMinZoom: function() {
                                return void 0 === this.options.minZoom ? this._layersMinZoom || 0 : this.options.minZoom
                            },
                            getMaxZoom: function() {
                                return void 0 === this.options.maxZoom ? void 0 === this._layersMaxZoom ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom
                            },
                            getBoundsZoom: function(t, e, n) {
                                t = M(t), n = E(n || [0, 0]);
                                var i = this.getZoom() || 0,
                                    o = this.getMinZoom(),
                                    r = this.getMaxZoom(),
                                    s = t.getNorthWest(),
                                    a = t.getSouthEast(),
                                    h = this.getSize().subtract(n),
                                    u = I(this.project(a, i), this.project(s, i)).getSize(),
                                    l = tn ? this.options.zoomSnap : 1,
                                    c = h.x / u.x,
                                    p = h.y / u.y,
                                    f = e ? Math.max(c, p) : Math.min(c, p);
                                return i = this.getScaleZoom(f, i), l && (i = Math.round(i / (l / 100)) * (l / 100), i = e ? Math.ceil(i / l) * l : Math.floor(i / l) * l), Math.max(o, Math.min(r, i))
                            },
                            getSize: function() {
                                return this._size && !this._sizeChanged || (this._size = new b(this._container.clientWidth || 0, this._container.clientHeight || 0), this._sizeChanged = !1), this._size.clone()
                            },
                            getPixelBounds: function(t, e) {
                                var n = this._getTopLeftPoint(t, e);
                                return new C(n, n.add(this.getSize()))
                            },
                            getPixelOrigin: function() {
                                return this._checkIfLoaded(), this._pixelOrigin
                            },
                            getPixelWorldBounds: function(t) {
                                return this.options.crs.getProjectedBounds(void 0 === t ? this.getZoom() : t)
                            },
                            getPane: function(t) {
                                return "string" == typeof t ? this._panes[t] : t
                            },
                            getPanes: function() {
                                return this._panes
                            },
                            getContainer: function() {
                                return this._container
                            },
                            getZoomScale: function(t, e) {
                                var n = this.options.crs;
                                return e = void 0 === e ? this._zoom : e, n.scale(t) / n.scale(e)
                            },
                            getScaleZoom: function(t, e) {
                                var n = this.options.crs;
                                e = void 0 === e ? this._zoom : e;
                                var i = n.zoom(t * n.scale(e));
                                return isNaN(i) ? 1 / 0 : i
                            },
                            project: function(t, e) {
                                return e = void 0 === e ? this._zoom : e, this.options.crs.latLngToPoint(P(t), e)
                            },
                            unproject: function(t, e) {
                                return e = void 0 === e ? this._zoom : e, this.options.crs.pointToLatLng(E(t), e)
                            },
                            layerPointToLatLng: function(t) {
                                var e = E(t).add(this.getPixelOrigin());
                                return this.unproject(e)
                            },
                            latLngToLayerPoint: function(t) {
                                return this.project(P(t))._round()._subtract(this.getPixelOrigin())
                            },
                            wrapLatLng: function(t) {
                                return this.options.crs.wrapLatLng(P(t))
                            },
                            wrapLatLngBounds: function(t) {
                                return this.options.crs.wrapLatLngBounds(M(t))
                            },
                            distance: function(t, e) {
                                return this.options.crs.distance(P(t), P(e))
                            },
                            containerPointToLayerPoint: function(t) {
                                return E(t).subtract(this._getMapPanePos())
                            },
                            layerPointToContainerPoint: function(t) {
                                return E(t).add(this._getMapPanePos())
                            },
                            containerPointToLatLng: function(t) {
                                var e = this.containerPointToLayerPoint(E(t));
                                return this.layerPointToLatLng(e)
                            },
                            latLngToContainerPoint: function(t) {
                                return this.layerPointToContainerPoint(this.latLngToLayerPoint(P(t)))
                            },
                            mouseEventToContainerPoint: function(t) {
                                return et(t, this._container)
                            },
                            mouseEventToLayerPoint: function(t) {
                                return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))
                            },
                            mouseEventToLatLng: function(t) {
                                return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))
                            },
                            _initContainer: function(t) {
                                var e = this._container = at(t);
                                if (!e) throw new Error("Map container not found.");
                                if (e._leaflet_id) throw new Error("Map container is already initialized.");
                                H(e, "scroll", this._onScroll, this), this._containerId = o(e)
                            },
                            _initLayout: function() {
                                var t = this._container;
                                this._fadeAnimated = this.options.fadeAnimation && tn, _t(t, "leaflet-container" + (an ? " leaflet-touch" : "") + (ln ? " leaflet-retina" : "") + (Fe ? " leaflet-oldie" : "") + (Ye ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
                                var e = ht(t, "position");
                                "absolute" !== e && "relative" !== e && "fixed" !== e && (t.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos()
                            },
                            _initPanes: function() {
                                var t = this._panes = {};
                                this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), Et(this._mapPane, new b(0, 0)), this.createPane("tilePane"), this.createPane("shadowPane"), this.createPane("overlayPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane"), this.options.markerZoomAnimation || (_t(t.markerPane, "leaflet-zoom-hide"), _t(t.shadowPane, "leaflet-zoom-hide"))
                            },
                            _resetView: function(t, e) {
                                Et(this._mapPane, new b(0, 0));
                                var n = !this._loaded;
                                this._loaded = !0, e = this._limitZoom(e), this.fire("viewprereset");
                                var i = this._zoom !== e;
                                this._moveStart(i, !1)._move(t, e)._moveEnd(i), this.fire("viewreset"), n && this.fire("load")
                            },
                            _moveStart: function(t, e) {
                                return t && this.fire("zoomstart"), e || this.fire("movestart"), this
                            },
                            _move: function(t, e, n) {
                                void 0 === e && (e = this._zoom);
                                var i = this._zoom !== e;
                                return this._zoom = e, this._lastCenter = t, this._pixelOrigin = this._getNewPixelOrigin(t), (i || n && n.pinch) && this.fire("zoom", n), this.fire("move", n)
                            },
                            _moveEnd: function(t) {
                                return t && this.fire("zoomend"), this.fire("moveend")
                            },
                            _stop: function() {
                                return y(this._flyToFrame), this._panAnim && this._panAnim.stop(), this
                            },
                            _rawPanBy: function(t) {
                                Et(this._mapPane, this._getMapPanePos().subtract(t))
                            },
                            _getZoomSpan: function() {
                                return this.getMaxZoom() - this.getMinZoom()
                            },
                            _panInsideMaxBounds: function() {
                                this._enforcingBounds || this.panInsideBounds(this.options.maxBounds)
                            },
                            _checkIfLoaded: function() {
                                if (!this._loaded) throw new Error("Set map center and zoom first.")
                            },
                            _initEvents: function(t) {
                                this._targets = {}, this._targets[o(this._container)] = this;
                                var e = t ? Y : H;
                                e(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress", this._handleDOMEvent, this), this.options.trackResize && e(window, "resize", this._onResize, this), tn && this.options.transform3DLimit && (t ? this.off : this.on).call(this, "moveend", this._onMoveEnd)
                            },
                            _onResize: function() {
                                y(this._resizeRequest), this._resizeRequest = m(function() {
                                    this.invalidateSize({
                                        debounceMoveend: !0
                                    })
                                }, this)
                            },
                            _onScroll: function() {
                                this._container.scrollTop = 0, this._container.scrollLeft = 0
                            },
                            _onMoveEnd: function() {
                                var t = this._getMapPanePos();
                                Math.max(Math.abs(t.x), Math.abs(t.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom())
                            },
                            _findEventTargets: function(t, e) {
                                for (var n, i = [], r = "mouseout" === e || "mouseover" === e, s = t.target || t.srcElement, a = !1; s;) {
                                    if ((n = this._targets[o(s)]) && ("click" === e || "preclick" === e) && !t._simulated && this._draggableMoved(n)) {
                                        a = !0;
                                        break
                                    }
                                    if (n && n.listens(e, !0)) {
                                        if (r && !rt(s, t)) break;
                                        if (i.push(n), r) break
                                    }
                                    if (s === this._container) break;
                                    s = s.parentNode
                                }
                                return i.length || a || r || !rt(s, t) || (i = [this]), i
                            },
                            _handleDOMEvent: function(t) {
                                if (this._loaded && !ot(t)) {
                                    var e = t.type;
                                    "mousedown" !== e && "keypress" !== e || Mt(t.target || t.srcElement), this._fireDOMEvent(t, e)
                                }
                            },
                            _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
                            _fireDOMEvent: function(t, n, i) {
                                if ("click" === t.type) {
                                    var o = e({}, t);
                                    o.type = "preclick", this._fireDOMEvent(o, o.type, i)
                                }
                                if (!t._stopped && (i = (i || []).concat(this._findEventTargets(t, n)), i.length)) {
                                    var r = i[0];
                                    "contextmenu" === n && r.listens(n, !0) && $(t);
                                    var s = {
                                        originalEvent: t
                                    };
                                    if ("keypress" !== t.type) {
                                        var a = r.getLatLng && (!r._radius || r._radius <= 10);
                                        s.containerPoint = a ? this.latLngToContainerPoint(r.getLatLng()) : this.mouseEventToContainerPoint(t), s.layerPoint = this.containerPointToLayerPoint(s.containerPoint), s.latlng = a ? r.getLatLng() : this.layerPointToLatLng(s.layerPoint)
                                    }
                                    for (var h = 0; h < i.length; h++)
                                        if (i[h].fire(n, s, !0), s.originalEvent._stopped || !1 === i[h].options.bubblingMouseEvents && -1 !== d(this._mouseEvents, n)) return
                                }
                            },
                            _draggableMoved: function(t) {
                                return t = t.dragging && t.dragging.enabled() ? t : this, t.dragging && t.dragging.moved() || this.boxZoom && this.boxZoom.moved()
                            },
                            _clearHandlers: function() {
                                for (var t = 0, e = this._handlers.length; t < e; t++) this._handlers[t].disable()
                            },
                            whenReady: function(t, e) {
                                return this._loaded ? t.call(e || this, {
                                    target: this
                                }) : this.on("load", t, e), this
                            },
                            _getMapPanePos: function() {
                                return Ct(this._mapPane) || new b(0, 0)
                            },
                            _moved: function() {
                                var t = this._getMapPanePos();
                                return t && !t.equals([0, 0])
                            },
                            _getTopLeftPoint: function(t, e) {
                                return (t && void 0 !== e ? this._getNewPixelOrigin(t, e) : this.getPixelOrigin()).subtract(this._getMapPanePos())
                            },
                            _getNewPixelOrigin: function(t, e) {
                                var n = this.getSize()._divideBy(2);
                                return this.project(t, e)._subtract(n)._add(this._getMapPanePos())._round()
                            },
                            _latLngToNewLayerPoint: function(t, e, n) {
                                var i = this._getNewPixelOrigin(n, e);
                                return this.project(t, e)._subtract(i)
                            },
                            _latLngBoundsToNewLayerBounds: function(t, e, n) {
                                var i = this._getNewPixelOrigin(n, e);
                                return I([this.project(t.getSouthWest(), e)._subtract(i), this.project(t.getNorthWest(), e)._subtract(i), this.project(t.getSouthEast(), e)._subtract(i), this.project(t.getNorthEast(), e)._subtract(i)])
                            },
                            _getCenterLayerPoint: function() {
                                return this.containerPointToLayerPoint(this.getSize()._divideBy(2))
                            },
                            _getCenterOffset: function(t) {
                                return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())
                            },
                            _limitCenter: function(t, e, n) {
                                if (!n) return t;
                                var i = this.project(t, e),
                                    o = this.getSize().divideBy(2),
                                    r = new C(i.subtract(o), i.add(o)),
                                    s = this._getBoundsOffset(r, n, e);
                                return s.round().equals([0, 0]) ? t : this.unproject(i.add(s), e)
                            },
                            _limitOffset: function(t, e) {
                                if (!e) return t;
                                var n = this.getPixelBounds(),
                                    i = new C(n.min.add(t), n.max.add(t));
                                return t.add(this._getBoundsOffset(i, e))
                            },
                            _getBoundsOffset: function(t, e, n) {
                                var i = I(this.project(e.getNorthEast(), n), this.project(e.getSouthWest(), n)),
                                    o = i.min.subtract(t.min),
                                    r = i.max.subtract(t.max);
                                return new b(this._rebound(o.x, -r.x), this._rebound(o.y, -r.y))
                            },
                            _rebound: function(t, e) {
                                return t + e > 0 ? Math.round(t - e) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(e))
                            },
                            _limitZoom: function(t) {
                                var e = this.getMinZoom(),
                                    n = this.getMaxZoom(),
                                    i = tn ? this.options.zoomSnap : 1;
                                return i && (t = Math.round(t / i) * i), Math.max(e, Math.min(n, t))
                            },
                            _onPanTransitionStep: function() {
                                this.fire("move")
                            },
                            _onPanTransitionEnd: function() {
                                gt(this._mapPane, "leaflet-pan-anim"), this.fire("moveend")
                            },
                            _tryAnimatedPan: function(t, e) {
                                var n = this._getCenterOffset(t)._trunc();
                                return !(!0 !== (e && e.animate) && !this.getSize().contains(n)) && (this.panBy(n, e), !0)
                            },
                            _createAnimProxy: function() {
                                var t = this._proxy = ut("div", "leaflet-proxy leaflet-zoom-animated");
                                this._panes.mapPane.appendChild(t), this.on("zoomanim", function(t) {
                                    var e = Nn,
                                        n = this._proxy.style[e];
                                    bt(this._proxy, this.project(t.center, t.zoom), this.getZoomScale(t.zoom, 1)), n === this._proxy.style[e] && this._animatingZoom && this._onZoomTransitionEnd()
                                }, this), this.on("load moveend", function() {
                                    var t = this.getCenter(),
                                        e = this.getZoom();
                                    bt(this._proxy, this.project(t, e), this.getZoomScale(e, 1))
                                }, this), this._on("unload", this._destroyAnimProxy, this)
                            },
                            _destroyAnimProxy: function() {
                                lt(this._proxy), delete this._proxy
                            },
                            _catchTransitionEnd: function(t) {
                                this._animatingZoom && t.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd()
                            },
                            _nothingToAnimate: function() {
                                return !this._container.getElementsByClassName("leaflet-zoom-animated").length
                            },
                            _tryAnimatedZoom: function(t, e, n) {
                                if (this._animatingZoom) return !0;
                                if (n = n || {}, !this._zoomAnimated || !1 === n.animate || this._nothingToAnimate() || Math.abs(e - this._zoom) > this.options.zoomAnimationThreshold) return !1;
                                var i = this.getZoomScale(e),
                                    o = this._getCenterOffset(t)._divideBy(1 - 1 / i);
                                return !(!0 !== n.animate && !this.getSize().contains(o)) && (m(function() {
                                    this._moveStart(!0, !1)._animateZoom(t, e, !0)
                                }, this), !0)
                            },
                            _animateZoom: function(t, e, n, o) {
                                this._mapPane && (n && (this._animatingZoom = !0, this._animateToCenter = t, this._animateToZoom = e, _t(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", {
                                    center: t,
                                    zoom: e,
                                    noUpdate: o
                                }), setTimeout(i(this._onZoomTransitionEnd, this), 250))
                            },
                            _onZoomTransitionEnd: function() {
                                this._animatingZoom && (this._mapPane && gt(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom), m(function() {
                                    this._moveEnd(!0)
                                }, this))
                            }
                        }),
                        Bn = v.extend({
                            options: {
                                position: "topright"
                            },
                            initialize: function(t) {
                                c(this, t)
                            },
                            getPosition: function() {
                                return this.options.position
                            },
                            setPosition: function(t) {
                                var e = this._map;
                                return e && e.removeControl(this), this.options.position = t, e && e.addControl(this), this
                            },
                            getContainer: function() {
                                return this._container
                            },
                            addTo: function(t) {
                                this.remove(), this._map = t;
                                var e = this._container = this.onAdd(t),
                                    n = this.getPosition(),
                                    i = t._controlCorners[n];
                                return _t(e, "leaflet-control"), -1 !== n.indexOf("bottom") ? i.insertBefore(e, i.firstChild) : i.appendChild(e), this
                            },
                            remove: function() {
                                return this._map ? (lt(this._container), this.onRemove && this.onRemove(this._map), this._map = null, this) : this
                            },
                            _refocusOnMap: function(t) {
                                this._map && t && t.screenX > 0 && t.screenY > 0 && this._map.getContainer().focus()
                            }
                        }),
                        Gn = function(t) {
                            return new Bn(t)
                        };
                    zn.include({
                        addControl: function(t) {
                            return t.addTo(this), this
                        },
                        removeControl: function(t) {
                            return t.remove(), this
                        },
                        _initControlPos: function() {
                            function t(t, o) {
                                var r = n + t + " " + n + o;
                                e[t + o] = ut("div", r, i)
                            }
                            var e = this._controlCorners = {},
                                n = "leaflet-",
                                i = this._controlContainer = ut("div", n + "control-container", this._container);
                            t("top", "left"), t("top", "right"), t("bottom", "left"), t("bottom", "right")
                        },
                        _clearControlPos: function() {
                            for (var t in this._controlCorners) lt(this._controlCorners[t]);
                            lt(this._controlContainer), delete this._controlCorners, delete this._controlContainer
                        }
                    });
                    var Un = Bn.extend({
                            options: {
                                collapsed: !0,
                                position: "topright",
                                autoZIndex: !0,
                                hideSingleBase: !1,
                                sortLayers: !1,
                                sortFunction: function(t, e, n, i) {
                                    return n < i ? -1 : i < n ? 1 : 0
                                }
                            },
                            initialize: function(t, e, n) {
                                c(this, n), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = !1;
                                for (var i in t) this._addLayer(t[i], i);
                                for (i in e) this._addLayer(e[i], i, !0)
                            },
                            onAdd: function(t) {
                                this._initLayout(), this._update(), this._map = t, t.on("zoomend", this._checkDisabledLayers, this);
                                for (var e = 0; e < this._layers.length; e++) this._layers[e].layer.on("add remove", this._onLayerChange, this);
                                return this._container
                            },
                            addTo: function(t) {
                                return Bn.prototype.addTo.call(this, t), this._expandIfNotCollapsed()
                            },
                            onRemove: function() {
                                this._map.off("zoomend", this._checkDisabledLayers, this);
                                for (var t = 0; t < this._layers.length; t++) this._layers[t].layer.off("add remove", this._onLayerChange, this)
                            },
                            addBaseLayer: function(t, e) {
                                return this._addLayer(t, e), this._map ? this._update() : this
                            },
                            addOverlay: function(t, e) {
                                return this._addLayer(t, e, !0), this._map ? this._update() : this
                            },
                            removeLayer: function(t) {
                                t.off("add remove", this._onLayerChange, this);
                                var e = this._getLayer(o(t));
                                return e && this._layers.splice(this._layers.indexOf(e), 1), this._map ? this._update() : this
                            },
                            expand: function() {
                                _t(this._container, "leaflet-control-layers-expanded"), this._form.style.height = null;
                                var t = this._map.getSize().y - (this._container.offsetTop + 50);
                                return t < this._form.clientHeight ? (_t(this._form, "leaflet-control-layers-scrollbar"), this._form.style.height = t + "px") : gt(this._form, "leaflet-control-layers-scrollbar"), this._checkDisabledLayers(), this
                            },
                            collapse: function() {
                                return gt(this._container, "leaflet-control-layers-expanded"), this
                            },
                            _initLayout: function() {
                                var t = "leaflet-control-layers",
                                    e = this._container = ut("div", t),
                                    n = this.options.collapsed;
                                e.setAttribute("aria-haspopup", !0), Q(e), K(e);
                                var i = this._form = ut("form", t + "-list");
                                n && (this._map.on("click", this.collapse, this), Ge || H(e, {
                                    mouseenter: this.expand,
                                    mouseleave: this.collapse
                                }, this));
                                var o = this._layersLink = ut("a", t + "-toggle", e);
                                o.href = "#", o.title = "Layers", an ? (H(o, "click", tt), H(o, "click", this.expand, this)) : H(o, "focus", this.expand, this), n || this.expand(), this._baseLayersList = ut("div", t + "-base", i), this._separator = ut("div", t + "-separator", i), this._overlaysList = ut("div", t + "-overlays", i), e.appendChild(i)
                            },
                            _getLayer: function(t) {
                                for (var e = 0; e < this._layers.length; e++)
                                    if (this._layers[e] && o(this._layers[e].layer) === t) return this._layers[e]
                            },
                            _addLayer: function(t, e, n) {
                                this._map && t.on("add remove", this._onLayerChange, this), this._layers.push({
                                    layer: t,
                                    name: e,
                                    overlay: n
                                }), this.options.sortLayers && this._layers.sort(i(function(t, e) {
                                    return this.options.sortFunction(t.layer, e.layer, t.name, e.name)
                                }, this)), this.options.autoZIndex && t.setZIndex && (this._lastZIndex++, t.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed()
                            },
                            _update: function() {
                                if (!this._container) return this;
                                ct(this._baseLayersList), ct(this._overlaysList), this._layerControlInputs = [];
                                var t, e, n, i, o = 0;
                                for (n = 0; n < this._layers.length; n++) i = this._layers[n], this._addItem(i), e = e || i.overlay, t = t || !i.overlay, o += i.overlay ? 0 : 1;
                                return this.options.hideSingleBase && (t = t && o > 1, this._baseLayersList.style.display = t ? "" : "none"), this._separator.style.display = e && t ? "" : "none", this
                            },
                            _onLayerChange: function(t) {
                                this._handlingClick || this._update();
                                var e = this._getLayer(o(t.target)),
                                    n = e.overlay ? "add" === t.type ? "overlayadd" : "overlayremove" : "add" === t.type ? "baselayerchange" : null;
                                n && this._map.fire(n, e)
                            },
                            _createRadioElement: function(t, e) {
                                var n = '<input type="radio" class="leaflet-control-layers-selector" name="' + t + '"' + (e ? ' checked="checked"' : "") + "/>",
                                    i = document.createElement("div");
                                return i.innerHTML = n, i.firstChild
                            },
                            _addItem: function(t) {
                                var e, n = document.createElement("label"),
                                    i = this._map.hasLayer(t.layer);
                                t.overlay ? (e = document.createElement("input"), e.type = "checkbox", e.className = "leaflet-control-layers-selector", e.defaultChecked = i) : e = this._createRadioElement("leaflet-base-layers", i), this._layerControlInputs.push(e), e.layerId = o(t.layer), H(e, "click", this._onInputClick, this);
                                var r = document.createElement("span");
                                r.innerHTML = " " + t.name;
                                var s = document.createElement("div");
                                return n.appendChild(s), s.appendChild(e), s.appendChild(r), (t.overlay ? this._overlaysList : this._baseLayersList).appendChild(n), this._checkDisabledLayers(), n
                            },
                            _onInputClick: function() {
                                var t, e, n = this._layerControlInputs,
                                    i = [],
                                    o = [];
                                this._handlingClick = !0;
                                for (var r = n.length - 1; r >= 0; r--) t = n[r], e = this._getLayer(t.layerId).layer, t.checked ? i.push(e) : t.checked || o.push(e);
                                for (r = 0; r < o.length; r++) this._map.hasLayer(o[r]) && this._map.removeLayer(o[r]);
                                for (r = 0; r < i.length; r++) this._map.hasLayer(i[r]) || this._map.addLayer(i[r]);
                                this._handlingClick = !1, this._refocusOnMap()
                            },
                            _checkDisabledLayers: function() {
                                for (var t, e, n = this._layerControlInputs, i = this._map.getZoom(), o = n.length - 1; o >= 0; o--) t = n[o], e = this._getLayer(t.layerId).layer, t.disabled = void 0 !== e.options.minZoom && i < e.options.minZoom || void 0 !== e.options.maxZoom && i > e.options.maxZoom
                            },
                            _expandIfNotCollapsed: function() {
                                return this._map && !this.options.collapsed && this.expand(), this
                            },
                            _expand: function() {
                                return this.expand()
                            },
                            _collapse: function() {
                                return this.collapse()
                            }
                        }),
                        jn = function(t, e, n) {
                            return new Un(t, e, n)
                        },
                        qn = Bn.extend({
                            options: {
                                position: "topleft",
                                zoomInText: "+",
                                zoomInTitle: "Zoom in",
                                zoomOutText: "&#x2212;",
                                zoomOutTitle: "Zoom out"
                            },
                            onAdd: function(t) {
                                var e = "leaflet-control-zoom",
                                    n = ut("div", e + " leaflet-bar"),
                                    i = this.options;
                                return this._zoomInButton = this._createButton(i.zoomInText, i.zoomInTitle, e + "-in", n, this._zoomIn), this._zoomOutButton = this._createButton(i.zoomOutText, i.zoomOutTitle, e + "-out", n, this._zoomOut), this._updateDisabled(), t.on("zoomend zoomlevelschange", this._updateDisabled, this), n
                            },
                            onRemove: function(t) {
                                t.off("zoomend zoomlevelschange", this._updateDisabled, this)
                            },
                            disable: function() {
                                return this._disabled = !0, this._updateDisabled(), this
                            },
                            enable: function() {
                                return this._disabled = !1, this._updateDisabled(), this
                            },
                            _zoomIn: function(t) {
                                !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1))
                            },
                            _zoomOut: function(t) {
                                !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1))
                            },
                            _createButton: function(t, e, n, i, o) {
                                var r = ut("a", n, i);
                                return r.innerHTML = t, r.href = "#", r.title = e, r.setAttribute("role", "button"), r.setAttribute("aria-label", e), Q(r), H(r, "click", tt), H(r, "click", o, this), H(r, "click", this._refocusOnMap, this), r
                            },
                            _updateDisabled: function() {
                                var t = this._map,
                                    e = "leaflet-disabled";
                                gt(this._zoomInButton, e), gt(this._zoomOutButton, e), (this._disabled || t._zoom === t.getMinZoom()) && _t(this._zoomOutButton, e), (this._disabled || t._zoom === t.getMaxZoom()) && _t(this._zoomInButton, e)
                            }
                        });
                    zn.mergeOptions({
                        zoomControl: !0
                    }), zn.addInitHook(function() {
                        this.options.zoomControl && (this.zoomControl = new qn, this.addControl(this.zoomControl))
                    });
                    var Zn = function(t) {
                            return new qn(t)
                        },
                        Vn = Bn.extend({
                            options: {
                                position: "bottomleft",
                                maxWidth: 100,
                                metric: !0,
                                imperial: !0
                            },
                            onAdd: function(t) {
                                var e = ut("div", "leaflet-control-scale"),
                                    n = this.options;
                                return this._addScales(n, "leaflet-control-scale-line", e), t.on(n.updateWhenIdle ? "moveend" : "move", this._update, this), t.whenReady(this._update, this), e
                            },
                            onRemove: function(t) {
                                t.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this)
                            },
                            _addScales: function(t, e, n) {
                                t.metric && (this._mScale = ut("div", e, n)), t.imperial && (this._iScale = ut("div", e, n))
                            },
                            _update: function() {
                                var t = this._map,
                                    e = t.getSize().y / 2,
                                    n = t.distance(t.containerPointToLatLng([0, e]), t.containerPointToLatLng([this.options.maxWidth, e]));
                                this._updateScales(n)
                            },
                            _updateScales: function(t) {
                                this.options.metric && t && this._updateMetric(t), this.options.imperial && t && this._updateImperial(t)
                            },
                            _updateMetric: function(t) {
                                var e = this._getRoundNum(t),
                                    n = e < 1e3 ? e + " m" : e / 1e3 + " km";
                                this._updateScale(this._mScale, n, e / t)
                            },
                            _updateImperial: function(t) {
                                var e, n, i, o = 3.2808399 * t;
                                o > 5280 ? (e = o / 5280, n = this._getRoundNum(e), this._updateScale(this._iScale, n + " mi", n / e)) : (i = this._getRoundNum(o), this._updateScale(this._iScale, i + " ft", i / o))
                            },
                            _updateScale: function(t, e, n) {
                                t.style.width = Math.round(this.options.maxWidth * n) + "px", t.innerHTML = e
                            },
                            _getRoundNum: function(t) {
                                var e = Math.pow(10, (Math.floor(t) + "").length - 1),
                                    n = t / e;
                                return n = n >= 10 ? 10 : n >= 5 ? 5 : n >= 3 ? 3 : n >= 2 ? 2 : 1, e * n
                            }
                        }),
                        Hn = function(t) {
                            return new Vn(t)
                        },
                        Yn = Bn.extend({
                            options: {
                                position: "bottomright",
                                prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
                            },
                            initialize: function(t) {
                                c(this, t), this._attributions = {}
                            },
                            onAdd: function(t) {
                                t.attributionControl = this, this._container = ut("div", "leaflet-control-attribution"), Q(this._container);
                                for (var e in t._layers) t._layers[e].getAttribution && this.addAttribution(t._layers[e].getAttribution());
                                return this._update(), this._container
                            },
                            setPrefix: function(t) {
                                return this.options.prefix = t, this._update(), this
                            },
                            addAttribution: function(t) {
                                return t ? (this._attributions[t] || (this._attributions[t] = 0), this._attributions[t]++, this._update(), this) : this
                            },
                            removeAttribution: function(t) {
                                return t ? (this._attributions[t] && (this._attributions[t]--, this._update()), this) : this
                            },
                            _update: function() {
                                if (this._map) {
                                    var t = [];
                                    for (var e in this._attributions) this._attributions[e] && t.push(e);
                                    var n = [];
                                    this.options.prefix && n.push(this.options.prefix), t.length && n.push(t.join(", ")), this._container.innerHTML = n.join(" | ")
                                }
                            }
                        });
                    zn.mergeOptions({
                        attributionControl: !0
                    }), zn.addInitHook(function() {
                        this.options.attributionControl && (new Yn).addTo(this)
                    });
                    var Wn = function(t) {
                        return new Yn(t)
                    };
                    Bn.Layers = Un, Bn.Zoom = qn, Bn.Scale = Vn, Bn.Attribution = Yn, Gn.layers = jn, Gn.zoom = Zn, Gn.scale = Hn, Gn.attribution = Wn;
                    var Xn = v.extend({
                        initialize: function(t) {
                            this._map = t
                        },
                        enable: function() {
                            return this._enabled ? this : (this._enabled = !0, this.addHooks(), this)
                        },
                        disable: function() {
                            return this._enabled ? (this._enabled = !1, this.removeHooks(), this) : this
                        },
                        enabled: function() {
                            return !!this._enabled
                        }
                    });
                    Xn.addTo = function(t, e) {
                        return t.addHandler(e, this), this
                    };
                    var Jn, Kn = {
                            Events: Ee
                        },
                        Qn = an ? "touchstart mousedown" : "mousedown",
                        $n = {
                            mousedown: "mouseup",
                            touchstart: "touchend",
                            pointerdown: "touchend",
                            MSPointerDown: "touchend"
                        },
                        ti = {
                            mousedown: "mousemove",
                            touchstart: "touchmove",
                            pointerdown: "touchmove",
                            MSPointerDown: "touchmove"
                        },
                        ei = Ce.extend({
                            options: {
                                clickTolerance: 3
                            },
                            initialize: function(t, e, n, i) {
                                c(this, i), this._element = t, this._dragStartTarget = e || t, this._preventOutline = n
                            },
                            enable: function() {
                                this._enabled || (H(this._dragStartTarget, Qn, this._onDown, this), this._enabled = !0)
                            },
                            disable: function() {
                                this._enabled && (ei._dragging === this && this.finishDrag(), Y(this._dragStartTarget, Qn, this._onDown, this), this._enabled = !1, this._moved = !1)
                            },
                            _onDown: function(t) {
                                if (!t._simulated && this._enabled && (this._moved = !1, !dt(this._element, "leaflet-zoom-anim") && !(ei._dragging || t.shiftKey || 1 !== t.which && 1 !== t.button && !t.touches || (ei._dragging = this, this._preventOutline && Mt(this._element), It(), Ne(), this._moving)))) {
                                    this.fire("down");
                                    var e = t.touches ? t.touches[0] : t;
                                    this._startPoint = new b(e.clientX, e.clientY), H(document, ti[t.type], this._onMove, this), H(document, $n[t.type], this._onUp, this)
                                }
                            },
                            _onMove: function(t) {
                                if (!t._simulated && this._enabled) {
                                    if (t.touches && t.touches.length > 1) return void(this._moved = !0);
                                    var e = t.touches && 1 === t.touches.length ? t.touches[0] : t,
                                        n = new b(e.clientX, e.clientY),
                                        i = n.subtract(this._startPoint);
                                    (i.x || i.y) && (Math.abs(i.x) + Math.abs(i.y) < this.options.clickTolerance || ($(t), this._moved || (this.fire("dragstart"), this._moved = !0, this._startPos = Ct(this._element).subtract(i), _t(document.body, "leaflet-dragging"), this._lastTarget = t.target || t.srcElement, window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), _t(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(i), this._moving = !0, y(this._animRequest), this._lastEvent = t, this._animRequest = m(this._updatePosition, this, !0)))
                                }
                            },
                            _updatePosition: function() {
                                var t = {
                                    originalEvent: this._lastEvent
                                };
                                this.fire("predrag", t), Et(this._element, this._newPos), this.fire("drag", t)
                            },
                            _onUp: function(t) {
                                !t._simulated && this._enabled && this.finishDrag()
                            },
                            finishDrag: function() {
                                gt(document.body, "leaflet-dragging"), this._lastTarget && (gt(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null);
                                for (var t in ti) Y(document, ti[t], this._onMove, this), Y(document, $n[t], this._onUp, this);
                                wt(), Te(), this._moved && this._moving && (y(this._animRequest), this.fire("dragend", {
                                    distance: this._newPos.distanceTo(this._startPos)
                                })), this._moving = !1, ei._dragging = !1
                            }
                        }),
                        ni = (Object.freeze || Object)({
                            simplify: Nt,
                            pointToSegmentDistance: Tt,
                            closestPointOnSegment: Ot,
                            clipSegment: kt,
                            _getEdgeIntersection: Ft,
                            _getBitCode: zt,
                            _sqClosestPointOnSegment: Gt,
                            isFlat: Ut,
                            _flat: jt
                        }),
                        ii = (Object.freeze || Object)({
                            clipPolygon: qt
                        }),
                        oi = {
                            project: function(t) {
                                return new b(t.lng, t.lat)
                            },
                            unproject: function(t) {
                                return new S(t.y, t.x)
                            },
                            bounds: new C([-180, -90], [180, 90])
                        },
                        ri = {
                            R: 6378137,
                            R_MINOR: 6356752.314245179,
                            bounds: new C([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),
                            project: function(t) {
                                var e = Math.PI / 180,
                                    n = this.R,
                                    i = t.lat * e,
                                    o = this.R_MINOR / n,
                                    r = Math.sqrt(1 - o * o),
                                    s = r * Math.sin(i),
                                    a = Math.tan(Math.PI / 4 - i / 2) / Math.pow((1 - s) / (1 + s), r / 2);
                                return i = -n * Math.log(Math.max(a, 1e-10)), new b(t.lng * e * n, i)
                            },
                            unproject: function(t) {
                                for (var e, n = 180 / Math.PI, i = this.R, o = this.R_MINOR / i, r = Math.sqrt(1 - o * o), s = Math.exp(-t.y / i), a = Math.PI / 2 - 2 * Math.atan(s), h = 0, u = .1; h < 15 && Math.abs(u) > 1e-7; h++) e = r * Math.sin(a), e = Math.pow((1 - e) / (1 + e), r / 2), u = Math.PI / 2 - 2 * Math.atan(s * e) - a, a += u;
                                return new S(a * n, t.x * n / i)
                            }
                        },
                        si = (Object.freeze || Object)({
                            LonLat: oi,
                            Mercator: ri,
                            SphericalMercator: Se
                        }),
                        ai = e({}, Me, {
                            code: "EPSG:3395",
                            projection: ri,
                            transformation: function() {
                                var t = .5 / (Math.PI * ri.R);
                                return T(t, .5, -t, .5)
                            }()
                        }),
                        hi = e({}, Me, {
                            code: "EPSG:4326",
                            projection: oi,
                            transformation: T(1 / 180, 1, -1 / 180, .5)
                        }),
                        ui = e({}, we, {
                            projection: oi,
                            transformation: T(1, 0, -1, 0),
                            scale: function(t) {
                                return Math.pow(2, t)
                            },
                            zoom: function(t) {
                                return Math.log(t) / Math.LN2
                            },
                            distance: function(t, e) {
                                var n = e.lng - t.lng,
                                    i = e.lat - t.lat;
                                return Math.sqrt(n * n + i * i)
                            },
                            infinite: !0
                        });
                    we.Earth = Me, we.EPSG3395 = ai, we.EPSG3857 = Ae, we.EPSG900913 = Re, we.EPSG4326 = hi, we.Simple = ui;
                    var li = Ce.extend({
                        options: {
                            pane: "overlayPane",
                            attribution: null,
                            bubblingMouseEvents: !0
                        },
                        addTo: function(t) {
                            return t.addLayer(this), this
                        },
                        remove: function() {
                            return this.removeFrom(this._map || this._mapToAdd)
                        },
                        removeFrom: function(t) {
                            return t && t.removeLayer(this), this
                        },
                        getPane: function(t) {
                            return this._map.getPane(t ? this.options[t] || t : this.options.pane)
                        },
                        addInteractiveTarget: function(t) {
                            return this._map._targets[o(t)] = this, this
                        },
                        removeInteractiveTarget: function(t) {
                            return delete this._map._targets[o(t)], this
                        },
                        getAttribution: function() {
                            return this.options.attribution
                        },
                        _layerAdd: function(t) {
                            var e = t.target;
                            if (e.hasLayer(this)) {
                                if (this._map = e, this._zoomAnimated = e._zoomAnimated, this.getEvents) {
                                    var n = this.getEvents();
                                    e.on(n, this), this.once("remove", function() {
                                        e.off(n, this)
                                    }, this)
                                }
                                this.onAdd(e), this.getAttribution && e.attributionControl && e.attributionControl.addAttribution(this.getAttribution()), this.fire("add"), e.fire("layeradd", {
                                    layer: this
                                })
                            }
                        }
                    });
                    zn.include({
                        addLayer: function(t) {
                            if (!t._layerAdd) throw new Error("The provided object is not a Layer.");
                            var e = o(t);
                            return this._layers[e] ? this : (this._layers[e] = t, t._mapToAdd = this, t.beforeAdd && t.beforeAdd(this), this.whenReady(t._layerAdd, t), this)
                        },
                        removeLayer: function(t) {
                            var e = o(t);
                            return this._layers[e] ? (this._loaded && t.onRemove(this), t.getAttribution && this.attributionControl && this.attributionControl.removeAttribution(t.getAttribution()), delete this._layers[e], this._loaded && (this.fire("layerremove", {
                                layer: t
                            }), t.fire("remove")), t._map = t._mapToAdd = null, this) : this
                        },
                        hasLayer: function(t) {
                            return !!t && o(t) in this._layers
                        },
                        eachLayer: function(t, e) {
                            for (var n in this._layers) t.call(e, this._layers[n]);
                            return this
                        },
                        _addLayers: function(t) {
                            t = t ? me(t) ? t : [t] : [];
                            for (var e = 0, n = t.length; e < n; e++) this.addLayer(t[e])
                        },
                        _addZoomLimit: function(t) {
                            !isNaN(t.options.maxZoom) && isNaN(t.options.minZoom) || (this._zoomBoundLayers[o(t)] = t, this._updateZoomLevels())
                        },
                        _removeZoomLimit: function(t) {
                            var e = o(t);
                            this._zoomBoundLayers[e] && (delete this._zoomBoundLayers[e], this._updateZoomLevels())
                        },
                        _updateZoomLevels: function() {
                            var t = 1 / 0,
                                e = -1 / 0,
                                n = this._getZoomSpan();
                            for (var i in this._zoomBoundLayers) {
                                var o = this._zoomBoundLayers[i].options;
                                t = void 0 === o.minZoom ? t : Math.min(t, o.minZoom), e = void 0 === o.maxZoom ? e : Math.max(e, o.maxZoom)
                            }
                            this._layersMaxZoom = e === -1 / 0 ? void 0 : e, this._layersMinZoom = t === 1 / 0 ? void 0 : t, n !== this._getZoomSpan() && this.fire("zoomlevelschange"), void 0 === this.options.maxZoom && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), void 0 === this.options.minZoom && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom)
                        }
                    });
                    var ci = li.extend({
                            initialize: function(t, e) {
                                c(this, e), this._layers = {};
                                var n, i;
                                if (t)
                                    for (n = 0, i = t.length; n < i; n++) this.addLayer(t[n])
                            },
                            addLayer: function(t) {
                                var e = this.getLayerId(t);
                                return this._layers[e] = t, this._map && this._map.addLayer(t), this
                            },
                            removeLayer: function(t) {
                                var e = t in this._layers ? t : this.getLayerId(t);
                                return this._map && this._layers[e] && this._map.removeLayer(this._layers[e]), delete this._layers[e], this
                            },
                            hasLayer: function(t) {
                                return !!t && (t in this._layers || this.getLayerId(t) in this._layers)
                            },
                            clearLayers: function() {
                                return this.eachLayer(this.removeLayer, this)
                            },
                            invoke: function(t) {
                                var e, n, i = Array.prototype.slice.call(arguments, 1);
                                for (e in this._layers) n = this._layers[e], n[t] && n[t].apply(n, i);
                                return this
                            },
                            onAdd: function(t) {
                                this.eachLayer(t.addLayer, t)
                            },
                            onRemove: function(t) {
                                this.eachLayer(t.removeLayer, t)
                            },
                            eachLayer: function(t, e) {
                                for (var n in this._layers) t.call(e, this._layers[n]);
                                return this
                            },
                            getLayer: function(t) {
                                return this._layers[t]
                            },
                            getLayers: function() {
                                var t = [];
                                return this.eachLayer(t.push, t), t
                            },
                            setZIndex: function(t) {
                                return this.invoke("setZIndex", t)
                            },
                            getLayerId: function(t) {
                                return o(t)
                            }
                        }),
                        pi = function(t, e) {
                            return new ci(t, e)
                        },
                        fi = ci.extend({
                            addLayer: function(t) {
                                return this.hasLayer(t) ? this : (t.addEventParent(this), ci.prototype.addLayer.call(this, t), this.fire("layeradd", {
                                    layer: t
                                }))
                            },
                            removeLayer: function(t) {
                                return this.hasLayer(t) ? (t in this._layers && (t = this._layers[t]), t.removeEventParent(this), ci.prototype.removeLayer.call(this, t), this.fire("layerremove", {
                                    layer: t
                                })) : this
                            },
                            setStyle: function(t) {
                                return this.invoke("setStyle", t)
                            },
                            bringToFront: function() {
                                return this.invoke("bringToFront")
                            },
                            bringToBack: function() {
                                return this.invoke("bringToBack")
                            },
                            getBounds: function() {
                                var t = new w;
                                for (var e in this._layers) {
                                    var n = this._layers[e];
                                    t.extend(n.getBounds ? n.getBounds() : n.getLatLng())
                                }
                                return t
                            }
                        }),
                        di = function(t) {
                            return new fi(t)
                        },
                        _i = v.extend({
                            options: {
                                popupAnchor: [0, 0],
                                tooltipAnchor: [0, 0]
                            },
                            initialize: function(t) {
                                c(this, t)
                            },
                            createIcon: function(t) {
                                return this._createIcon("icon", t)
                            },
                            createShadow: function(t) {
                                return this._createIcon("shadow", t)
                            },
                            _createIcon: function(t, e) {
                                var n = this._getIconUrl(t);
                                if (!n) {
                                    if ("icon" === t) throw new Error("iconUrl not set in Icon options (see the docs).");
                                    return null
                                }
                                var i = this._createImg(n, e && "IMG" === e.tagName ? e : null);
                                return this._setIconStyles(i, t), i
                            },
                            _setIconStyles: function(t, e) {
                                var n = this.options,
                                    i = n[e + "Size"];
                                "number" == typeof i && (i = [i, i]);
                                var o = E(i),
                                    r = E("shadow" === e && n.shadowAnchor || n.iconAnchor || o && o.divideBy(2, !0));
                                t.className = "leaflet-marker-" + e + " " + (n.className || ""), r && (t.style.marginLeft = -r.x + "px", t.style.marginTop = -r.y + "px"), o && (t.style.width = o.x + "px", t.style.height = o.y + "px")
                            },
                            _createImg: function(t, e) {
                                return e = e || document.createElement("img"), e.src = t, e
                            },
                            _getIconUrl: function(t) {
                                return ln && this.options[t + "RetinaUrl"] || this.options[t + "Url"]
                            }
                        }),
                        gi = _i.extend({
                            options: {
                                iconUrl: "marker-icon.png",
                                iconRetinaUrl: "marker-icon-2x.png",
                                shadowUrl: "marker-shadow.png",
                                iconSize: [25, 41],
                                iconAnchor: [12, 41],
                                popupAnchor: [1, -34],
                                tooltipAnchor: [16, -28],
                                shadowSize: [41, 41]
                            },
                            _getIconUrl: function(t) {
                                return gi.imagePath || (gi.imagePath = this._detectIconPath()), (this.options.imagePath || gi.imagePath) + _i.prototype._getIconUrl.call(this, t)
                            },
                            _detectIconPath: function() {
                                var t = ut("div", "leaflet-default-icon-path", document.body),
                                    e = ht(t, "background-image") || ht(t, "backgroundImage");
                                return document.body.removeChild(t), e = null === e || 0 !== e.indexOf("url") ? "" : e.replace(/^url\(["']?/, "").replace(/marker-icon\.png["']?\)$/, "")
                            }
                        }),
                        mi = Xn.extend({
                            initialize: function(t) {
                                this._marker = t
                            },
                            addHooks: function() {
                                var t = this._marker._icon;
                                this._draggable || (this._draggable = new ei(t, t, !0)), this._draggable.on({
                                    dragstart: this._onDragStart,
                                    predrag: this._onPreDrag,
                                    drag: this._onDrag,
                                    dragend: this._onDragEnd
                                }, this).enable(), _t(t, "leaflet-marker-draggable")
                            },
                            removeHooks: function() {
                                this._draggable.off({
                                    dragstart: this._onDragStart,
                                    predrag: this._onPreDrag,
                                    drag: this._onDrag,
                                    dragend: this._onDragEnd
                                }, this).disable(), this._marker._icon && gt(this._marker._icon, "leaflet-marker-draggable")
                            },
                            moved: function() {
                                return this._draggable && this._draggable._moved
                            },
                            _adjustPan: function(t) {
                                var e = this._marker,
                                    n = e._map,
                                    i = this._marker.options.autoPanSpeed,
                                    o = this._marker.options.autoPanPadding,
                                    r = L.DomUtil.getPosition(e._icon),
                                    s = n.getPixelBounds(),
                                    a = n.getPixelOrigin(),
                                    h = I(s.min._subtract(a).add(o), s.max._subtract(a).subtract(o));
                                if (!h.contains(r)) {
                                    var u = E((Math.max(h.max.x, r.x) - h.max.x) / (s.max.x - h.max.x) - (Math.min(h.min.x, r.x) - h.min.x) / (s.min.x - h.min.x), (Math.max(h.max.y, r.y) - h.max.y) / (s.max.y - h.max.y) - (Math.min(h.min.y, r.y) - h.min.y) / (s.min.y - h.min.y)).multiplyBy(i);
                                    n.panBy(u, {
                                        animate: !1
                                    }), this._draggable._newPos._add(u), this._draggable._startPos._add(u), L.DomUtil.setPosition(e._icon, this._draggable._newPos), this._onDrag(t), this._panRequest = m(this._adjustPan.bind(this, t))
                                }
                            },
                            _onDragStart: function() {
                                this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup().fire("movestart").fire("dragstart")
                            },
                            _onPreDrag: function(t) {
                                this._marker.options.autoPan && (y(this._panRequest), this._panRequest = m(this._adjustPan.bind(this, t)))
                            },
                            _onDrag: function(t) {
                                var e = this._marker,
                                    n = e._shadow,
                                    i = Ct(e._icon),
                                    o = e._map.layerPointToLatLng(i);
                                n && Et(n, i), e._latlng = o, t.latlng = o, t.oldLatLng = this._oldLatLng, e.fire("move", t).fire("drag", t)
                            },
                            _onDragEnd: function(t) {
                                y(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", t)
                            }
                        }),
                        yi = li.extend({
                            options: {
                                icon: new gi,
                                interactive: !0,
                                draggable: !1,
                                autoPan: !1,
                                autoPanPadding: [50, 50],
                                autoPanSpeed: 10,
                                keyboard: !0,
                                title: "",
                                alt: "",
                                zIndexOffset: 0,
                                opacity: 1,
                                riseOnHover: !1,
                                riseOffset: 250,
                                pane: "markerPane",
                                bubblingMouseEvents: !1
                            },
                            initialize: function(t, e) {
                                c(this, e), this._latlng = P(t)
                            },
                            onAdd: function(t) {
                                this._zoomAnimated = this._zoomAnimated && t.options.markerZoomAnimation, this._zoomAnimated && t.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update()
                            },
                            onRemove: function(t) {
                                this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && t.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow()
                            },
                            getEvents: function() {
                                return {
                                    zoom: this.update,
                                    viewreset: this.update
                                }
                            },
                            getLatLng: function() {
                                return this._latlng
                            },
                            setLatLng: function(t) {
                                var e = this._latlng;
                                return this._latlng = P(t), this.update(), this.fire("move", {
                                    oldLatLng: e,
                                    latlng: this._latlng
                                })
                            },
                            setZIndexOffset: function(t) {
                                return this.options.zIndexOffset = t, this.update()
                            },
                            setIcon: function(t) {
                                return this.options.icon = t, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this
                            },
                            getElement: function() {
                                return this._icon
                            },
                            update: function() {
                                if (this._icon && this._map) {
                                    var t = this._map.latLngToLayerPoint(this._latlng).round();
                                    this._setPos(t)
                                }
                                return this
                            },
                            _initIcon: function() {
                                var t = this.options,
                                    e = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"),
                                    n = t.icon.createIcon(this._icon),
                                    i = !1;
                                n !== this._icon && (this._icon && this._removeIcon(), i = !0, t.title && (n.title = t.title), "IMG" === n.tagName && (n.alt = t.alt || "")), _t(n, e), t.keyboard && (n.tabIndex = "0"), this._icon = n, t.riseOnHover && this.on({
                                    mouseover: this._bringToFront,
                                    mouseout: this._resetZIndex
                                });
                                var o = t.icon.createShadow(this._shadow),
                                    r = !1;
                                o !== this._shadow && (this._removeShadow(), r = !0), o && (_t(o, e), o.alt = ""), this._shadow = o, t.opacity < 1 && this._updateOpacity(), i && this.getPane().appendChild(this._icon), this._initInteraction(), o && r && this.getPane("shadowPane").appendChild(this._shadow)
                            },
                            _removeIcon: function() {
                                this.options.riseOnHover && this.off({
                                    mouseover: this._bringToFront,
                                    mouseout: this._resetZIndex
                                }), lt(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null
                            },
                            _removeShadow: function() {
                                this._shadow && lt(this._shadow), this._shadow = null
                            },
                            _setPos: function(t) {
                                Et(this._icon, t), this._shadow && Et(this._shadow, t), this._zIndex = t.y + this.options.zIndexOffset, this._resetZIndex()
                            },
                            _updateZIndex: function(t) {
                                this._icon.style.zIndex = this._zIndex + t
                            },
                            _animateZoom: function(t) {
                                var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round();
                                this._setPos(e)
                            },
                            _initInteraction: function() {
                                if (this.options.interactive && (_t(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), mi)) {
                                    var t = this.options.draggable;
                                    this.dragging && (t = this.dragging.enabled(), this.dragging.disable()), this.dragging = new mi(this), t && this.dragging.enable()
                                }
                            },
                            setOpacity: function(t) {
                                return this.options.opacity = t, this._map && this._updateOpacity(), this
                            },
                            _updateOpacity: function() {
                                var t = this.options.opacity;
                                vt(this._icon, t), this._shadow && vt(this._shadow, t)
                            },
                            _bringToFront: function() {
                                this._updateZIndex(this.options.riseOffset)
                            },
                            _resetZIndex: function() {
                                this._updateZIndex(0)
                            },
                            _getPopupAnchor: function() {
                                return this.options.icon.options.popupAnchor
                            },
                            _getTooltipAnchor: function() {
                                return this.options.icon.options.tooltipAnchor
                            }
                        }),
                        vi = li.extend({
                            options: {
                                stroke: !0,
                                color: "#3388ff",
                                weight: 3,
                                opacity: 1,
                                lineCap: "round",
                                lineJoin: "round",
                                dashArray: null,
                                dashOffset: null,
                                fill: !1,
                                fillColor: null,
                                fillOpacity: .2,
                                fillRule: "evenodd",
                                interactive: !0,
                                bubblingMouseEvents: !0
                            },
                            beforeAdd: function(t) {
                                this._renderer = t.getRenderer(this)
                            },
                            onAdd: function() {
                                this._renderer._initPath(this), this._reset(), this._renderer._addPath(this)
                            },
                            onRemove: function() {
                                this._renderer._removePath(this)
                            },
                            redraw: function() {
                                return this._map && this._renderer._updatePath(this), this
                            },
                            setStyle: function(t) {
                                return c(this, t), this._renderer && this._renderer._updateStyle(this), this
                            },
                            bringToFront: function() {
                                return this._renderer && this._renderer._bringToFront(this), this
                            },
                            bringToBack: function() {
                                return this._renderer && this._renderer._bringToBack(this), this
                            },
                            getElement: function() {
                                return this._path
                            },
                            _reset: function() {
                                this._project(), this._update()
                            },
                            _clickTolerance: function() {
                                return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance
                            }
                        }),
                        Li = vi.extend({
                            options: {
                                fill: !0,
                                radius: 10
                            },
                            initialize: function(t, e) {
                                c(this, e), this._latlng = P(t), this._radius = this.options.radius
                            },
                            setLatLng: function(t) {
                                return this._latlng = P(t), this.redraw(), this.fire("move", {
                                    latlng: this._latlng
                                })
                            },
                            getLatLng: function() {
                                return this._latlng
                            },
                            setRadius: function(t) {
                                return this.options.radius = this._radius = t, this.redraw()
                            },
                            getRadius: function() {
                                return this._radius
                            },
                            setStyle: function(t) {
                                var e = t && t.radius || this._radius;
                                return vi.prototype.setStyle.call(this, t), this.setRadius(e), this
                            },
                            _project: function() {
                                this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds()
                            },
                            _updateBounds: function() {
                                var t = this._radius,
                                    e = this._radiusY || t,
                                    n = this._clickTolerance(),
                                    i = [t + n, e + n];
                                this._pxBounds = new C(this._point.subtract(i), this._point.add(i))
                            },
                            _update: function() {
                                this._map && this._updatePath()
                            },
                            _updatePath: function() {
                                this._renderer._updateCircle(this)
                            },
                            _empty: function() {
                                return this._radius && !this._renderer._bounds.intersects(this._pxBounds)
                            },
                            _containsPoint: function(t) {
                                return t.distanceTo(this._point) <= this._radius + this._clickTolerance()
                            }
                        }),
                        xi = Li.extend({
                            initialize: function(t, n, i) {
                                if ("number" == typeof n && (n = e({}, i, {
                                    radius: n
                                })), c(this, n), this._latlng = P(t), isNaN(this.options.radius)) throw new Error("Circle radius cannot be NaN");
                                this._mRadius = this.options.radius
                            },
                            setRadius: function(t) {
                                return this._mRadius = t, this.redraw()
                            },
                            getRadius: function() {
                                return this._mRadius
                            },
                            getBounds: function() {
                                var t = [this._radius, this._radiusY || this._radius];
                                return new w(this._map.layerPointToLatLng(this._point.subtract(t)), this._map.layerPointToLatLng(this._point.add(t)))
                            },
                            setStyle: vi.prototype.setStyle,
                            _project: function() {
                                var t = this._latlng.lng,
                                    e = this._latlng.lat,
                                    n = this._map,
                                    i = n.options.crs;
                                if (i.distance === Me.distance) {
                                    var o = Math.PI / 180,
                                        r = this._mRadius / Me.R / o,
                                        s = n.project([e + r, t]),
                                        a = n.project([e - r, t]),
                                        h = s.add(a).divideBy(2),
                                        u = n.unproject(h).lat,
                                        l = Math.acos((Math.cos(r * o) - Math.sin(e * o) * Math.sin(u * o)) / (Math.cos(e * o) * Math.cos(u * o))) / o;
                                    (isNaN(l) || 0 === l) && (l = r / Math.cos(Math.PI / 180 * e)), this._point = h.subtract(n.getPixelOrigin()), this._radius = isNaN(l) ? 0 : h.x - n.project([u, t - l]).x, this._radiusY = h.y - s.y
                                } else {
                                    var c = i.unproject(i.project(this._latlng).subtract([this._mRadius, 0]));
                                    this._point = n.latLngToLayerPoint(this._latlng), this._radius = this._point.x - n.latLngToLayerPoint(c).x
                                }
                                this._updateBounds()
                            }
                        }),
                        bi = vi.extend({
                            options: {
                                smoothFactor: 1,
                                noClip: !1
                            },
                            initialize: function(t, e) {
                                c(this, e), this._setLatLngs(t)
                            },
                            getLatLngs: function() {
                                return this._latlngs
                            },
                            setLatLngs: function(t) {
                                return this._setLatLngs(t), this.redraw()
                            },
                            isEmpty: function() {
                                return !this._latlngs.length
                            },
                            closestLayerPoint: function(t) {
                                for (var e, n, i = 1 / 0, o = null, r = Gt, s = 0, a = this._parts.length; s < a; s++)
                                    for (var h = this._parts[s], u = 1, l = h.length; u < l; u++) {
                                        e = h[u - 1], n = h[u];
                                        var c = r(t, e, n, !0);
                                        c < i && (i = c, o = r(t, e, n))
                                    }
                                return o && (o.distance = Math.sqrt(i)), o
                            },
                            getCenter: function() {
                                if (!this._map) throw new Error("Must add layer to map before using getCenter()");
                                var t, e, n, i, o, r, s, a = this._rings[0],
                                    h = a.length;
                                if (!h) return null;
                                for (t = 0, e = 0; t < h - 1; t++) e += a[t].distanceTo(a[t + 1]) / 2;
                                if (0 === e) return this._map.layerPointToLatLng(a[0]);
                                for (t = 0, i = 0; t < h - 1; t++)
                                    if (o = a[t], r = a[t + 1], n = o.distanceTo(r), (i += n) > e) return s = (i - e) / n, this._map.layerPointToLatLng([r.x - s * (r.x - o.x), r.y - s * (r.y - o.y)])
                            },
                            getBounds: function() {
                                return this._bounds
                            },
                            addLatLng: function(t, e) {
                                return e = e || this._defaultShape(), t = P(t), e.push(t), this._bounds.extend(t), this.redraw()
                            },
                            _setLatLngs: function(t) {
                                this._bounds = new w, this._latlngs = this._convertLatLngs(t)
                            },
                            _defaultShape: function() {
                                return Ut(this._latlngs) ? this._latlngs : this._latlngs[0]
                            },
                            _convertLatLngs: function(t) {
                                for (var e = [], n = Ut(t), i = 0, o = t.length; i < o; i++) n ? (e[i] = P(t[i]), this._bounds.extend(e[i])) : e[i] = this._convertLatLngs(t[i]);
                                return e
                            },
                            _project: function() {
                                var t = new C;
                                this._rings = [], this._projectLatlngs(this._latlngs, this._rings, t);
                                var e = this._clickTolerance(),
                                    n = new b(e, e);
                                this._bounds.isValid() && t.isValid() && (t.min._subtract(n), t.max._add(n), this._pxBounds = t)
                            },
                            _projectLatlngs: function(t, e, n) {
                                var i, o, r = t[0] instanceof S,
                                    s = t.length;
                                if (r) {
                                    for (o = [], i = 0; i < s; i++) o[i] = this._map.latLngToLayerPoint(t[i]), n.extend(o[i]);
                                    e.push(o)
                                } else
                                    for (i = 0; i < s; i++) this._projectLatlngs(t[i], e, n)
                            },
                            _clipPoints: function() {
                                var t = this._renderer._bounds;
                                if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t)) {
                                    if (this.options.noClip) return void(this._parts = this._rings);
                                    var e, n, i, o, r, s, a, h = this._parts;
                                    for (e = 0, i = 0, o = this._rings.length; e < o; e++)
                                        for (a = this._rings[e], n = 0, r = a.length; n < r - 1; n++)(s = kt(a[n], a[n + 1], t, n, !0)) && (h[i] = h[i] || [], h[i].push(s[0]), s[1] === a[n + 1] && n !== r - 2 || (h[i].push(s[1]), i++))
                                }
                            },
                            _simplifyPoints: function() {
                                for (var t = this._parts, e = this.options.smoothFactor, n = 0, i = t.length; n < i; n++) t[n] = Nt(t[n], e)
                            },
                            _update: function() {
                                this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath())
                            },
                            _updatePath: function() {
                                this._renderer._updatePoly(this)
                            },
                            _containsPoint: function(t, e) {
                                var n, i, o, r, s, a, h = this._clickTolerance();
                                if (!this._pxBounds || !this._pxBounds.contains(t)) return !1;
                                for (n = 0, r = this._parts.length; n < r; n++)
                                    for (a = this._parts[n], i = 0, s = a.length, o = s - 1; i < s; o = i++)
                                        if ((e || 0 !== i) && Tt(t, a[o], a[i]) <= h) return !0;
                                return !1
                            }
                        });
                    bi._flat = jt;
                    var Ei = bi.extend({
                            options: {
                                fill: !0
                            },
                            isEmpty: function() {
                                return !this._latlngs.length || !this._latlngs[0].length
                            },
                            getCenter: function() {
                                if (!this._map) throw new Error("Must add layer to map before using getCenter()");
                                var t, e, n, i, o, r, s, a, h, u = this._rings[0],
                                    l = u.length;
                                if (!l) return null;
                                for (r = s = a = 0, t = 0, e = l - 1; t < l; e = t++) n = u[t], i = u[e], o = n.y * i.x - i.y * n.x, s += (n.x + i.x) * o, a += (n.y + i.y) * o, r += 3 * o;
                                return h = 0 === r ? u[0] : [s / r, a / r], this._map.layerPointToLatLng(h)
                            },
                            _convertLatLngs: function(t) {
                                var e = bi.prototype._convertLatLngs.call(this, t),
                                    n = e.length;
                                return n >= 2 && e[0] instanceof S && e[0].equals(e[n - 1]) && e.pop(), e
                            },
                            _setLatLngs: function(t) {
                                bi.prototype._setLatLngs.call(this, t), Ut(this._latlngs) && (this._latlngs = [this._latlngs])
                            },
                            _defaultShape: function() {
                                return Ut(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0]
                            },
                            _clipPoints: function() {
                                var t = this._renderer._bounds,
                                    e = this.options.weight,
                                    n = new b(e, e);
                                if (t = new C(t.min.subtract(n), t.max.add(n)), this._parts = [], this._pxBounds && this._pxBounds.intersects(t)) {
                                    if (this.options.noClip) return void(this._parts = this._rings);
                                    for (var i, o = 0, r = this._rings.length; o < r; o++) i = qt(this._rings[o], t, !0), i.length && this._parts.push(i)
                                }
                            },
                            _updatePath: function() {
                                this._renderer._updatePoly(this, !0)
                            },
                            _containsPoint: function(t) {
                                var e, n, i, o, r, s, a, h, u = !1;
                                if (!this._pxBounds.contains(t)) return !1;
                                for (o = 0, a = this._parts.length; o < a; o++)
                                    for (e = this._parts[o], r = 0, h = e.length, s = h - 1; r < h; s = r++) n = e[r], i = e[s], n.y > t.y != i.y > t.y && t.x < (i.x - n.x) * (t.y - n.y) / (i.y - n.y) + n.x && (u = !u);
                                return u || bi.prototype._containsPoint.call(this, t, !0)
                            }
                        }),
                        Ci = fi.extend({
                            initialize: function(t, e) {
                                c(this, e), this._layers = {}, t && this.addData(t)
                            },
                            addData: function(t) {
                                var e, n, i, o = me(t) ? t : t.features;
                                if (o) {
                                    for (e = 0, n = o.length; e < n; e++) i = o[e], (i.geometries || i.geometry || i.features || i.coordinates) && this.addData(i);
                                    return this
                                }
                                var r = this.options;
                                if (r.filter && !r.filter(t)) return this;
                                var s = Jt(t, r);
                                return s ? (s.feature = ne(t), s.defaultOptions = s.options, this.resetStyle(s), r.onEachFeature && r.onEachFeature(t, s), this.addLayer(s)) : this
                            },
                            resetStyle: function(t) {
                                return t.options = e({}, t.defaultOptions), this._setLayerStyle(t, this.options.style), this
                            },
                            setStyle: function(t) {
                                return this.eachLayer(function(e) {
                                    this._setLayerStyle(e, t)
                                }, this)
                            },
                            _setLayerStyle: function(t, e) {
                                "function" == typeof e && (e = e(t.feature)), t.setStyle && t.setStyle(e)
                            }
                        }),
                        Ii = {
                            toGeoJSON: function(t) {
                                return ee(this, {
                                    type: "Point",
                                    coordinates: $t(this.getLatLng(), t)
                                })
                            }
                        };
                    yi.include(Ii), xi.include(Ii), Li.include(Ii), bi.include({
                        toGeoJSON: function(t) {
                            var e = !Ut(this._latlngs),
                                n = te(this._latlngs, e ? 1 : 0, !1, t);
                            return ee(this, {
                                type: (e ? "Multi" : "") + "LineString",
                                coordinates: n
                            })
                        }
                    }), Ei.include({
                        toGeoJSON: function(t) {
                            var e = !Ut(this._latlngs),
                                n = e && !Ut(this._latlngs[0]),
                                i = te(this._latlngs, n ? 2 : e ? 1 : 0, !0, t);
                            return e || (i = [i]), ee(this, {
                                type: (n ? "Multi" : "") + "Polygon",
                                coordinates: i
                            })
                        }
                    }), ci.include({
                        toMultiPoint: function(t) {
                            var e = [];
                            return this.eachLayer(function(n) {
                                e.push(n.toGeoJSON(t).geometry.coordinates)
                            }), ee(this, {
                                type: "MultiPoint",
                                coordinates: e
                            })
                        },
                        toGeoJSON: function(t) {
                            var e = this.feature && this.feature.geometry && this.feature.geometry.type;
                            if ("MultiPoint" === e) return this.toMultiPoint(t);
                            var n = "GeometryCollection" === e,
                                i = [];
                            return this.eachLayer(function(e) {
                                if (e.toGeoJSON) {
                                    var o = e.toGeoJSON(t);
                                    if (n) i.push(o.geometry);
                                    else {
                                        var r = ne(o);
                                        "FeatureCollection" === r.type ? i.push.apply(i, r.features) : i.push(r)
                                    }
                                }
                            }), n ? ee(this, {
                                geometries: i,
                                type: "GeometryCollection"
                            }) : {
                                type: "FeatureCollection",
                                features: i
                            }
                        }
                    });
                    var wi = ie,
                        Mi = li.extend({
                            options: {
                                opacity: 1,
                                alt: "",
                                interactive: !1,
                                crossOrigin: !1,
                                errorOverlayUrl: "",
                                zIndex: 1,
                                className: ""
                            },
                            initialize: function(t, e, n) {
                                this._url = t, this._bounds = M(e), c(this, n)
                            },
                            onAdd: function() {
                                this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (_t(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset()
                            },
                            onRemove: function() {
                                lt(this._image), this.options.interactive && this.removeInteractiveTarget(this._image)
                            },
                            setOpacity: function(t) {
                                return this.options.opacity = t, this._image && this._updateOpacity(), this
                            },
                            setStyle: function(t) {
                                return t.opacity && this.setOpacity(t.opacity), this
                            },
                            bringToFront: function() {
                                return this._map && pt(this._image), this
                            },
                            bringToBack: function() {
                                return this._map && ft(this._image), this
                            },
                            setUrl: function(t) {
                                return this._url = t, this._image && (this._image.src = t), this
                            },
                            setBounds: function(t) {
                                return this._bounds = M(t), this._map && this._reset(), this
                            },
                            getEvents: function() {
                                var t = {
                                    zoom: this._reset,
                                    viewreset: this._reset
                                };
                                return this._zoomAnimated && (t.zoomanim = this._animateZoom), t
                            },
                            setZIndex: function(t) {
                                return this.options.zIndex = t, this._updateZIndex(), this
                            },
                            getBounds: function() {
                                return this._bounds
                            },
                            getElement: function() {
                                return this._image
                            },
                            _initImage: function() {
                                var t = "IMG" === this._url.tagName,
                                    e = this._image = t ? this._url : ut("img");
                                if (_t(e, "leaflet-image-layer"), this._zoomAnimated && _t(e, "leaflet-zoom-animated"), this.options.className && _t(e, this.options.className), e.onselectstart = a, e.onmousemove = a, e.onload = i(this.fire, this, "load"), e.onerror = i(this._overlayOnError, this, "error"), this.options.crossOrigin && (e.crossOrigin = ""), this.options.zIndex && this._updateZIndex(), t) return void(this._url = e.src);
                                e.src = this._url, e.alt = this.options.alt
                            },
                            _animateZoom: function(t) {
                                var e = this._map.getZoomScale(t.zoom),
                                    n = this._map._latLngBoundsToNewLayerBounds(this._bounds, t.zoom, t.center).min;
                                bt(this._image, n, e)
                            },
                            _reset: function() {
                                var t = this._image,
                                    e = new C(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
                                    n = e.getSize();
                                Et(t, e.min), t.style.width = n.x + "px", t.style.height = n.y + "px"
                            },
                            _updateOpacity: function() {
                                vt(this._image, this.options.opacity)
                            },
                            _updateZIndex: function() {
                                this._image && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._image.style.zIndex = this.options.zIndex)
                            },
                            _overlayOnError: function() {
                                this.fire("error");
                                var t = this.options.errorOverlayUrl;
                                t && this._url !== t && (this._url = t, this._image.src = t)
                            }
                        }),
                        Si = function(t, e, n) {
                            return new Mi(t, e, n)
                        },
                        Pi = Mi.extend({
                            options: {
                                autoplay: !0,
                                loop: !0
                            },
                            _initImage: function() {
                                var t = "VIDEO" === this._url.tagName,
                                    e = this._image = t ? this._url : ut("video");
                                if (_t(e, "leaflet-image-layer"), this._zoomAnimated && _t(e, "leaflet-zoom-animated"), e.onselectstart = a, e.onmousemove = a, e.onloadeddata = i(this.fire, this, "load"), t) {
                                    for (var n = e.getElementsByTagName("source"), o = [], r = 0; r < n.length; r++) o.push(n[r].src);
                                    return void(this._url = n.length > 0 ? o : [e.src])
                                }
                                me(this._url) || (this._url = [this._url]), e.autoplay = !!this.options.autoplay, e.loop = !!this.options.loop;
                                for (var s = 0; s < this._url.length; s++) {
                                    var h = ut("source");
                                    h.src = this._url[s], e.appendChild(h)
                                }
                            }
                        }),
                        Ni = li.extend({
                            options: {
                                offset: [0, 7],
                                className: "",
                                pane: "popupPane"
                            },
                            initialize: function(t, e) {
                                c(this, t), this._source = e
                            },
                            onAdd: function(t) {
                                this._zoomAnimated = t._zoomAnimated, this._container || this._initLayout(), t._fadeAnimated && vt(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), t._fadeAnimated && vt(this._container, 1), this.bringToFront()
                            },
                            onRemove: function(t) {
                                t._fadeAnimated ? (vt(this._container, 0), this._removeTimeout = setTimeout(i(lt, void 0, this._container), 200)) : lt(this._container)
                            },
                            getLatLng: function() {
                                return this._latlng
                            },
                            setLatLng: function(t) {
                                return this._latlng = P(t), this._map && (this._updatePosition(), this._adjustPan()), this
                            },
                            getContent: function() {
                                return this._content
                            },
                            setContent: function(t) {
                                return this._content = t, this.update(), this
                            },
                            getElement: function() {
                                return this._container
                            },
                            update: function() {
                                this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan())
                            },
                            getEvents: function() {
                                var t = {
                                    zoom: this._updatePosition,
                                    viewreset: this._updatePosition
                                };
                                return this._zoomAnimated && (t.zoomanim = this._animateZoom), t
                            },
                            isOpen: function() {
                                return !!this._map && this._map.hasLayer(this)
                            },
                            bringToFront: function() {
                                return this._map && pt(this._container), this
                            },
                            bringToBack: function() {
                                return this._map && ft(this._container), this
                            },
                            _updateContent: function() {
                                if (this._content) {
                                    var t = this._contentNode,
                                        e = "function" == typeof this._content ? this._content(this._source || this) : this._content;
                                    if ("string" == typeof e) t.innerHTML = e;
                                    else {
                                        for (; t.hasChildNodes();) t.removeChild(t.firstChild);
                                        t.appendChild(e)
                                    }
                                    this.fire("contentupdate")
                                }
                            },
                            _updatePosition: function() {
                                if (this._map) {
                                    var t = this._map.latLngToLayerPoint(this._latlng),
                                        e = E(this.options.offset),
                                        n = this._getAnchor();
                                    this._zoomAnimated ? Et(this._container, t.add(n)) : e = e.add(t).add(n);
                                    var i = this._containerBottom = -e.y,
                                        o = this._containerLeft = -Math.round(this._containerWidth / 2) + e.x;
                                    this._container.style.bottom = i + "px", this._container.style.left = o + "px"
                                }
                            },
                            _getAnchor: function() {
                                return [0, 0]
                            }
                        }),
                        Ti = Ni.extend({
                            options: {
                                maxWidth: 300,
                                minWidth: 50,
                                maxHeight: null,
                                autoPan: !0,
                                autoPanPaddingTopLeft: null,
                                autoPanPaddingBottomRight: null,
                                autoPanPadding: [5, 5],
                                keepInView: !1,
                                closeButton: !0,
                                autoClose: !0,
                                closeOnEscapeKey: !0,
                                className: ""
                            },
                            openOn: function(t) {
                                return t.openPopup(this), this
                            },
                            onAdd: function(t) {
                                Ni.prototype.onAdd.call(this, t), t.fire("popupopen", {
                                    popup: this
                                }), this._source && (this._source.fire("popupopen", {
                                    popup: this
                                }, !0), this._source instanceof vi || this._source.on("preclick", J))
                            },
                            onRemove: function(t) {
                                Ni.prototype.onRemove.call(this, t), t.fire("popupclose", {
                                    popup: this
                                }), this._source && (this._source.fire("popupclose", {
                                    popup: this
                                }, !0), this._source instanceof vi || this._source.off("preclick", J))
                            },
                            getEvents: function() {
                                var t = Ni.prototype.getEvents.call(this);
                                return (void 0 !== this.options.closeOnClick ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this._close), this.options.keepInView && (t.moveend = this._adjustPan), t
                            },
                            _close: function() {
                                this._map && this._map.closePopup(this)
                            },
                            _initLayout: function() {
                                var t = "leaflet-popup",
                                    e = this._container = ut("div", t + " " + (this.options.className || "") + " leaflet-zoom-animated"),
                                    n = this._wrapper = ut("div", t + "-content-wrapper", e);
                                if (this._contentNode = ut("div", t + "-content", n), Q(n), K(this._contentNode), H(n, "contextmenu", J), this._tipContainer = ut("div", t + "-tip-container", e), this._tip = ut("div", t + "-tip", this._tipContainer), this.options.closeButton) {
                                    var i = this._closeButton = ut("a", t + "-close-button", e);
                                    i.href = "#close", i.innerHTML = "&#215;", H(i, "click", this._onCloseButtonClick, this)
                                }
                            },
                            _updateLayout: function() {
                                var t = this._contentNode,
                                    e = t.style;
                                e.width = "", e.whiteSpace = "nowrap";
                                var n = t.offsetWidth;
                                n = Math.min(n, this.options.maxWidth), n = Math.max(n, this.options.minWidth), e.width = n + 1 + "px", e.whiteSpace = "", e.height = "";
                                var i = t.offsetHeight,
                                    o = this.options.maxHeight;
                                o && i > o ? (e.height = o + "px", _t(t, "leaflet-popup-scrolled")) : gt(t, "leaflet-popup-scrolled"), this._containerWidth = this._container.offsetWidth
                            },
                            _animateZoom: function(t) {
                                var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center),
                                    n = this._getAnchor();
                                Et(this._container, e.add(n))
                            },
                            _adjustPan: function() {
                                if (!(!this.options.autoPan || this._map._panAnim && this._map._panAnim._inProgress)) {
                                    var t = this._map,
                                        e = parseInt(ht(this._container, "marginBottom"), 10) || 0,
                                        n = this._container.offsetHeight + e,
                                        i = this._containerWidth,
                                        o = new b(this._containerLeft, -n - this._containerBottom);
                                    o._add(Ct(this._container));
                                    var r = t.layerPointToContainerPoint(o),
                                        s = E(this.options.autoPanPadding),
                                        a = E(this.options.autoPanPaddingTopLeft || s),
                                        h = E(this.options.autoPanPaddingBottomRight || s),
                                        u = t.getSize(),
                                        l = 0,
                                        c = 0;
                                    r.x + i + h.x > u.x && (l = r.x + i - u.x + h.x), r.x - l - a.x < 0 && (l = r.x - a.x), r.y + n + h.y > u.y && (c = r.y + n - u.y + h.y), r.y - c - a.y < 0 && (c = r.y - a.y), (l || c) && t.fire("autopanstart").panBy([l, c])
                                }
                            },
                            _onCloseButtonClick: function(t) {
                                this._close(), tt(t)
                            },
                            _getAnchor: function() {
                                return E(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0])
                            }
                        }),
                        Oi = function(t, e) {
                            return new Ti(t, e)
                        };
                    zn.mergeOptions({
                        closePopupOnClick: !0
                    }), zn.include({
                        openPopup: function(t, e, n) {
                            return t instanceof Ti || (t = new Ti(n).setContent(t)), e && t.setLatLng(e), this.hasLayer(t) ? this : (this._popup && this._popup.options.autoClose && this.closePopup(), this._popup = t, this.addLayer(t))
                        },
                        closePopup: function(t) {
                            return t && t !== this._popup || (t = this._popup, this._popup = null), t && this.removeLayer(t), this
                        }
                    }), li.include({
                        bindPopup: function(t, e) {
                            return t instanceof Ti ? (c(t, e), this._popup = t, t._source = this) : (this._popup && !e || (this._popup = new Ti(e, this)), this._popup.setContent(t)), this._popupHandlersAdded || (this.on({
                                click: this._openPopup,
                                keypress: this._onKeyPress,
                                remove: this.closePopup,
                                move: this._movePopup
                            }), this._popupHandlersAdded = !0), this
                        },
                        unbindPopup: function() {
                            return this._popup && (this.off({
                                click: this._openPopup,
                                keypress: this._onKeyPress,
                                remove: this.closePopup,
                                move: this._movePopup
                            }), this._popupHandlersAdded = !1, this._popup = null), this
                        },
                        openPopup: function(t, e) {
                            if (t instanceof li || (e = t, t = this), t instanceof fi)
                                for (var n in this._layers) {
                                    t = this._layers[n];
                                    break
                                }
                            return e || (e = t.getCenter ? t.getCenter() : t.getLatLng()), this._popup && this._map && (this._popup._source = t, this._popup.update(), this._map.openPopup(this._popup, e)), this
                        },
                        closePopup: function() {
                            return this._popup && this._popup._close(), this
                        },
                        togglePopup: function(t) {
                            return this._popup && (this._popup._map ? this.closePopup() : this.openPopup(t)), this
                        },
                        isPopupOpen: function() {
                            return !!this._popup && this._popup.isOpen()
                        },
                        setPopupContent: function(t) {
                            return this._popup && this._popup.setContent(t), this
                        },
                        getPopup: function() {
                            return this._popup
                        },
                        _openPopup: function(t) {
                            var e = t.layer || t.target;
                            if (this._popup && this._map) {
                                if (tt(t),
                                    e instanceof vi) return void this.openPopup(t.layer || t.target, t.latlng);
                                this._map.hasLayer(this._popup) && this._popup._source === e ? this.closePopup() : this.openPopup(e, t.latlng)
                            }
                        },
                        _movePopup: function(t) {
                            this._popup.setLatLng(t.latlng)
                        },
                        _onKeyPress: function(t) {
                            13 === t.originalEvent.keyCode && this._openPopup(t)
                        }
                    });
                    var Ai = Ni.extend({
                            options: {
                                pane: "tooltipPane",
                                offset: [0, 0],
                                direction: "auto",
                                permanent: !1,
                                sticky: !1,
                                interactive: !1,
                                opacity: .9
                            },
                            onAdd: function(t) {
                                Ni.prototype.onAdd.call(this, t), this.setOpacity(this.options.opacity), t.fire("tooltipopen", {
                                    tooltip: this
                                }), this._source && this._source.fire("tooltipopen", {
                                    tooltip: this
                                }, !0)
                            },
                            onRemove: function(t) {
                                Ni.prototype.onRemove.call(this, t), t.fire("tooltipclose", {
                                    tooltip: this
                                }), this._source && this._source.fire("tooltipclose", {
                                    tooltip: this
                                }, !0)
                            },
                            getEvents: function() {
                                var t = Ni.prototype.getEvents.call(this);
                                return an && !this.options.permanent && (t.preclick = this._close), t
                            },
                            _close: function() {
                                this._map && this._map.closeTooltip(this)
                            },
                            _initLayout: function() {
                                var t = "leaflet-tooltip " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
                                this._contentNode = this._container = ut("div", t)
                            },
                            _updateLayout: function() {},
                            _adjustPan: function() {},
                            _setPosition: function(t) {
                                var e = this._map,
                                    n = this._container,
                                    i = e.latLngToContainerPoint(e.getCenter()),
                                    o = e.layerPointToContainerPoint(t),
                                    r = this.options.direction,
                                    s = n.offsetWidth,
                                    a = n.offsetHeight,
                                    h = E(this.options.offset),
                                    u = this._getAnchor();
                                "top" === r ? t = t.add(E(-s / 2 + h.x, -a + h.y + u.y, !0)) : "bottom" === r ? t = t.subtract(E(s / 2 - h.x, -h.y, !0)) : "center" === r ? t = t.subtract(E(s / 2 + h.x, a / 2 - u.y + h.y, !0)) : "right" === r || "auto" === r && o.x < i.x ? (r = "right", t = t.add(E(h.x + u.x, u.y - a / 2 + h.y, !0))) : (r = "left", t = t.subtract(E(s + u.x - h.x, a / 2 - u.y - h.y, !0))), gt(n, "leaflet-tooltip-right"), gt(n, "leaflet-tooltip-left"), gt(n, "leaflet-tooltip-top"), gt(n, "leaflet-tooltip-bottom"), _t(n, "leaflet-tooltip-" + r), Et(n, t)
                            },
                            _updatePosition: function() {
                                var t = this._map.latLngToLayerPoint(this._latlng);
                                this._setPosition(t)
                            },
                            setOpacity: function(t) {
                                this.options.opacity = t, this._container && vt(this._container, t)
                            },
                            _animateZoom: function(t) {
                                var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center);
                                this._setPosition(e)
                            },
                            _getAnchor: function() {
                                return E(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0])
                            }
                        }),
                        Ri = function(t, e) {
                            return new Ai(t, e)
                        };
                    zn.include({
                        openTooltip: function(t, e, n) {
                            return t instanceof Ai || (t = new Ai(n).setContent(t)), e && t.setLatLng(e), this.hasLayer(t) ? this : this.addLayer(t)
                        },
                        closeTooltip: function(t) {
                            return t && this.removeLayer(t), this
                        }
                    }), li.include({
                        bindTooltip: function(t, e) {
                            return t instanceof Ai ? (c(t, e), this._tooltip = t, t._source = this) : (this._tooltip && !e || (this._tooltip = new Ai(e, this)), this._tooltip.setContent(t)), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this
                        },
                        unbindTooltip: function() {
                            return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null), this
                        },
                        _initTooltipInteractions: function(t) {
                            if (t || !this._tooltipHandlersAdded) {
                                var e = t ? "off" : "on",
                                    n = {
                                        remove: this.closeTooltip,
                                        move: this._moveTooltip
                                    };
                                this._tooltip.options.permanent ? n.add = this._openTooltip : (n.mouseover = this._openTooltip, n.mouseout = this.closeTooltip, this._tooltip.options.sticky && (n.mousemove = this._moveTooltip), an && (n.click = this._openTooltip)), this[e](n), this._tooltipHandlersAdded = !t
                            }
                        },
                        openTooltip: function(t, e) {
                            if (t instanceof li || (e = t, t = this), t instanceof fi)
                                for (var n in this._layers) {
                                    t = this._layers[n];
                                    break
                                }
                            return e || (e = t.getCenter ? t.getCenter() : t.getLatLng()), this._tooltip && this._map && (this._tooltip._source = t, this._tooltip.update(), this._map.openTooltip(this._tooltip, e), this._tooltip.options.interactive && this._tooltip._container && (_t(this._tooltip._container, "leaflet-clickable"), this.addInteractiveTarget(this._tooltip._container))), this
                        },
                        closeTooltip: function() {
                            return this._tooltip && (this._tooltip._close(), this._tooltip.options.interactive && this._tooltip._container && (gt(this._tooltip._container, "leaflet-clickable"), this.removeInteractiveTarget(this._tooltip._container))), this
                        },
                        toggleTooltip: function(t) {
                            return this._tooltip && (this._tooltip._map ? this.closeTooltip() : this.openTooltip(t)), this
                        },
                        isTooltipOpen: function() {
                            return this._tooltip.isOpen()
                        },
                        setTooltipContent: function(t) {
                            return this._tooltip && this._tooltip.setContent(t), this
                        },
                        getTooltip: function() {
                            return this._tooltip
                        },
                        _openTooltip: function(t) {
                            var e = t.layer || t.target;
                            this._tooltip && this._map && this.openTooltip(e, this._tooltip.options.sticky ? t.latlng : void 0)
                        },
                        _moveTooltip: function(t) {
                            var e, n, i = t.latlng;
                            this._tooltip.options.sticky && t.originalEvent && (e = this._map.mouseEventToContainerPoint(t.originalEvent), n = this._map.containerPointToLayerPoint(e), i = this._map.layerPointToLatLng(n)), this._tooltip.setLatLng(i)
                        }
                    });
                    var Di = _i.extend({
                        options: {
                            iconSize: [12, 12],
                            html: !1,
                            bgPos: null,
                            className: "leaflet-div-icon"
                        },
                        createIcon: function(t) {
                            var e = t && "DIV" === t.tagName ? t : document.createElement("div"),
                                n = this.options;
                            if (e.innerHTML = !1 !== n.html ? n.html : "", n.bgPos) {
                                var i = E(n.bgPos);
                                e.style.backgroundPosition = -i.x + "px " + -i.y + "px"
                            }
                            return this._setIconStyles(e, "icon"), e
                        },
                        createShadow: function() {
                            return null
                        }
                    });
                    _i.Default = gi;
                    var ki = li.extend({
                            options: {
                                tileSize: 256,
                                opacity: 1,
                                updateWhenIdle: en,
                                updateWhenZooming: !0,
                                updateInterval: 200,
                                zIndex: 1,
                                bounds: null,
                                minZoom: 0,
                                maxZoom: void 0,
                                maxNativeZoom: void 0,
                                minNativeZoom: void 0,
                                noWrap: !1,
                                pane: "tilePane",
                                className: "",
                                keepBuffer: 2
                            },
                            initialize: function(t) {
                                c(this, t)
                            },
                            onAdd: function() {
                                this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView(), this._update()
                            },
                            beforeAdd: function(t) {
                                t._addZoomLimit(this)
                            },
                            onRemove: function(t) {
                                this._removeAllTiles(), lt(this._container), t._removeZoomLimit(this), this._container = null, this._tileZoom = void 0
                            },
                            bringToFront: function() {
                                return this._map && (pt(this._container), this._setAutoZIndex(Math.max)), this
                            },
                            bringToBack: function() {
                                return this._map && (ft(this._container), this._setAutoZIndex(Math.min)), this
                            },
                            getContainer: function() {
                                return this._container
                            },
                            setOpacity: function(t) {
                                return this.options.opacity = t, this._updateOpacity(), this
                            },
                            setZIndex: function(t) {
                                return this.options.zIndex = t, this._updateZIndex(), this
                            },
                            isLoading: function() {
                                return this._loading
                            },
                            redraw: function() {
                                return this._map && (this._removeAllTiles(), this._update()), this
                            },
                            getEvents: function() {
                                var t = {
                                    viewprereset: this._invalidateAll,
                                    viewreset: this._resetView,
                                    zoom: this._resetView,
                                    moveend: this._onMoveEnd
                                };
                                return this.options.updateWhenIdle || (this._onMove || (this._onMove = r(this._onMoveEnd, this.options.updateInterval, this)), t.move = this._onMove), this._zoomAnimated && (t.zoomanim = this._animateZoom), t
                            },
                            createTile: function() {
                                return document.createElement("div")
                            },
                            getTileSize: function() {
                                var t = this.options.tileSize;
                                return t instanceof b ? t : new b(t, t)
                            },
                            _updateZIndex: function() {
                                this._container && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._container.style.zIndex = this.options.zIndex)
                            },
                            _setAutoZIndex: function(t) {
                                for (var e, n = this.getPane().children, i = -t(-1 / 0, 1 / 0), o = 0, r = n.length; o < r; o++) e = n[o].style.zIndex, n[o] !== this._container && e && (i = t(i, +e));
                                isFinite(i) && (this.options.zIndex = i + t(-1, 1), this._updateZIndex())
                            },
                            _updateOpacity: function() {
                                if (this._map && !Fe) {
                                    vt(this._container, this.options.opacity);
                                    var t = +new Date,
                                        e = !1,
                                        n = !1;
                                    for (var i in this._tiles) {
                                        var o = this._tiles[i];
                                        if (o.current && o.loaded) {
                                            var r = Math.min(1, (t - o.loaded) / 200);
                                            vt(o.el, r), r < 1 ? e = !0 : (o.active ? n = !0 : this._onOpaqueTile(o), o.active = !0)
                                        }
                                    }
                                    n && !this._noPrune && this._pruneTiles(), e && (y(this._fadeFrame), this._fadeFrame = m(this._updateOpacity, this))
                                }
                            },
                            _onOpaqueTile: a,
                            _initContainer: function() {
                                this._container || (this._container = ut("div", "leaflet-layer " + (this.options.className || "")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container))
                            },
                            _updateLevels: function() {
                                var t = this._tileZoom,
                                    e = this.options.maxZoom;
                                if (void 0 !== t) {
                                    for (var n in this._levels) this._levels[n].el.children.length || n === t ? (this._levels[n].el.style.zIndex = e - Math.abs(t - n), this._onUpdateLevel(n)) : (lt(this._levels[n].el), this._removeTilesAtZoom(n), this._onRemoveLevel(n), delete this._levels[n]);
                                    var i = this._levels[t],
                                        o = this._map;
                                    return i || (i = this._levels[t] = {}, i.el = ut("div", "leaflet-tile-container leaflet-zoom-animated", this._container), i.el.style.zIndex = e, i.origin = o.project(o.unproject(o.getPixelOrigin()), t).round(), i.zoom = t, this._setZoomTransform(i, o.getCenter(), o.getZoom()), i.el.offsetWidth, this._onCreateLevel(i)), this._level = i, i
                                }
                            },
                            _onUpdateLevel: a,
                            _onRemoveLevel: a,
                            _onCreateLevel: a,
                            _pruneTiles: function() {
                                if (this._map) {
                                    var t, e, n = this._map.getZoom();
                                    if (n > this.options.maxZoom || n < this.options.minZoom) return void this._removeAllTiles();
                                    for (t in this._tiles) e = this._tiles[t], e.retain = e.current;
                                    for (t in this._tiles)
                                        if (e = this._tiles[t], e.current && !e.active) {
                                            var i = e.coords;
                                            this._retainParent(i.x, i.y, i.z, i.z - 5) || this._retainChildren(i.x, i.y, i.z, i.z + 2)
                                        }
                                    for (t in this._tiles) this._tiles[t].retain || this._removeTile(t)
                                }
                            },
                            _removeTilesAtZoom: function(t) {
                                for (var e in this._tiles) this._tiles[e].coords.z === t && this._removeTile(e)
                            },
                            _removeAllTiles: function() {
                                for (var t in this._tiles) this._removeTile(t)
                            },
                            _invalidateAll: function() {
                                for (var t in this._levels) lt(this._levels[t].el), this._onRemoveLevel(t), delete this._levels[t];
                                this._removeAllTiles(), this._tileZoom = void 0
                            },
                            _retainParent: function(t, e, n, i) {
                                var o = Math.floor(t / 2),
                                    r = Math.floor(e / 2),
                                    s = n - 1,
                                    a = new b(+o, +r);
                                a.z = +s;
                                var h = this._tileCoordsToKey(a),
                                    u = this._tiles[h];
                                return u && u.active ? (u.retain = !0, !0) : (u && u.loaded && (u.retain = !0), s > i && this._retainParent(o, r, s, i))
                            },
                            _retainChildren: function(t, e, n, i) {
                                for (var o = 2 * t; o < 2 * t + 2; o++)
                                    for (var r = 2 * e; r < 2 * e + 2; r++) {
                                        var s = new b(o, r);
                                        s.z = n + 1;
                                        var a = this._tileCoordsToKey(s),
                                            h = this._tiles[a];
                                        h && h.active ? h.retain = !0 : (h && h.loaded && (h.retain = !0), n + 1 < i && this._retainChildren(o, r, n + 1, i))
                                    }
                            },
                            _resetView: function(t) {
                                var e = t && (t.pinch || t.flyTo);
                                this._setView(this._map.getCenter(), this._map.getZoom(), e, e)
                            },
                            _animateZoom: function(t) {
                                this._setView(t.center, t.zoom, !0, t.noUpdate)
                            },
                            _clampZoom: function(t) {
                                var e = this.options;
                                return void 0 !== e.minNativeZoom && t < e.minNativeZoom ? e.minNativeZoom : void 0 !== e.maxNativeZoom && e.maxNativeZoom < t ? e.maxNativeZoom : t
                            },
                            _setView: function(t, e, n, i) {
                                var o = this._clampZoom(Math.round(e));
                                (void 0 !== this.options.maxZoom && o > this.options.maxZoom || void 0 !== this.options.minZoom && o < this.options.minZoom) && (o = void 0);
                                var r = this.options.updateWhenZooming && o !== this._tileZoom;
                                i && !r || (this._tileZoom = o, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), void 0 !== o && this._update(t), n || this._pruneTiles(), this._noPrune = !!n), this._setZoomTransforms(t, e)
                            },
                            _setZoomTransforms: function(t, e) {
                                for (var n in this._levels) this._setZoomTransform(this._levels[n], t, e)
                            },
                            _setZoomTransform: function(t, e, n) {
                                var i = this._map.getZoomScale(n, t.zoom),
                                    o = t.origin.multiplyBy(i).subtract(this._map._getNewPixelOrigin(e, n)).round();
                                tn ? bt(t.el, o, i) : Et(t.el, o)
                            },
                            _resetGrid: function() {
                                var t = this._map,
                                    e = t.options.crs,
                                    n = this._tileSize = this.getTileSize(),
                                    i = this._tileZoom,
                                    o = this._map.getPixelWorldBounds(this._tileZoom);
                                o && (this._globalTileRange = this._pxBoundsToTileRange(o)), this._wrapX = e.wrapLng && !this.options.noWrap && [Math.floor(t.project([0, e.wrapLng[0]], i).x / n.x), Math.ceil(t.project([0, e.wrapLng[1]], i).x / n.y)], this._wrapY = e.wrapLat && !this.options.noWrap && [Math.floor(t.project([e.wrapLat[0], 0], i).y / n.x), Math.ceil(t.project([e.wrapLat[1], 0], i).y / n.y)]
                            },
                            _onMoveEnd: function() {
                                this._map && !this._map._animatingZoom && this._update()
                            },
                            _getTiledPixelBounds: function(t) {
                                var e = this._map,
                                    n = e._animatingZoom ? Math.max(e._animateToZoom, e.getZoom()) : e.getZoom(),
                                    i = e.getZoomScale(n, this._tileZoom),
                                    o = e.project(t, this._tileZoom).floor(),
                                    r = e.getSize().divideBy(2 * i);
                                return new C(o.subtract(r), o.add(r))
                            },
                            _update: function(t) {
                                var e = this._map;
                                if (e) {
                                    var n = this._clampZoom(e.getZoom());
                                    if (void 0 === t && (t = e.getCenter()), void 0 !== this._tileZoom) {
                                        var i = this._getTiledPixelBounds(t),
                                            o = this._pxBoundsToTileRange(i),
                                            r = o.getCenter(),
                                            s = [],
                                            a = this.options.keepBuffer,
                                            h = new C(o.getBottomLeft().subtract([a, -a]), o.getTopRight().add([a, -a]));
                                        if (!(isFinite(o.min.x) && isFinite(o.min.y) && isFinite(o.max.x) && isFinite(o.max.y))) throw new Error("Attempted to load an infinite number of tiles");
                                        for (var u in this._tiles) {
                                            var l = this._tiles[u].coords;
                                            l.z === this._tileZoom && h.contains(new b(l.x, l.y)) || (this._tiles[u].current = !1)
                                        }
                                        if (Math.abs(n - this._tileZoom) > 1) return void this._setView(t, n);
                                        for (var c = o.min.y; c <= o.max.y; c++)
                                            for (var p = o.min.x; p <= o.max.x; p++) {
                                                var f = new b(p, c);
                                                if (f.z = this._tileZoom, this._isValidTile(f)) {
                                                    var d = this._tiles[this._tileCoordsToKey(f)];
                                                    d ? d.current = !0 : s.push(f)
                                                }
                                            }
                                        if (s.sort(function(t, e) {
                                            return t.distanceTo(r) - e.distanceTo(r)
                                        }), 0 !== s.length) {
                                            this._loading || (this._loading = !0, this.fire("loading"));
                                            var _ = document.createDocumentFragment();
                                            for (p = 0; p < s.length; p++) this._addTile(s[p], _);
                                            this._level.el.appendChild(_)
                                        }
                                    }
                                }
                            },
                            _isValidTile: function(t) {
                                var e = this._map.options.crs;
                                if (!e.infinite) {
                                    var n = this._globalTileRange;
                                    if (!e.wrapLng && (t.x < n.min.x || t.x > n.max.x) || !e.wrapLat && (t.y < n.min.y || t.y > n.max.y)) return !1
                                }
                                if (!this.options.bounds) return !0;
                                var i = this._tileCoordsToBounds(t);
                                return M(this.options.bounds).overlaps(i)
                            },
                            _keyToBounds: function(t) {
                                return this._tileCoordsToBounds(this._keyToTileCoords(t))
                            },
                            _tileCoordsToNwSe: function(t) {
                                var e = this._map,
                                    n = this.getTileSize(),
                                    i = t.scaleBy(n),
                                    o = i.add(n);
                                return [e.unproject(i, t.z), e.unproject(o, t.z)]
                            },
                            _tileCoordsToBounds: function(t) {
                                var e = this._tileCoordsToNwSe(t),
                                    n = new w(e[0], e[1]);
                                return this.options.noWrap || (n = this._map.wrapLatLngBounds(n)), n
                            },
                            _tileCoordsToKey: function(t) {
                                return t.x + ":" + t.y + ":" + t.z
                            },
                            _keyToTileCoords: function(t) {
                                var e = t.split(":"),
                                    n = new b(+e[0], +e[1]);
                                return n.z = +e[2], n
                            },
                            _removeTile: function(t) {
                                var e = this._tiles[t];
                                e && (qe || e.el.setAttribute("src", ye), lt(e.el), delete this._tiles[t], this.fire("tileunload", {
                                    tile: e.el,
                                    coords: this._keyToTileCoords(t)
                                }))
                            },
                            _initTile: function(t) {
                                _t(t, "leaflet-tile");
                                var e = this.getTileSize();
                                t.style.width = e.x + "px", t.style.height = e.y + "px", t.onselectstart = a, t.onmousemove = a, Fe && this.options.opacity < 1 && vt(t, this.options.opacity), Ge && !Ue && (t.style.WebkitBackfaceVisibility = "hidden")
                            },
                            _addTile: function(t, e) {
                                var n = this._getTilePos(t),
                                    o = this._tileCoordsToKey(t),
                                    r = this.createTile(this._wrapCoords(t), i(this._tileReady, this, t));
                                this._initTile(r), this.createTile.length < 2 && m(i(this._tileReady, this, t, null, r)), Et(r, n), this._tiles[o] = {
                                    el: r,
                                    coords: t,
                                    current: !0
                                }, e.appendChild(r), this.fire("tileloadstart", {
                                    tile: r,
                                    coords: t
                                })
                            },
                            _tileReady: function(t, e, n) {
                                if (this._map) {
                                    e && this.fire("tileerror", {
                                        error: e,
                                        tile: n,
                                        coords: t
                                    });
                                    var o = this._tileCoordsToKey(t);
                                    n = this._tiles[o], n && (n.loaded = +new Date, this._map._fadeAnimated ? (vt(n.el, 0), y(this._fadeFrame), this._fadeFrame = m(this._updateOpacity, this)) : (n.active = !0, this._pruneTiles()), e || (_t(n.el, "leaflet-tile-loaded"), this.fire("tileload", {
                                        tile: n.el,
                                        coords: t
                                    })), this._noTilesToLoad() && (this._loading = !1, this.fire("load"), Fe || !this._map._fadeAnimated ? m(this._pruneTiles, this) : setTimeout(i(this._pruneTiles, this), 250)))
                                }
                            },
                            _getTilePos: function(t) {
                                return t.scaleBy(this.getTileSize()).subtract(this._level.origin)
                            },
                            _wrapCoords: function(t) {
                                var e = new b(this._wrapX ? s(t.x, this._wrapX) : t.x, this._wrapY ? s(t.y, this._wrapY) : t.y);
                                return e.z = t.z, e
                            },
                            _pxBoundsToTileRange: function(t) {
                                var e = this.getTileSize();
                                return new C(t.min.unscaleBy(e).floor(), t.max.unscaleBy(e).ceil().subtract([1, 1]))
                            },
                            _noTilesToLoad: function() {
                                for (var t in this._tiles)
                                    if (!this._tiles[t].loaded) return !1;
                                return !0
                            }
                        }),
                        Fi = ki.extend({
                            options: {
                                minZoom: 0,
                                maxZoom: 18,
                                subdomains: "abc",
                                errorTileUrl: "",
                                zoomOffset: 0,
                                tms: !1,
                                zoomReverse: !1,
                                detectRetina: !1,
                                crossOrigin: !1
                            },
                            initialize: function(t, e) {
                                this._url = t, e = c(this, e), e.detectRetina && ln && e.maxZoom > 0 && (e.tileSize = Math.floor(e.tileSize / 2), e.zoomReverse ? (e.zoomOffset--, e.minZoom++) : (e.zoomOffset++, e.maxZoom--), e.minZoom = Math.max(0, e.minZoom)), "string" == typeof e.subdomains && (e.subdomains = e.subdomains.split("")), Ge || this.on("tileunload", this._onTileRemove)
                            },
                            setUrl: function(t, e) {
                                return this._url = t, e || this.redraw(), this
                            },
                            createTile: function(t, e) {
                                var n = document.createElement("img");
                                return H(n, "load", i(this._tileOnLoad, this, e, n)), H(n, "error", i(this._tileOnError, this, e, n)), this.options.crossOrigin && (n.crossOrigin = ""), n.alt = "", n.setAttribute("role", "presentation"), n.src = this.getTileUrl(t), n
                            },
                            getTileUrl: function(t) {
                                var n = {
                                    r: ln ? "@2x" : "",
                                    s: this._getSubdomain(t),
                                    x: t.x,
                                    y: t.y,
                                    z: this._getZoomForUrl()
                                };
                                if (this._map && !this._map.options.crs.infinite) {
                                    var i = this._globalTileRange.max.y - t.y;
                                    this.options.tms && (n.y = i), n["-y"] = i
                                }
                                return f(this._url, e(n, this.options))
                            },
                            _tileOnLoad: function(t, e) {
                                Fe ? setTimeout(i(t, this, null, e), 0) : t(null, e)
                            },
                            _tileOnError: function(t, e, n) {
                                var i = this.options.errorTileUrl;
                                i && e.getAttribute("src") !== i && (e.src = i), t(n, e)
                            },
                            _onTileRemove: function(t) {
                                t.tile.onload = null
                            },
                            _getZoomForUrl: function() {
                                var t = this._tileZoom,
                                    e = this.options.maxZoom,
                                    n = this.options.zoomReverse,
                                    i = this.options.zoomOffset;
                                return n && (t = e - t), t + i
                            },
                            _getSubdomain: function(t) {
                                var e = Math.abs(t.x + t.y) % this.options.subdomains.length;
                                return this.options.subdomains[e]
                            },
                            _abortLoading: function() {
                                var t, e;
                                for (t in this._tiles) this._tiles[t].coords.z !== this._tileZoom && (e = this._tiles[t].el, e.onload = a, e.onerror = a, e.complete || (e.src = ye, lt(e), delete this._tiles[t]))
                            }
                        }),
                        zi = Fi.extend({
                            defaultWmsParams: {
                                service: "WMS",
                                request: "GetMap",
                                layers: "",
                                styles: "",
                                format: "image/jpeg",
                                transparent: !1,
                                version: "1.1.1"
                            },
                            options: {
                                crs: null,
                                uppercase: !1
                            },
                            initialize: function(t, n) {
                                this._url = t;
                                var i = e({}, this.defaultWmsParams);
                                for (var o in n) o in this.options || (i[o] = n[o]);
                                n = c(this, n);
                                var r = n.detectRetina && ln ? 2 : 1,
                                    s = this.getTileSize();
                                i.width = s.x * r, i.height = s.y * r, this.wmsParams = i
                            },
                            onAdd: function(t) {
                                this._crs = this.options.crs || t.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
                                var e = this._wmsVersion >= 1.3 ? "crs" : "srs";
                                this.wmsParams[e] = this._crs.code, Fi.prototype.onAdd.call(this, t)
                            },
                            getTileUrl: function(t) {
                                var e = this._tileCoordsToNwSe(t),
                                    n = this._crs,
                                    i = I(n.project(e[0]), n.project(e[1])),
                                    o = i.min,
                                    r = i.max,
                                    s = (this._wmsVersion >= 1.3 && this._crs === hi ? [o.y, o.x, r.y, r.x] : [o.x, o.y, r.x, r.y]).join(","),
                                    a = L.TileLayer.prototype.getTileUrl.call(this, t);
                                return a + p(this.wmsParams, a, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + s
                            },
                            setParams: function(t, n) {
                                return e(this.wmsParams, t), n || this.redraw(), this
                            }
                        });
                    Fi.WMS = zi, ae.wms = he;
                    var Bi = li.extend({
                            options: {
                                padding: .1,
                                tolerance: 0
                            },
                            initialize: function(t) {
                                c(this, t), o(this), this._layers = this._layers || {}
                            },
                            onAdd: function() {
                                this._container || (this._initContainer(), this._zoomAnimated && _t(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this)
                            },
                            onRemove: function() {
                                this.off("update", this._updatePaths, this), this._destroyContainer()
                            },
                            getEvents: function() {
                                var t = {
                                    viewreset: this._reset,
                                    zoom: this._onZoom,
                                    moveend: this._update,
                                    zoomend: this._onZoomEnd
                                };
                                return this._zoomAnimated && (t.zoomanim = this._onAnimZoom), t
                            },
                            _onAnimZoom: function(t) {
                                this._updateTransform(t.center, t.zoom)
                            },
                            _onZoom: function() {
                                this._updateTransform(this._map.getCenter(), this._map.getZoom())
                            },
                            _updateTransform: function(t, e) {
                                var n = this._map.getZoomScale(e, this._zoom),
                                    i = Ct(this._container),
                                    o = this._map.getSize().multiplyBy(.5 + this.options.padding),
                                    r = this._map.project(this._center, e),
                                    s = this._map.project(t, e),
                                    a = s.subtract(r),
                                    h = o.multiplyBy(-n).add(i).add(o).subtract(a);
                                tn ? bt(this._container, h, n) : Et(this._container, h)
                            },
                            _reset: function() {
                                this._update(), this._updateTransform(this._center, this._zoom);
                                for (var t in this._layers) this._layers[t]._reset()
                            },
                            _onZoomEnd: function() {
                                for (var t in this._layers) this._layers[t]._project()
                            },
                            _updatePaths: function() {
                                for (var t in this._layers) this._layers[t]._update()
                            },
                            _update: function() {
                                var t = this.options.padding,
                                    e = this._map.getSize(),
                                    n = this._map.containerPointToLayerPoint(e.multiplyBy(-t)).round();
                                this._bounds = new C(n, n.add(e.multiplyBy(1 + 2 * t)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom()
                            }
                        }),
                        Gi = Bi.extend({
                            getEvents: function() {
                                var t = Bi.prototype.getEvents.call(this);
                                return t.viewprereset = this._onViewPreReset, t
                            },
                            _onViewPreReset: function() {
                                this._postponeUpdatePaths = !0
                            },
                            onAdd: function() {
                                Bi.prototype.onAdd.call(this), this._draw()
                            },
                            _initContainer: function() {
                                var t = this._container = document.createElement("canvas");
                                H(t, "mousemove", r(this._onMouseMove, 32, this), this), H(t, "click dblclick mousedown mouseup contextmenu", this._onClick, this), H(t, "mouseout", this._handleMouseOut, this), this._ctx = t.getContext("2d")
                            },
                            _destroyContainer: function() {
                                delete this._ctx, lt(this._container), Y(this._container), delete this._container
                            },
                            _updatePaths: function() {
                                if (!this._postponeUpdatePaths) {
                                    var t;
                                    this._redrawBounds = null;
                                    for (var e in this._layers) t = this._layers[e], t._update();
                                    this._redraw()
                                }
                            },
                            _update: function() {
                                if (!this._map._animatingZoom || !this._bounds) {
                                    this._drawnLayers = {}, Bi.prototype._update.call(this);
                                    var t = this._bounds,
                                        e = this._container,
                                        n = t.getSize(),
                                        i = ln ? 2 : 1;
                                    Et(e, t.min), e.width = i * n.x, e.height = i * n.y, e.style.width = n.x + "px", e.style.height = n.y + "px", ln && this._ctx.scale(2, 2), this._ctx.translate(-t.min.x, -t.min.y), this.fire("update")
                                }
                            },
                            _reset: function() {
                                Bi.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths())
                            },
                            _initPath: function(t) {
                                this._updateDashArray(t), this._layers[o(t)] = t;
                                var e = t._order = {
                                    layer: t,
                                    prev: this._drawLast,
                                    next: null
                                };
                                this._drawLast && (this._drawLast.next = e), this._drawLast = e, this._drawFirst = this._drawFirst || this._drawLast
                            },
                            _addPath: function(t) {
                                this._requestRedraw(t)
                            },
                            _removePath: function(t) {
                                var e = t._order,
                                    n = e.next,
                                    i = e.prev;
                                n ? n.prev = i : this._drawLast = i, i ? i.next = n : this._drawFirst = n, delete t._order, delete this._layers[L.stamp(t)], this._requestRedraw(t)
                            },
                            _updatePath: function(t) {
                                this._extendRedrawBounds(t), t._project(), t._update(), this._requestRedraw(t)
                            },
                            _updateStyle: function(t) {
                                this._updateDashArray(t), this._requestRedraw(t)
                            },
                            _updateDashArray: function(t) {
                                if (t.options.dashArray) {
                                    var e, n = t.options.dashArray.split(","),
                                        i = [];
                                    for (e = 0; e < n.length; e++) i.push(Number(n[e]));
                                    t.options._dashArray = i
                                }
                            },
                            _requestRedraw: function(t) {
                                this._map && (this._extendRedrawBounds(t), this._redrawRequest = this._redrawRequest || m(this._redraw, this))
                            },
                            _extendRedrawBounds: function(t) {
                                if (t._pxBounds) {
                                    var e = (t.options.weight || 0) + 1;
                                    this._redrawBounds = this._redrawBounds || new C, this._redrawBounds.extend(t._pxBounds.min.subtract([e, e])), this._redrawBounds.extend(t._pxBounds.max.add([e, e]))
                                }
                            },
                            _redraw: function() {
                                this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null
                            },
                            _clear: function() {
                                var t = this._redrawBounds;
                                if (t) {
                                    var e = t.getSize();
                                    this._ctx.clearRect(t.min.x, t.min.y, e.x, e.y)
                                } else this._ctx.clearRect(0, 0, this._container.width, this._container.height)
                            },
                            _draw: function() {
                                var t, e = this._redrawBounds;
                                if (this._ctx.save(), e) {
                                    var n = e.getSize();
                                    this._ctx.beginPath(), this._ctx.rect(e.min.x, e.min.y, n.x, n.y), this._ctx.clip()
                                }
                                this._drawing = !0;
                                for (var i = this._drawFirst; i; i = i.next) t = i.layer, (!e || t._pxBounds && t._pxBounds.intersects(e)) && t._updatePath();
                                this._drawing = !1, this._ctx.restore()
                            },
                            _updatePoly: function(t, e) {
                                if (this._drawing) {
                                    var n, i, o, r, s = t._parts,
                                        a = s.length,
                                        h = this._ctx;
                                    if (a) {
                                        for (this._drawnLayers[t._leaflet_id] = t, h.beginPath(), n = 0; n < a; n++) {
                                            for (i = 0, o = s[n].length; i < o; i++) r = s[n][i], h[i ? "lineTo" : "moveTo"](r.x, r.y);
                                            e && h.closePath()
                                        }
                                        this._fillStroke(h, t)
                                    }
                                }
                            },
                            _updateCircle: function(t) {
                                if (this._drawing && !t._empty()) {
                                    var e = t._point,
                                        n = this._ctx,
                                        i = Math.max(Math.round(t._radius), 1),
                                        o = (Math.max(Math.round(t._radiusY), 1) || i) / i;
                                    this._drawnLayers[t._leaflet_id] = t, 1 !== o && (n.save(), n.scale(1, o)), n.beginPath(), n.arc(e.x, e.y / o, i, 0, 2 * Math.PI, !1), 1 !== o && n.restore(), this._fillStroke(n, t)
                                }
                            },
                            _fillStroke: function(t, e) {
                                var n = e.options;
                                n.fill && (t.globalAlpha = n.fillOpacity, t.fillStyle = n.fillColor || n.color, t.fill(n.fillRule || "evenodd")), n.stroke && 0 !== n.weight && (t.setLineDash && t.setLineDash(e.options && e.options._dashArray || []), t.globalAlpha = n.opacity, t.lineWidth = n.weight, t.strokeStyle = n.color, t.lineCap = n.lineCap, t.lineJoin = n.lineJoin, t.stroke())
                            },
                            _onClick: function(t) {
                                for (var e, n, i = this._map.mouseEventToLayerPoint(t), o = this._drawFirst; o; o = o.next) e = o.layer, e.options.interactive && e._containsPoint(i) && !this._map._draggableMoved(e) && (n = e);
                                n && (it(t), this._fireEvent([n], t))
                            },
                            _onMouseMove: function(t) {
                                if (this._map && !this._map.dragging.moving() && !this._map._animatingZoom) {
                                    var e = this._map.mouseEventToLayerPoint(t);
                                    this._handleMouseHover(t, e)
                                }
                            },
                            _handleMouseOut: function(t) {
                                var e = this._hoveredLayer;
                                e && (gt(this._container, "leaflet-interactive"), this._fireEvent([e], t, "mouseout"), this._hoveredLayer = null)
                            },
                            _handleMouseHover: function(t, e) {
                                for (var n, i, o = this._drawFirst; o; o = o.next) n = o.layer, n.options.interactive && n._containsPoint(e) && (i = n);
                                i !== this._hoveredLayer && (this._handleMouseOut(t), i && (_t(this._container, "leaflet-interactive"), this._fireEvent([i], t, "mouseover"), this._hoveredLayer = i)), this._hoveredLayer && this._fireEvent([this._hoveredLayer], t)
                            },
                            _fireEvent: function(t, e, n) {
                                this._map._fireDOMEvent(e, n || e.type, t)
                            },
                            _bringToFront: function(t) {
                                var e = t._order,
                                    n = e.next,
                                    i = e.prev;
                                n && (n.prev = i, i ? i.next = n : n && (this._drawFirst = n), e.prev = this._drawLast, this._drawLast.next = e, e.next = null, this._drawLast = e, this._requestRedraw(t))
                            },
                            _bringToBack: function(t) {
                                var e = t._order,
                                    n = e.next,
                                    i = e.prev;
                                i && (i.next = n, n ? n.prev = i : i && (this._drawLast = i), e.prev = null, e.next = this._drawFirst, this._drawFirst.prev = e, this._drawFirst = e, this._requestRedraw(t))
                            }
                        }),
                        Ui = function() {
                            try {
                                return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"),
                                    function(t) {
                                        return document.createElement("<lvml:" + t + ' class="lvml">')
                                    }
                            } catch (t) {
                                return function(t) {
                                    return document.createElement("<" + t + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')
                                }
                            }
                        }(),
                        ji = {
                            _initContainer: function() {
                                this._container = ut("div", "leaflet-vml-container")
                            },
                            _update: function() {
                                this._map._animatingZoom || (Bi.prototype._update.call(this), this.fire("update"))
                            },
                            _initPath: function(t) {
                                var e = t._container = Ui("shape");
                                _t(e, "leaflet-vml-shape " + (this.options.className || "")), e.coordsize = "1 1", t._path = Ui("path"), e.appendChild(t._path), this._updateStyle(t), this._layers[o(t)] = t
                            },
                            _addPath: function(t) {
                                var e = t._container;
                                this._container.appendChild(e), t.options.interactive && t.addInteractiveTarget(e)
                            },
                            _removePath: function(t) {
                                var e = t._container;
                                lt(e), t.removeInteractiveTarget(e), delete this._layers[o(t)]
                            },
                            _updateStyle: function(t) {
                                var e = t._stroke,
                                    n = t._fill,
                                    i = t.options,
                                    o = t._container;
                                o.stroked = !!i.stroke, o.filled = !!i.fill, i.stroke ? (e || (e = t._stroke = Ui("stroke")), o.appendChild(e), e.weight = i.weight + "px", e.color = i.color, e.opacity = i.opacity, i.dashArray ? e.dashStyle = me(i.dashArray) ? i.dashArray.join(" ") : i.dashArray.replace(/( *, *)/g, " ") : e.dashStyle = "", e.endcap = i.lineCap.replace("butt", "flat"), e.joinstyle = i.lineJoin) : e && (o.removeChild(e), t._stroke = null), i.fill ? (n || (n = t._fill = Ui("fill")), o.appendChild(n), n.color = i.fillColor || i.color, n.opacity = i.fillOpacity) : n && (o.removeChild(n), t._fill = null)
                            },
                            _updateCircle: function(t) {
                                var e = t._point.round(),
                                    n = Math.round(t._radius),
                                    i = Math.round(t._radiusY || n);
                                this._setPath(t, t._empty() ? "M0 0" : "AL " + e.x + "," + e.y + " " + n + "," + i + " 0,23592600")
                            },
                            _setPath: function(t, e) {
                                t._path.v = e
                            },
                            _bringToFront: function(t) {
                                pt(t._container)
                            },
                            _bringToBack: function(t) {
                                ft(t._container)
                            }
                        },
                        qi = fn ? Ui : O,
                        Zi = Bi.extend({
                            getEvents: function() {
                                var t = Bi.prototype.getEvents.call(this);
                                return t.zoomstart = this._onZoomStart, t
                            },
                            _initContainer: function() {
                                this._container = qi("svg"), this._container.setAttribute("pointer-events", "none"), this._rootGroup = qi("g"), this._container.appendChild(this._rootGroup)
                            },
                            _destroyContainer: function() {
                                lt(this._container), Y(this._container), delete this._container, delete this._rootGroup, delete this._svgSize
                            },
                            _onZoomStart: function() {
                                this._update()
                            },
                            _update: function() {
                                if (!this._map._animatingZoom || !this._bounds) {
                                    Bi.prototype._update.call(this);
                                    var t = this._bounds,
                                        e = t.getSize(),
                                        n = this._container;
                                    this._svgSize && this._svgSize.equals(e) || (this._svgSize = e, n.setAttribute("width", e.x), n.setAttribute("height", e.y)), Et(n, t.min), n.setAttribute("viewBox", [t.min.x, t.min.y, e.x, e.y].join(" ")), this.fire("update")
                                }
                            },
                            _initPath: function(t) {
                                var e = t._path = qi("path");
                                t.options.className && _t(e, t.options.className), t.options.interactive && _t(e, "leaflet-interactive"), this._updateStyle(t), this._layers[o(t)] = t
                            },
                            _addPath: function(t) {
                                this._rootGroup || this._initContainer(), this._rootGroup.appendChild(t._path), t.addInteractiveTarget(t._path)
                            },
                            _removePath: function(t) {
                                lt(t._path), t.removeInteractiveTarget(t._path), delete this._layers[o(t)]
                            },
                            _updatePath: function(t) {
                                t._project(), t._update()
                            },
                            _updateStyle: function(t) {
                                var e = t._path,
                                    n = t.options;
                                e && (n.stroke ? (e.setAttribute("stroke", n.color), e.setAttribute("stroke-opacity", n.opacity), e.setAttribute("stroke-width", n.weight), e.setAttribute("stroke-linecap", n.lineCap), e.setAttribute("stroke-linejoin", n.lineJoin), n.dashArray ? e.setAttribute("stroke-dasharray", n.dashArray) : e.removeAttribute("stroke-dasharray"), n.dashOffset ? e.setAttribute("stroke-dashoffset", n.dashOffset) : e.removeAttribute("stroke-dashoffset")) : e.setAttribute("stroke", "none"), n.fill ? (e.setAttribute("fill", n.fillColor || n.color), e.setAttribute("fill-opacity", n.fillOpacity), e.setAttribute("fill-rule", n.fillRule || "evenodd")) : e.setAttribute("fill", "none"))
                            },
                            _updatePoly: function(t, e) {
                                this._setPath(t, A(t._parts, e))
                            },
                            _updateCircle: function(t) {
                                var e = t._point,
                                    n = Math.max(Math.round(t._radius), 1),
                                    i = Math.max(Math.round(t._radiusY), 1) || n,
                                    o = "a" + n + "," + i + " 0 1,0 ",
                                    r = t._empty() ? "M0 0" : "M" + (e.x - n) + "," + e.y + o + 2 * n + ",0 " + o + 2 * -n + ",0 ";
                                this._setPath(t, r)
                            },
                            _setPath: function(t, e) {
                                t._path.setAttribute("d", e)
                            },
                            _bringToFront: function(t) {
                                pt(t._path)
                            },
                            _bringToBack: function(t) {
                                ft(t._path)
                            }
                        });
                    fn && Zi.include(ji), zn.include({
                        getRenderer: function(t) {
                            var e = t.options.renderer || this._getPaneRenderer(t.options.pane) || this.options.renderer || this._renderer;
                            return e || (e = this._renderer = this.options.preferCanvas && ue() || le()), this.hasLayer(e) || this.addLayer(e), e
                        },
                        _getPaneRenderer: function(t) {
                            if ("overlayPane" === t || void 0 === t) return !1;
                            var e = this._paneRenderers[t];
                            return void 0 === e && (e = Zi && le({
                                pane: t
                            }) || Gi && ue({
                                pane: t
                            }), this._paneRenderers[t] = e), e
                        }
                    });
                    var Vi = Ei.extend({
                        initialize: function(t, e) {
                            Ei.prototype.initialize.call(this, this._boundsToLatLngs(t), e)
                        },
                        setBounds: function(t) {
                            return this.setLatLngs(this._boundsToLatLngs(t))
                        },
                        _boundsToLatLngs: function(t) {
                            return t = M(t), [t.getSouthWest(), t.getNorthWest(), t.getNorthEast(), t.getSouthEast()]
                        }
                    });
                    Zi.create = qi, Zi.pointsToPath = A, Ci.geometryToLayer = Jt, Ci.coordsToLatLng = Kt, Ci.coordsToLatLngs = Qt, Ci.latLngToCoords = $t, Ci.latLngsToCoords = te, Ci.getFeature = ee, Ci.asFeature = ne, zn.mergeOptions({
                        boxZoom: !0
                    });
                    var Hi = Xn.extend({
                        initialize: function(t) {
                            this._map = t, this._container = t._container, this._pane = t._panes.overlayPane, this._resetStateTimeout = 0, t.on("unload", this._destroy, this)
                        },
                        addHooks: function() {
                            H(this._container, "mousedown", this._onMouseDown, this)
                        },
                        removeHooks: function() {
                            Y(this._container, "mousedown", this._onMouseDown, this)
                        },
                        moved: function() {
                            return this._moved
                        },
                        _destroy: function() {
                            lt(this._pane), delete this._pane
                        },
                        _resetState: function() {
                            this._resetStateTimeout = 0, this._moved = !1
                        },
                        _clearDeferredResetState: function() {
                            0 !== this._resetStateTimeout && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0)
                        },
                        _onMouseDown: function(t) {
                            if (!t.shiftKey || 1 !== t.which && 1 !== t.button) return !1;
                            this._clearDeferredResetState(), this._resetState(), Ne(), It(), this._startPoint = this._map.mouseEventToContainerPoint(t), H(document, {
                                contextmenu: tt,
                                mousemove: this._onMouseMove,
                                mouseup: this._onMouseUp,
                                keydown: this._onKeyDown
                            }, this)
                        },
                        _onMouseMove: function(t) {
                            this._moved || (this._moved = !0, this._box = ut("div", "leaflet-zoom-box", this._container), _t(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), this._point = this._map.mouseEventToContainerPoint(t);
                            var e = new C(this._point, this._startPoint),
                                n = e.getSize();
                            Et(this._box, e.min), this._box.style.width = n.x + "px", this._box.style.height = n.y + "px"
                        },
                        _finish: function() {
                            this._moved && (lt(this._box), gt(this._container, "leaflet-crosshair")), Te(), wt(), Y(document, {
                                contextmenu: tt,
                                mousemove: this._onMouseMove,
                                mouseup: this._onMouseUp,
                                keydown: this._onKeyDown
                            }, this)
                        },
                        _onMouseUp: function(t) {
                            if ((1 === t.which || 1 === t.button) && (this._finish(), this._moved)) {
                                this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(i(this._resetState, this), 0);
                                var e = new w(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));
                                this._map.fitBounds(e).fire("boxzoomend", {
                                    boxZoomBounds: e
                                })
                            }
                        },
                        _onKeyDown: function(t) {
                            27 === t.keyCode && this._finish()
                        }
                    });
                    zn.addInitHook("addHandler", "boxZoom", Hi), zn.mergeOptions({
                        doubleClickZoom: !0
                    });
                    var Yi = Xn.extend({
                        addHooks: function() {
                            this._map.on("dblclick", this._onDoubleClick, this)
                        },
                        removeHooks: function() {
                            this._map.off("dblclick", this._onDoubleClick, this)
                        },
                        _onDoubleClick: function(t) {
                            var e = this._map,
                                n = e.getZoom(),
                                i = e.options.zoomDelta,
                                o = t.originalEvent.shiftKey ? n - i : n + i;
                            "center" === e.options.doubleClickZoom ? e.setZoom(o) : e.setZoomAround(t.containerPoint, o)
                        }
                    });
                    zn.addInitHook("addHandler", "doubleClickZoom", Yi), zn.mergeOptions({
                        dragging: !0,
                        inertia: !Ue,
                        inertiaDeceleration: 3400,
                        inertiaMaxSpeed: 1 / 0,
                        easeLinearity: .2,
                        worldCopyJump: !1,
                        maxBoundsViscosity: 0
                    });
                    var Wi = Xn.extend({
                        addHooks: function() {
                            if (!this._draggable) {
                                var t = this._map;
                                this._draggable = new ei(t._mapPane, t._container), this._draggable.on({
                                    dragstart: this._onDragStart,
                                    drag: this._onDrag,
                                    dragend: this._onDragEnd
                                }, this), this._draggable.on("predrag", this._onPreDragLimit, this), t.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), t.on("zoomend", this._onZoomEnd, this), t.whenReady(this._onZoomEnd, this))
                            }
                            _t(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), this._positions = [], this._times = []
                        },
                        removeHooks: function() {
                            gt(this._map._container, "leaflet-grab"), gt(this._map._container, "leaflet-touch-drag"), this._draggable.disable()
                        },
                        moved: function() {
                            return this._draggable && this._draggable._moved
                        },
                        moving: function() {
                            return this._draggable && this._draggable._moving
                        },
                        _onDragStart: function() {
                            var t = this._map;
                            if (t._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
                                var e = M(this._map.options.maxBounds);
                                this._offsetLimit = I(this._map.latLngToContainerPoint(e.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(e.getSouthEast()).multiplyBy(-1).add(this._map.getSize())), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity))
                            } else this._offsetLimit = null;
                            t.fire("movestart").fire("dragstart"), t.options.inertia && (this._positions = [], this._times = [])
                        },
                        _onDrag: function(t) {
                            if (this._map.options.inertia) {
                                var e = this._lastTime = +new Date,
                                    n = this._lastPos = this._draggable._absPos || this._draggable._newPos;
                                this._positions.push(n), this._times.push(e), this._prunePositions(e)
                            }
                            this._map.fire("move", t).fire("drag", t)
                        },
                        _prunePositions: function(t) {
                            for (; this._positions.length > 1 && t - this._times[0] > 50;) this._positions.shift(), this._times.shift()
                        },
                        _onZoomEnd: function() {
                            var t = this._map.getSize().divideBy(2),
                                e = this._map.latLngToLayerPoint([0, 0]);
                            this._initialWorldOffset = e.subtract(t).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x
                        },
                        _viscousLimit: function(t, e) {
                            return t - (t - e) * this._viscosity
                        },
                        _onPreDragLimit: function() {
                            if (this._viscosity && this._offsetLimit) {
                                var t = this._draggable._newPos.subtract(this._draggable._startPos),
                                    e = this._offsetLimit;
                                t.x < e.min.x && (t.x = this._viscousLimit(t.x, e.min.x)), t.y < e.min.y && (t.y = this._viscousLimit(t.y, e.min.y)), t.x > e.max.x && (t.x = this._viscousLimit(t.x, e.max.x)), t.y > e.max.y && (t.y = this._viscousLimit(t.y, e.max.y)), this._draggable._newPos = this._draggable._startPos.add(t)
                            }
                        },
                        _onPreDragWrap: function() {
                            var t = this._worldWidth,
                                e = Math.round(t / 2),
                                n = this._initialWorldOffset,
                                i = this._draggable._newPos.x,
                                o = (i - e + n) % t + e - n,
                                r = (i + e + n) % t - e - n,
                                s = Math.abs(o + n) < Math.abs(r + n) ? o : r;
                            this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = s
                        },
                        _onDragEnd: function(t) {
                            var e = this._map,
                                n = e.options,
                                i = !n.inertia || this._times.length < 2;
                            if (e.fire("dragend", t), i) e.fire("moveend");
                            else {
                                this._prunePositions(+new Date);
                                var o = this._lastPos.subtract(this._positions[0]),
                                    r = (this._lastTime - this._times[0]) / 1e3,
                                    s = n.easeLinearity,
                                    a = o.multiplyBy(s / r),
                                    h = a.distanceTo([0, 0]),
                                    u = Math.min(n.inertiaMaxSpeed, h),
                                    l = a.multiplyBy(u / h),
                                    c = u / (n.inertiaDeceleration * s),
                                    p = l.multiplyBy(-c / 2).round();
                                p.x || p.y ? (p = e._limitOffset(p, e.options.maxBounds), m(function() {
                                    e.panBy(p, {
                                        duration: c,
                                        easeLinearity: s,
                                        noMoveStart: !0,
                                        animate: !0
                                    })
                                })) : e.fire("moveend")
                            }
                        }
                    });
                    zn.addInitHook("addHandler", "dragging", Wi), zn.mergeOptions({
                        keyboard: !0,
                        keyboardPanDelta: 80
                    });
                    var Xi = Xn.extend({
                        keyCodes: {
                            left: [37],
                            right: [39],
                            down: [40],
                            up: [38],
                            zoomIn: [187, 107, 61, 171],
                            zoomOut: [189, 109, 54, 173]
                        },
                        initialize: function(t) {
                            this._map = t, this._setPanDelta(t.options.keyboardPanDelta), this._setZoomDelta(t.options.zoomDelta)
                        },
                        addHooks: function() {
                            var t = this._map._container;
                            t.tabIndex <= 0 && (t.tabIndex = "0"), H(t, {
                                focus: this._onFocus,
                                blur: this._onBlur,
                                mousedown: this._onMouseDown
                            }, this), this._map.on({
                                focus: this._addHooks,
                                blur: this._removeHooks
                            }, this)
                        },
                        removeHooks: function() {
                            this._removeHooks(), Y(this._map._container, {
                                focus: this._onFocus,
                                blur: this._onBlur,
                                mousedown: this._onMouseDown
                            }, this), this._map.off({
                                focus: this._addHooks,
                                blur: this._removeHooks
                            }, this)
                        },
                        _onMouseDown: function() {
                            if (!this._focused) {
                                var t = document.body,
                                    e = document.documentElement,
                                    n = t.scrollTop || e.scrollTop,
                                    i = t.scrollLeft || e.scrollLeft;
                                this._map._container.focus(), window.scrollTo(i, n)
                            }
                        },
                        _onFocus: function() {
                            this._focused = !0, this._map.fire("focus")
                        },
                        _onBlur: function() {
                            this._focused = !1, this._map.fire("blur")
                        },
                        _setPanDelta: function(t) {
                            var e, n, i = this._panKeys = {},
                                o = this.keyCodes;
                            for (e = 0, n = o.left.length; e < n; e++) i[o.left[e]] = [-1 * t, 0];
                            for (e = 0, n = o.right.length; e < n; e++) i[o.right[e]] = [t, 0];
                            for (e = 0, n = o.down.length; e < n; e++) i[o.down[e]] = [0, t];
                            for (e = 0, n = o.up.length; e < n; e++) i[o.up[e]] = [0, -1 * t]
                        },
                        _setZoomDelta: function(t) {
                            var e, n, i = this._zoomKeys = {},
                                o = this.keyCodes;
                            for (e = 0, n = o.zoomIn.length; e < n; e++) i[o.zoomIn[e]] = t;
                            for (e = 0, n = o.zoomOut.length; e < n; e++) i[o.zoomOut[e]] = -t
                        },
                        _addHooks: function() {
                            H(document, "keydown", this._onKeyDown, this)
                        },
                        _removeHooks: function() {
                            Y(document, "keydown", this._onKeyDown, this)
                        },
                        _onKeyDown: function(t) {
                            if (!(t.altKey || t.ctrlKey || t.metaKey)) {
                                var e, n = t.keyCode,
                                    i = this._map;
                                if (n in this._panKeys) {
                                    if (i._panAnim && i._panAnim._inProgress) return;
                                    e = this._panKeys[n], t.shiftKey && (e = E(e).multiplyBy(3)), i.panBy(e), i.options.maxBounds && i.panInsideBounds(i.options.maxBounds)
                                } else if (n in this._zoomKeys) i.setZoom(i.getZoom() + (t.shiftKey ? 3 : 1) * this._zoomKeys[n]);
                                else {
                                    if (27 !== n || !i._popup || !i._popup.options.closeOnEscapeKey) return;
                                    i.closePopup()
                                }
                                tt(t)
                            }
                        }
                    });
                    zn.addInitHook("addHandler", "keyboard", Xi), zn.mergeOptions({
                        scrollWheelZoom: !0,
                        wheelDebounceTime: 40,
                        wheelPxPerZoomLevel: 60
                    });
                    var Ji = Xn.extend({
                        addHooks: function() {
                            H(this._map._container, "mousewheel", this._onWheelScroll, this), this._delta = 0
                        },
                        removeHooks: function() {
                            Y(this._map._container, "mousewheel", this._onWheelScroll, this)
                        },
                        _onWheelScroll: function(t) {
                            var e = nt(t),
                                n = this._map.options.wheelDebounceTime;
                            this._delta += e, this._lastMousePos = this._map.mouseEventToContainerPoint(t), this._startTime || (this._startTime = +new Date);
                            var o = Math.max(n - (+new Date - this._startTime), 0);
                            clearTimeout(this._timer), this._timer = setTimeout(i(this._performZoom, this), o), tt(t)
                        },
                        _performZoom: function() {
                            var t = this._map,
                                e = t.getZoom(),
                                n = this._map.options.zoomSnap || 0;
                            t._stop();
                            var i = this._delta / (4 * this._map.options.wheelPxPerZoomLevel),
                                o = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(i)))) / Math.LN2,
                                r = n ? Math.ceil(o / n) * n : o,
                                s = t._limitZoom(e + (this._delta > 0 ? r : -r)) - e;
                            this._delta = 0, this._startTime = null, s && ("center" === t.options.scrollWheelZoom ? t.setZoom(e + s) : t.setZoomAround(this._lastMousePos, e + s))
                        }
                    });
                    zn.addInitHook("addHandler", "scrollWheelZoom", Ji), zn.mergeOptions({
                        tap: !0,
                        tapTolerance: 15
                    });
                    var Ki = Xn.extend({
                        addHooks: function() {
                            H(this._map._container, "touchstart", this._onDown, this)
                        },
                        removeHooks: function() {
                            Y(this._map._container, "touchstart", this._onDown, this)
                        },
                        _onDown: function(t) {
                            if (t.touches) {
                                if ($(t), this._fireClick = !0, t.touches.length > 1) return this._fireClick = !1, void clearTimeout(this._holdTimeout);
                                var e = t.touches[0],
                                    n = e.target;
                                this._startPos = this._newPos = new b(e.clientX, e.clientY), n.tagName && "a" === n.tagName.toLowerCase() && _t(n, "leaflet-active"), this._holdTimeout = setTimeout(i(function() {
                                    this._isTapValid() && (this._fireClick = !1, this._onUp(), this._simulateEvent("contextmenu", e))
                                }, this), 1e3), this._simulateEvent("mousedown", e), H(document, {
                                    touchmove: this._onMove,
                                    touchend: this._onUp
                                }, this)
                            }
                        },
                        _onUp: function(t) {
                            if (clearTimeout(this._holdTimeout), Y(document, {
                                touchmove: this._onMove,
                                touchend: this._onUp
                            }, this), this._fireClick && t && t.changedTouches) {
                                var e = t.changedTouches[0],
                                    n = e.target;
                                n && n.tagName && "a" === n.tagName.toLowerCase() && gt(n, "leaflet-active"), this._simulateEvent("mouseup", e), this._isTapValid() && this._simulateEvent("click", e)
                            }
                        },
                        _isTapValid: function() {
                            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance
                        },
                        _onMove: function(t) {
                            var e = t.touches[0];
                            this._newPos = new b(e.clientX, e.clientY), this._simulateEvent("mousemove", e)
                        },
                        _simulateEvent: function(t, e) {
                            var n = document.createEvent("MouseEvents");
                            n._simulated = !0, e.target._simulatedClick = !0, n.initMouseEvent(t, !0, !0, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, !1, !1, !1, !1, 0, null), e.target.dispatchEvent(n)
                        }
                    });
                    an && !sn && zn.addInitHook("addHandler", "tap", Ki), zn.mergeOptions({
                        touchZoom: an && !Ue,
                        bounceAtZoomLimits: !0
                    });
                    var Qi = Xn.extend({
                        addHooks: function() {
                            _t(this._map._container, "leaflet-touch-zoom"), H(this._map._container, "touchstart", this._onTouchStart, this)
                        },
                        removeHooks: function() {
                            gt(this._map._container, "leaflet-touch-zoom"), Y(this._map._container, "touchstart", this._onTouchStart, this)
                        },
                        _onTouchStart: function(t) {
                            var e = this._map;
                            if (t.touches && 2 === t.touches.length && !e._animatingZoom && !this._zooming) {
                                var n = e.mouseEventToContainerPoint(t.touches[0]),
                                    i = e.mouseEventToContainerPoint(t.touches[1]);
                                this._centerPoint = e.getSize()._divideBy(2), this._startLatLng = e.containerPointToLatLng(this._centerPoint), "center" !== e.options.touchZoom && (this._pinchStartLatLng = e.containerPointToLatLng(n.add(i)._divideBy(2))), this._startDist = n.distanceTo(i), this._startZoom = e.getZoom(), this._moved = !1, this._zooming = !0, e._stop(), H(document, "touchmove", this._onTouchMove, this), H(document, "touchend", this._onTouchEnd, this), $(t)
                            }
                        },
                        _onTouchMove: function(t) {
                            if (t.touches && 2 === t.touches.length && this._zooming) {
                                var e = this._map,
                                    n = e.mouseEventToContainerPoint(t.touches[0]),
                                    o = e.mouseEventToContainerPoint(t.touches[1]),
                                    r = n.distanceTo(o) / this._startDist;
                                if (this._zoom = e.getScaleZoom(r, this._startZoom), !e.options.bounceAtZoomLimits && (this._zoom < e.getMinZoom() && r < 1 || this._zoom > e.getMaxZoom() && r > 1) && (this._zoom = e._limitZoom(this._zoom)), "center" === e.options.touchZoom) {
                                    if (this._center = this._startLatLng, 1 === r) return
                                } else {
                                    var s = n._add(o)._divideBy(2)._subtract(this._centerPoint);
                                    if (1 === r && 0 === s.x && 0 === s.y) return;
                                    this._center = e.unproject(e.project(this._pinchStartLatLng, this._zoom).subtract(s), this._zoom)
                                }
                                this._moved || (e._moveStart(!0, !1), this._moved = !0), y(this._animRequest);
                                var a = i(e._move, e, this._center, this._zoom, {
                                    pinch: !0,
                                    round: !1
                                });
                                this._animRequest = m(a, this, !0), $(t)
                            }
                        },
                        _onTouchEnd: function() {
                            if (!this._moved || !this._zooming) return void(this._zooming = !1);
                            this._zooming = !1, y(this._animRequest), Y(document, "touchmove", this._onTouchMove), Y(document, "touchend", this._onTouchEnd), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom))
                        }
                    });
                    zn.addInitHook("addHandler", "touchZoom", Qi), zn.BoxZoom = Hi, zn.DoubleClickZoom = Yi, zn.Drag = Wi, zn.Keyboard = Xi, zn.ScrollWheelZoom = Ji, zn.Tap = Ki, zn.TouchZoom = Qi;
                    var $i = window.L;
                    window.L = t, Object.freeze = fe, t.version = "1.3.1", t.noConflict = pe, t.Control = Bn, t.control = Gn, t.Browser = dn, t.Evented = Ce, t.Mixin = Kn, t.Util = be, t.Class = v, t.Handler = Xn, t.extend = e, t.bind = i, t.stamp = o, t.setOptions = c, t.DomEvent = Pn, t.DomUtil = kn, t.PosAnimation = Fn, t.Draggable = ei, t.LineUtil = ni, t.PolyUtil = ii, t.Point = b, t.point = E, t.Bounds = C, t.bounds = I, t.Transformation = N, t.transformation = T, t.Projection = si, t.LatLng = S, t.latLng = P, t.LatLngBounds = w, t.latLngBounds = M, t.CRS = we, t.GeoJSON = Ci, t.geoJSON = ie, t.geoJson = wi, t.Layer = li, t.LayerGroup = ci, t.layerGroup = pi, t.FeatureGroup = fi, t.featureGroup = di, t.ImageOverlay = Mi, t.imageOverlay = Si, t.VideoOverlay = Pi, t.videoOverlay = oe, t.DivOverlay = Ni, t.Popup = Ti, t.popup = Oi, t.Tooltip = Ai, t.tooltip = Ri, t.Icon = _i, t.icon = Zt, t.DivIcon = Di, t.divIcon = re, t.Marker = yi, t.marker = Vt, t.TileLayer = Fi, t.tileLayer = ae, t.GridLayer = ki, t.gridLayer = se, t.SVG = Zi, t.svg = le, t.Renderer = Bi, t.Canvas = Gi, t.canvas = ue, t.Path = vi, t.CircleMarker = Li, t.circleMarker = Ht, t.Circle = xi, t.circle = Yt, t.Polyline = bi, t.polyline = Wt, t.Polygon = Ei, t.polygon = Xt, t.Rectangle = Vi, t.rectangle = ce, t.Map = zn, t.map = Pt
                }(e)
            }()
        });
    t(function(t, e) {
        ! function(t, n) {
            ! function(t) {
                var e = L.MarkerClusterGroup = L.FeatureGroup.extend({
                    options: {
                        maxClusterRadius: 80,
                        iconCreateFunction: null,
                        clusterPane: L.Marker.prototype.options.pane,
                        spiderfyOnMaxZoom: !0,
                        showCoverageOnHover: !0,
                        zoomToBoundsOnClick: !0,
                        singleMarkerMode: !1,
                        disableClusteringAtZoom: null,
                        removeOutsideVisibleBounds: !0,
                        animate: !0,
                        animateAddingMarkers: !1,
                        spiderfyDistanceMultiplier: 1,
                        spiderLegPolylineOptions: {
                            weight: 1.5,
                            color: "#222",
                            opacity: .5
                        },
                        chunkedLoading: !1,
                        chunkInterval: 200,
                        chunkDelay: 50,
                        chunkProgress: null,
                        polygonOptions: {}
                    },
                    initialize: function(t) {
                        L.Util.setOptions(this, t), this.options.iconCreateFunction || (this.options.iconCreateFunction = this._defaultIconCreateFunction), this._featureGroup = L.featureGroup(), this._featureGroup.addEventParent(this), this._nonPointGroup = L.featureGroup(), this._nonPointGroup.addEventParent(this), this._inZoomAnimation = 0, this._needsClustering = [], this._needsRemoving = [], this._currentShownBounds = null, this._queue = [], this._childMarkerEventHandlers = {
                            dragstart: this._childMarkerDragStart,
                            move: this._childMarkerMoved,
                            dragend: this._childMarkerDragEnd
                        };
                        var e = L.DomUtil.TRANSITION && this.options.animate;
                        L.extend(this, e ? this._withAnimation : this._noAnimation), this._markerCluster = e ? L.MarkerCluster : L.MarkerClusterNonAnimated
                    },
                    addLayer: function(t) {
                        if (t instanceof L.LayerGroup) return this.addLayers([t]);
                        if (!t.getLatLng) return this._nonPointGroup.addLayer(t), this.fire("layeradd", {
                            layer: t
                        }), this;
                        if (!this._map) return this._needsClustering.push(t), this.fire("layeradd", {
                            layer: t
                        }), this;
                        if (this.hasLayer(t)) return this;
                        this._unspiderfy && this._unspiderfy(), this._addLayer(t, this._maxZoom), this.fire("layeradd", {
                            layer: t
                        }), this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons();
                        var e = t,
                            n = this._zoom;
                        if (t.__parent)
                            for (; e.__parent._zoom >= n;) e = e.__parent;
                        return this._currentShownBounds.contains(e.getLatLng()) && (this.options.animateAddingMarkers ? this._animationAddLayer(t, e) : this._animationAddLayerNonAnimated(t, e)), this
                    },
                    removeLayer: function(t) {
                        return t instanceof L.LayerGroup ? this.removeLayers([t]) : t.getLatLng ? this._map ? t.__parent ? (this._unspiderfy && (this._unspiderfy(), this._unspiderfyLayer(t)), this._removeLayer(t, !0), this.fire("layerremove", {
                            layer: t
                        }), this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), t.off(this._childMarkerEventHandlers, this), this._featureGroup.hasLayer(t) && (this._featureGroup.removeLayer(t), t.clusterShow && t.clusterShow()), this) : this : (!this._arraySplice(this._needsClustering, t) && this.hasLayer(t) && this._needsRemoving.push({
                            layer: t,
                            latlng: t._latlng
                        }), this.fire("layerremove", {
                            layer: t
                        }), this) : (this._nonPointGroup.removeLayer(t), this.fire("layerremove", {
                            layer: t
                        }), this)
                    },
                    addLayers: function(t, e) {
                        if (!L.Util.isArray(t)) return this.addLayer(t);
                        var n, i = this._featureGroup,
                            o = this._nonPointGroup,
                            r = this.options.chunkedLoading,
                            s = this.options.chunkInterval,
                            a = this.options.chunkProgress,
                            h = t.length,
                            u = 0,
                            l = !0;
                        if (this._map) {
                            var c = (new Date).getTime(),
                                p = L.bind(function() {
                                    for (var f = (new Date).getTime(); u < h; u++) {
                                        if (r && u % 200 == 0) {
                                            if ((new Date).getTime() - f > s) break
                                        }
                                        if ((n = t[u]) instanceof L.LayerGroup) l && (t = t.slice(), l = !1), this._extractNonGroupLayers(n, t), h = t.length;
                                        else if (n.getLatLng) {
                                            if (!this.hasLayer(n) && (this._addLayer(n, this._maxZoom), e || this.fire("layeradd", {
                                                layer: n
                                            }), n.__parent && 2 === n.__parent.getChildCount())) {
                                                var d = n.__parent.getAllChildMarkers(),
                                                    _ = d[0] === n ? d[1] : d[0];
                                                i.removeLayer(_)
                                            }
                                        } else o.addLayer(n), e || this.fire("layeradd", {
                                            layer: n
                                        })
                                    }
                                    a && a(u, h, (new Date).getTime() - c), u === h ? (this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds)) : setTimeout(p, this.options.chunkDelay)
                                }, this);
                            p()
                        } else
                            for (var f = this._needsClustering; u < h; u++) n = t[u], n instanceof L.LayerGroup ? (l && (t = t.slice(), l = !1), this._extractNonGroupLayers(n, t), h = t.length) : n.getLatLng ? this.hasLayer(n) || f.push(n) : o.addLayer(n);
                        return this
                    },
                    removeLayers: function(t) {
                        var e, n, i = t.length,
                            o = this._featureGroup,
                            r = this._nonPointGroup,
                            s = !0;
                        if (!this._map) {
                            for (e = 0; e < i; e++) n = t[e], n instanceof L.LayerGroup ? (s && (t = t.slice(), s = !1), this._extractNonGroupLayers(n, t), i = t.length) : (this._arraySplice(this._needsClustering, n), r.removeLayer(n), this.hasLayer(n) && this._needsRemoving.push({
                                layer: n,
                                latlng: n._latlng
                            }), this.fire("layerremove", {
                                layer: n
                            }));
                            return this
                        }
                        if (this._unspiderfy) {
                            this._unspiderfy();
                            var a = t.slice(),
                                h = i;
                            for (e = 0; e < h; e++) n = a[e], n instanceof L.LayerGroup ? (this._extractNonGroupLayers(n, a), h = a.length) : this._unspiderfyLayer(n)
                        }
                        for (e = 0; e < i; e++) n = t[e], n instanceof L.LayerGroup ? (s && (t = t.slice(), s = !1), this._extractNonGroupLayers(n, t), i = t.length) : n.__parent ? (this._removeLayer(n, !0, !0), this.fire("layerremove", {
                            layer: n
                        }), o.hasLayer(n) && (o.removeLayer(n), n.clusterShow && n.clusterShow())) : (r.removeLayer(n), this.fire("layerremove", {
                            layer: n
                        }));
                        return this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds), this
                    },
                    clearLayers: function() {
                        return this._map || (this._needsClustering = [], delete this._gridClusters, delete this._gridUnclustered), this._noanimationUnspiderfy && this._noanimationUnspiderfy(), this._featureGroup.clearLayers(), this._nonPointGroup.clearLayers(), this.eachLayer(function(t) {
                            t.off(this._childMarkerEventHandlers, this), delete t.__parent
                        }, this), this._map && this._generateInitialClusters(), this
                    },
                    getBounds: function() {
                        var t = new L.LatLngBounds;
                        this._topClusterLevel && t.extend(this._topClusterLevel._bounds);
                        for (var e = this._needsClustering.length - 1; e >= 0; e--) t.extend(this._needsClustering[e].getLatLng());
                        return t.extend(this._nonPointGroup.getBounds()), t
                    },
                    eachLayer: function(t, e) {
                        var n, i, o, r = this._needsClustering.slice(),
                            s = this._needsRemoving;
                        for (this._topClusterLevel && this._topClusterLevel.getAllChildMarkers(r), i = r.length - 1; i >= 0; i--) {
                            for (n = !0, o = s.length - 1; o >= 0; o--)
                                if (s[o].layer === r[i]) {
                                    n = !1;
                                    break
                                }
                            n && t.call(e, r[i])
                        }
                        this._nonPointGroup.eachLayer(t, e)
                    },
                    getLayers: function() {
                        var t = [];
                        return this.eachLayer(function(e) {
                            t.push(e)
                        }), t
                    },
                    getLayer: function(t) {
                        var e = null;
                        return t = parseInt(t, 10), this.eachLayer(function(n) {
                            L.stamp(n) === t && (e = n)
                        }), e
                    },
                    hasLayer: function(t) {
                        if (!t) return !1;
                        var e, n = this._needsClustering;
                        for (e = n.length - 1; e >= 0; e--)
                            if (n[e] === t) return !0;
                        for (n = this._needsRemoving, e = n.length - 1; e >= 0; e--)
                            if (n[e].layer === t) return !1;
                        return !(!t.__parent || t.__parent._group !== this) || this._nonPointGroup.hasLayer(t)
                    },
                    zoomToShowLayer: function(t, e) {
                        "function" != typeof e && (e = function() {});
                        var n = function n() {
                            !t._icon && !t.__parent._icon || this._inZoomAnimation || (this._map.off("moveend", n, this), this.off("animationend", n, this), t._icon ? e() : t.__parent._icon && (this.once("spiderfied", e, this), t.__parent.spiderfy()))
                        };
                        t._icon && this._map.getBounds().contains(t.getLatLng()) ? e() : t.__parent._zoom < Math.round(this._map._zoom) ? (this._map.on("moveend", n, this), this._map.panTo(t.getLatLng())) : (this._map.on("moveend", n, this), this.on("animationend", n, this), t.__parent.zoomToBounds())
                    },
                    onAdd: function(t) {
                        this._map = t;
                        var e, n, i;
                        if (!isFinite(this._map.getMaxZoom())) throw "Map has no maxZoom specified";
                        for (this._featureGroup.addTo(t), this._nonPointGroup.addTo(t), this._gridClusters || this._generateInitialClusters(), this._maxLat = t.options.crs.projection.MAX_LATITUDE, e = 0, n = this._needsRemoving.length; e < n; e++) i = this._needsRemoving[e], i.newlatlng = i.layer._latlng, i.layer._latlng = i.latlng;
                        for (e = 0, n = this._needsRemoving.length; e < n; e++) i = this._needsRemoving[e], this._removeLayer(i.layer, !0), i.layer._latlng = i.newlatlng;
                        this._needsRemoving = [], this._zoom = Math.round(this._map._zoom), this._currentShownBounds = this._getExpandedVisibleBounds(), this._map.on("zoomend", this._zoomEnd, this), this._map.on("moveend", this._moveEnd, this), this._spiderfierOnAdd && this._spiderfierOnAdd(), this._bindEvents(), n = this._needsClustering, this._needsClustering = [], this.addLayers(n, !0)
                    },
                    onRemove: function(t) {
                        t.off("zoomend", this._zoomEnd, this), t.off("moveend", this._moveEnd, this), this._unbindEvents(), this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", ""), this._spiderfierOnRemove && this._spiderfierOnRemove(), delete this._maxLat, this._hideCoverage(), this._featureGroup.remove(), this._nonPointGroup.remove(), this._featureGroup.clearLayers(), this._map = null
                    },
                    getVisibleParent: function(t) {
                        for (var e = t; e && !e._icon;) e = e.__parent;
                        return e || null
                    },
                    _arraySplice: function(t, e) {
                        for (var n = t.length - 1; n >= 0; n--)
                            if (t[n] === e) return t.splice(n, 1), !0
                    },
                    _removeFromGridUnclustered: function(t, e) {
                        for (var n = this._map, i = this._gridUnclustered, o = Math.floor(this._map.getMinZoom()); e >= o && i[e].removeObject(t, n.project(t.getLatLng(), e)); e--);
                    },
                    _childMarkerDragStart: function(t) {
                        t.target.__dragStart = t.target._latlng
                    },
                    _childMarkerMoved: function(t) {
                        if (!this._ignoreMove && !t.target.__dragStart) {
                            var e = t.target._popup && t.target._popup.isOpen();
                            this._moveChild(t.target, t.oldLatLng, t.latlng), e && t.target.openPopup()
                        }
                    },
                    _moveChild: function(t, e, n) {
                        t._latlng = e, this.removeLayer(t), t._latlng = n, this.addLayer(t)
                    },
                    _childMarkerDragEnd: function(t) {
                        t.target.__dragStart && this._moveChild(t.target, t.target.__dragStart, t.target._latlng), delete t.target.__dragStart
                    },
                    _removeLayer: function(t, e, n) {
                        var i = this._gridClusters,
                            o = this._gridUnclustered,
                            r = this._featureGroup,
                            s = this._map,
                            a = Math.floor(this._map.getMinZoom());
                        e && this._removeFromGridUnclustered(t, this._maxZoom);
                        var h, u = t.__parent,
                            l = u._markers;
                        for (this._arraySplice(l, t); u && (u._childCount--, u._boundsNeedUpdate = !0, !(u._zoom < a));) e && u._childCount <= 1 ? (h = u._markers[0] === t ? u._markers[1] : u._markers[0], i[u._zoom].removeObject(u, s.project(u._cLatLng, u._zoom)), o[u._zoom].addObject(h, s.project(h.getLatLng(), u._zoom)), this._arraySplice(u.__parent._childClusters, u), u.__parent._markers.push(h), h.__parent = u.__parent, u._icon && (r.removeLayer(u), n || r.addLayer(h))) : u._iconNeedsUpdate = !0, u = u.__parent;
                        delete t.__parent
                    },
                    _isOrIsParent: function(t, e) {
                        for (; e;) {
                            if (t === e) return !0;
                            e = e.parentNode
                        }
                        return !1
                    },
                    fire: function(t, e, n) {
                        if (e && e.layer instanceof L.MarkerCluster) {
                            if (e.originalEvent && this._isOrIsParent(e.layer._icon, e.originalEvent.relatedTarget)) return;
                            t = "cluster" + t
                        }
                        L.FeatureGroup.prototype.fire.call(this, t, e, n)
                    },
                    listens: function(t, e) {
                        return L.FeatureGroup.prototype.listens.call(this, t, e) || L.FeatureGroup.prototype.listens.call(this, "cluster" + t, e)
                    },
                    _defaultIconCreateFunction: function(t) {
                        var e = t.getChildCount(),
                            n = " marker-cluster-";
                        return n += e < 10 ? "small" : e < 100 ? "medium" : "large", new L.DivIcon({
                            html: "<div><span>" + e + "</span></div>",
                            className: "marker-cluster" + n,
                            iconSize: new L.Point(40, 40)
                        })
                    },
                    _bindEvents: function() {
                        var t = this._map,
                            e = this.options.spiderfyOnMaxZoom,
                            n = this.options.showCoverageOnHover,
                            i = this.options.zoomToBoundsOnClick;
                        (e || i) && this.on("clusterclick", this._zoomOrSpiderfy, this), n && (this.on("clustermouseover", this._showCoverage, this), this.on("clustermouseout", this._hideCoverage, this), t.on("zoomend", this._hideCoverage, this))
                    },
                    _zoomOrSpiderfy: function(t) {
                        for (var e = t.layer, n = e; 1 === n._childClusters.length;) n = n._childClusters[0];
                        n._zoom === this._maxZoom && n._childCount === e._childCount && this.options.spiderfyOnMaxZoom ? e.spiderfy() : this.options.zoomToBoundsOnClick && e.zoomToBounds(), t.originalEvent && 13 === t.originalEvent.keyCode && this._map._container.focus()
                    },
                    _showCoverage: function(t) {
                        var e = this._map;
                        this._inZoomAnimation || (this._shownPolygon && e.removeLayer(this._shownPolygon), t.layer.getChildCount() > 2 && t.layer !== this._spiderfied && (this._shownPolygon = new L.Polygon(t.layer.getConvexHull(), this.options.polygonOptions), e.addLayer(this._shownPolygon)))
                    },
                    _hideCoverage: function() {
                        this._shownPolygon && (this._map.removeLayer(this._shownPolygon), this._shownPolygon = null)
                    },
                    _unbindEvents: function() {
                        var t = this.options.spiderfyOnMaxZoom,
                            e = this.options.showCoverageOnHover,
                            n = this.options.zoomToBoundsOnClick,
                            i = this._map;
                        (t || n) && this.off("clusterclick", this._zoomOrSpiderfy, this), e && (this.off("clustermouseover", this._showCoverage, this), this.off("clustermouseout", this._hideCoverage, this), i.off("zoomend", this._hideCoverage, this))
                    },
                    _zoomEnd: function() {
                        this._map && (this._mergeSplitClusters(), this._zoom = Math.round(this._map._zoom), this._currentShownBounds = this._getExpandedVisibleBounds())
                    },
                    _moveEnd: function() {
                        if (!this._inZoomAnimation) {
                            var t = this._getExpandedVisibleBounds();
                            this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, t), this._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), t), this._currentShownBounds = t
                        }
                    },
                    _generateInitialClusters: function() {
                        var t = Math.ceil(this._map.getMaxZoom()),
                            e = Math.floor(this._map.getMinZoom()),
                            n = this.options.maxClusterRadius,
                            i = n;
                        "function" != typeof n && (i = function() {
                            return n
                        }), null !== this.options.disableClusteringAtZoom && (t = this.options.disableClusteringAtZoom - 1), this._maxZoom = t, this._gridClusters = {}, this._gridUnclustered = {};
                        for (var o = t; o >= e; o--) this._gridClusters[o] = new L.DistanceGrid(i(o)), this._gridUnclustered[o] = new L.DistanceGrid(i(o));
                        this._topClusterLevel = new this._markerCluster(this, e - 1)
                    },
                    _addLayer: function(t, e) {
                        var n, i, o = this._gridClusters,
                            r = this._gridUnclustered,
                            s = Math.floor(this._map.getMinZoom());
                        for (this.options.singleMarkerMode && this._overrideMarkerIcon(t), t.on(this._childMarkerEventHandlers, this); e >= s; e--) {
                            n = this._map.project(t.getLatLng(), e);
                            var a = o[e].getNearObject(n);
                            if (a) return a._addChild(t), void(t.__parent = a);
                            if (a = r[e].getNearObject(n)) {
                                var h = a.__parent;
                                h && this._removeLayer(a, !1);
                                var u = new this._markerCluster(this, e, a, t);
                                o[e].addObject(u, this._map.project(u._cLatLng, e)), a.__parent = u, t.__parent = u;
                                var l = u;
                                for (i = e - 1; i > h._zoom; i--) l = new this._markerCluster(this, i, l), o[i].addObject(l, this._map.project(a.getLatLng(), i));
                                return h._addChild(l), void this._removeFromGridUnclustered(a, e)
                            }
                            r[e].addObject(t, n)
                        }
                        this._topClusterLevel._addChild(t), t.__parent = this._topClusterLevel
                    },
                    _refreshClustersIcons: function() {
                        this._featureGroup.eachLayer(function(t) {
                            t instanceof L.MarkerCluster && t._iconNeedsUpdate && t._updateIcon()
                        })
                    },
                    _enqueue: function(t) {
                        this._queue.push(t), this._queueTimeout || (this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300))
                    },
                    _processQueue: function() {
                        for (var t = 0; t < this._queue.length; t++) this._queue[t].call(this);
                        this._queue.length = 0, clearTimeout(this._queueTimeout), this._queueTimeout = null
                    },
                    _mergeSplitClusters: function() {
                        var t = Math.round(this._map._zoom);
                        this._processQueue(), this._zoom < t && this._currentShownBounds.intersects(this._getExpandedVisibleBounds()) ? (this._animationStart(), this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds()), this._animationZoomIn(this._zoom, t)) : this._zoom > t ? (this._animationStart(), this._animationZoomOut(this._zoom, t)) : this._moveEnd()
                    },
                    _getExpandedVisibleBounds: function() {
                        return this.options.removeOutsideVisibleBounds ? L.Browser.mobile ? this._checkBoundsMaxLat(this._map.getBounds()) : this._checkBoundsMaxLat(this._map.getBounds().pad(1)) : this._mapBoundsInfinite
                    },
                    _checkBoundsMaxLat: function(t) {
                        var e = this._maxLat;
                        return void 0 !== e && (t.getNorth() >= e && (t._northEast.lat = 1 / 0), t.getSouth() <= -e && (t._southWest.lat = -1 / 0)), t
                    },
                    _animationAddLayerNonAnimated: function(t, e) {
                        if (e === t) this._featureGroup.addLayer(t);
                        else if (2 === e._childCount) {
                            e._addToMap();
                            var n = e.getAllChildMarkers();
                            this._featureGroup.removeLayer(n[0]), this._featureGroup.removeLayer(n[1])
                        } else e._updateIcon()
                    },
                    _extractNonGroupLayers: function(t, e) {
                        var n, i = t.getLayers(),
                            o = 0;
                        for (e = e || []; o < i.length; o++) n = i[o], n instanceof L.LayerGroup ? this._extractNonGroupLayers(n, e) : e.push(n);
                        return e
                    },
                    _overrideMarkerIcon: function(t) {
                        return t.options.icon = this.options.iconCreateFunction({
                            getChildCount: function() {
                                return 1
                            },
                            getAllChildMarkers: function() {
                                return [t]
                            }
                        })
                    }
                });
                L.MarkerClusterGroup.include({
                    _mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-1 / 0, -1 / 0), new L.LatLng(1 / 0, 1 / 0))
                }), L.MarkerClusterGroup.include({
                    _noAnimation: {
                        _animationStart: function() {},
                        _animationZoomIn: function(t, e) {
                            this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), t), this._topClusterLevel._recursivelyAddChildrenToMap(null, e, this._getExpandedVisibleBounds()), this.fire("animationend")
                        },
                        _animationZoomOut: function(t, e) {
                            this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), t), this._topClusterLevel._recursivelyAddChildrenToMap(null, e, this._getExpandedVisibleBounds()), this.fire("animationend")
                        },
                        _animationAddLayer: function(t, e) {
                            this._animationAddLayerNonAnimated(t, e)
                        }
                    },
                    _withAnimation: {
                        _animationStart: function() {
                            this._map._mapPane.className += " leaflet-cluster-anim", this._inZoomAnimation++
                        },
                        _animationZoomIn: function(t, e) {
                            var n, i = this._getExpandedVisibleBounds(),
                                o = this._featureGroup,
                                r = Math.floor(this._map.getMinZoom());
                            this._ignoreMove = !0, this._topClusterLevel._recursively(i, t, r, function(r) {
                                var s, a = r._latlng,
                                    h = r._markers;
                                for (i.contains(a) || (a = null), r._isSingleParent() && t + 1 === e ? (o.removeLayer(r), r._recursivelyAddChildrenToMap(null, e, i)) : (r.clusterHide(), r._recursivelyAddChildrenToMap(a, e, i)), n = h.length - 1; n >= 0; n--) s = h[n], i.contains(s._latlng) || o.removeLayer(s)
                            }), this._forceLayout(), this._topClusterLevel._recursivelyBecomeVisible(i, e), o.eachLayer(function(t) {
                                t instanceof L.MarkerCluster || !t._icon || t.clusterShow()
                            }), this._topClusterLevel._recursively(i, t, e, function(t) {
                                t._recursivelyRestoreChildPositions(e)
                            }), this._ignoreMove = !1, this._enqueue(function() {
                                this._topClusterLevel._recursively(i, t, r, function(t) {
                                    o.removeLayer(t), t.clusterShow()
                                }), this._animationEnd()
                            })
                        },
                        _animationZoomOut: function(t, e) {
                            this._animationZoomOutSingle(this._topClusterLevel, t - 1, e), this._topClusterLevel._recursivelyAddChildrenToMap(null, e, this._getExpandedVisibleBounds()), this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), t, this._getExpandedVisibleBounds())
                        },
                        _animationAddLayer: function(t, e) {
                            var n = this,
                                i = this._featureGroup;
                            i.addLayer(t), e !== t && (e._childCount > 2 ? (e._updateIcon(), this._forceLayout(), this._animationStart(), t._setPos(this._map.latLngToLayerPoint(e.getLatLng())), t.clusterHide(), this._enqueue(function() {
                                i.removeLayer(t), t.clusterShow(), n._animationEnd()
                            })) : (this._forceLayout(), n._animationStart(), n._animationZoomOutSingle(e, this._map.getMaxZoom(), this._zoom)))
                        }
                    },
                    _animationZoomOutSingle: function(t, e, n) {
                        var i = this._getExpandedVisibleBounds(),
                            o = Math.floor(this._map.getMinZoom());
                        t._recursivelyAnimateChildrenInAndAddSelfToMap(i, o, e + 1, n);
                        var r = this;
                        this._forceLayout(), t._recursivelyBecomeVisible(i, n), this._enqueue(function() {
                            if (1 === t._childCount) {
                                var s = t._markers[0];
                                this._ignoreMove = !0, s.setLatLng(s.getLatLng()), this._ignoreMove = !1, s.clusterShow && s.clusterShow()
                            } else t._recursively(i, n, o, function(t) {
                                t._recursivelyRemoveChildrenFromMap(i, o, e + 1)
                            });
                            r._animationEnd()
                        })
                    },
                    _animationEnd: function() {
                        this._map && (this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", "")), this._inZoomAnimation--, this.fire("animationend")
                    },
                    _forceLayout: function() {
                        L.Util.falseFn(document.body.offsetWidth)
                    }
                }), L.markerClusterGroup = function(t) {
                    return new L.MarkerClusterGroup(t)
                };
                var n = L.MarkerCluster = L.Marker.extend({
                    options: L.Icon.prototype.options,
                    initialize: function(t, e, n, i) {
                        L.Marker.prototype.initialize.call(this, n ? n._cLatLng || n.getLatLng() : new L.LatLng(0, 0), {
                                icon: this,
                                pane: t.options.clusterPane
                            }), this._group = t, this._zoom = e, this._markers = [], this._childClusters = [], this._childCount = 0, this._iconNeedsUpdate = !0, this._boundsNeedUpdate = !0, this._bounds = new L.LatLngBounds, n && this._addChild(n),
                            i && this._addChild(i)
                    },
                    getAllChildMarkers: function(t) {
                        t = t || [];
                        for (var e = this._childClusters.length - 1; e >= 0; e--) this._childClusters[e].getAllChildMarkers(t);
                        for (var n = this._markers.length - 1; n >= 0; n--) t.push(this._markers[n]);
                        return t
                    },
                    getChildCount: function() {
                        return this._childCount
                    },
                    zoomToBounds: function(t) {
                        for (var e, n = this._childClusters.slice(), i = this._group._map, o = i.getBoundsZoom(this._bounds), r = this._zoom + 1, s = i.getZoom(); n.length > 0 && o > r;) {
                            r++;
                            var a = [];
                            for (e = 0; e < n.length; e++) a = a.concat(n[e]._childClusters);
                            n = a
                        }
                        o > r ? this._group._map.setView(this._latlng, r) : o <= s ? this._group._map.setView(this._latlng, s + 1) : this._group._map.fitBounds(this._bounds, t)
                    },
                    getBounds: function() {
                        var t = new L.LatLngBounds;
                        return t.extend(this._bounds), t
                    },
                    _updateIcon: function() {
                        this._iconNeedsUpdate = !0, this._icon && this.setIcon(this)
                    },
                    createIcon: function() {
                        return this._iconNeedsUpdate && (this._iconObj = this._group.options.iconCreateFunction(this), this._iconNeedsUpdate = !1), this._iconObj.createIcon()
                    },
                    createShadow: function() {
                        return this._iconObj.createShadow()
                    },
                    _addChild: function(t, e) {
                        this._iconNeedsUpdate = !0, this._boundsNeedUpdate = !0, this._setClusterCenter(t), t instanceof L.MarkerCluster ? (e || (this._childClusters.push(t), t.__parent = this), this._childCount += t._childCount) : (e || this._markers.push(t), this._childCount++), this.__parent && this.__parent._addChild(t, !0)
                    },
                    _setClusterCenter: function(t) {
                        this._cLatLng || (this._cLatLng = t._cLatLng || t._latlng)
                    },
                    _resetBounds: function() {
                        var t = this._bounds;
                        t._southWest && (t._southWest.lat = 1 / 0, t._southWest.lng = 1 / 0), t._northEast && (t._northEast.lat = -1 / 0, t._northEast.lng = -1 / 0)
                    },
                    _recalculateBounds: function() {
                        var t, e, n, i, o = this._markers,
                            r = this._childClusters,
                            s = 0,
                            a = 0,
                            h = this._childCount;
                        if (0 !== h) {
                            for (this._resetBounds(), t = 0; t < o.length; t++) n = o[t]._latlng, this._bounds.extend(n), s += n.lat, a += n.lng;
                            for (t = 0; t < r.length; t++) e = r[t], e._boundsNeedUpdate && e._recalculateBounds(), this._bounds.extend(e._bounds), n = e._wLatLng, i = e._childCount, s += n.lat * i, a += n.lng * i;
                            this._latlng = this._wLatLng = new L.LatLng(s / h, a / h), this._boundsNeedUpdate = !1
                        }
                    },
                    _addToMap: function(t) {
                        t && (this._backupLatlng = this._latlng, this.setLatLng(t)), this._group._featureGroup.addLayer(this)
                    },
                    _recursivelyAnimateChildrenIn: function(t, e, n) {
                        this._recursively(t, this._group._map.getMinZoom(), n - 1, function(t) {
                            var n, i, o = t._markers;
                            for (n = o.length - 1; n >= 0; n--) i = o[n], i._icon && (i._setPos(e), i.clusterHide())
                        }, function(t) {
                            var n, i, o = t._childClusters;
                            for (n = o.length - 1; n >= 0; n--) i = o[n], i._icon && (i._setPos(e), i.clusterHide())
                        })
                    },
                    _recursivelyAnimateChildrenInAndAddSelfToMap: function(t, e, n, i) {
                        this._recursively(t, i, e, function(o) {
                            o._recursivelyAnimateChildrenIn(t, o._group._map.latLngToLayerPoint(o.getLatLng()).round(), n), o._isSingleParent() && n - 1 === i ? (o.clusterShow(), o._recursivelyRemoveChildrenFromMap(t, e, n)) : o.clusterHide(), o._addToMap()
                        })
                    },
                    _recursivelyBecomeVisible: function(t, e) {
                        this._recursively(t, this._group._map.getMinZoom(), e, null, function(t) {
                            t.clusterShow()
                        })
                    },
                    _recursivelyAddChildrenToMap: function(t, e, n) {
                        this._recursively(n, this._group._map.getMinZoom() - 1, e, function(i) {
                            if (e !== i._zoom)
                                for (var o = i._markers.length - 1; o >= 0; o--) {
                                    var r = i._markers[o];
                                    n.contains(r._latlng) && (t && (r._backupLatlng = r.getLatLng(), r.setLatLng(t), r.clusterHide && r.clusterHide()), i._group._featureGroup.addLayer(r))
                                }
                        }, function(e) {
                            e._addToMap(t)
                        })
                    },
                    _recursivelyRestoreChildPositions: function(t) {
                        for (var e = this._markers.length - 1; e >= 0; e--) {
                            var n = this._markers[e];
                            n._backupLatlng && (n.setLatLng(n._backupLatlng), delete n._backupLatlng)
                        }
                        if (t - 1 === this._zoom)
                            for (var i = this._childClusters.length - 1; i >= 0; i--) this._childClusters[i]._restorePosition();
                        else
                            for (var o = this._childClusters.length - 1; o >= 0; o--) this._childClusters[o]._recursivelyRestoreChildPositions(t)
                    },
                    _restorePosition: function() {
                        this._backupLatlng && (this.setLatLng(this._backupLatlng), delete this._backupLatlng)
                    },
                    _recursivelyRemoveChildrenFromMap: function(t, e, n, i) {
                        var o, r;
                        this._recursively(t, e - 1, n - 1, function(t) {
                            for (r = t._markers.length - 1; r >= 0; r--) o = t._markers[r], i && i.contains(o._latlng) || (t._group._featureGroup.removeLayer(o), o.clusterShow && o.clusterShow())
                        }, function(t) {
                            for (r = t._childClusters.length - 1; r >= 0; r--) o = t._childClusters[r], i && i.contains(o._latlng) || (t._group._featureGroup.removeLayer(o), o.clusterShow && o.clusterShow())
                        })
                    },
                    _recursively: function(t, e, n, i, o) {
                        var r, s, a = this._childClusters,
                            h = this._zoom;
                        if (e <= h && (i && i(this), o && h === n && o(this)), h < e || h < n)
                            for (r = a.length - 1; r >= 0; r--) s = a[r], t.intersects(s._bounds) && s._recursively(t, e, n, i, o)
                    },
                    _isSingleParent: function() {
                        return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount
                    }
                });
                L.Marker.include({
                        clusterHide: function() {
                            return this.options.opacityWhenUnclustered = this.options.opacity || 1, this.setOpacity(0)
                        },
                        clusterShow: function() {
                            var t = this.setOpacity(this.options.opacity || this.options.opacityWhenUnclustered);
                            return delete this.options.opacityWhenUnclustered, t
                        }
                    }), L.DistanceGrid = function(t) {
                        this._cellSize = t, this._sqCellSize = t * t, this._grid = {}, this._objectPoint = {}
                    }, L.DistanceGrid.prototype = {
                        addObject: function(t, e) {
                            var n = this._getCoord(e.x),
                                i = this._getCoord(e.y),
                                o = this._grid,
                                r = o[i] = o[i] || {},
                                s = r[n] = r[n] || [],
                                a = L.Util.stamp(t);
                            this._objectPoint[a] = e, s.push(t)
                        },
                        updateObject: function(t, e) {
                            this.removeObject(t), this.addObject(t, e)
                        },
                        removeObject: function(t, e) {
                            var n, i, o = this._getCoord(e.x),
                                r = this._getCoord(e.y),
                                s = this._grid,
                                a = s[r] = s[r] || {},
                                h = a[o] = a[o] || [];
                            for (delete this._objectPoint[L.Util.stamp(t)], n = 0, i = h.length; n < i; n++)
                                if (h[n] === t) return h.splice(n, 1), 1 === i && delete a[o], !0
                        },
                        eachObject: function(t, e) {
                            var n, i, o, r, s, a, h = this._grid;
                            for (n in h) {
                                s = h[n];
                                for (i in s)
                                    for (a = s[i], o = 0, r = a.length; o < r; o++) t.call(e, a[o]) && (o--, r--)
                            }
                        },
                        getNearObject: function(t) {
                            var e, n, i, o, r, s, a, h, u = this._getCoord(t.x),
                                l = this._getCoord(t.y),
                                c = this._objectPoint,
                                p = this._sqCellSize,
                                f = null;
                            for (e = l - 1; e <= l + 1; e++)
                                if (o = this._grid[e])
                                    for (n = u - 1; n <= u + 1; n++)
                                        if (r = o[n])
                                            for (i = 0, s = r.length; i < s; i++) a = r[i], ((h = this._sqDist(c[L.Util.stamp(a)], t)) < p || h <= p && null === f) && (p = h, f = a);
                            return f
                        },
                        _getCoord: function(t) {
                            var e = Math.floor(t / this._cellSize);
                            return isFinite(e) ? e : t
                        },
                        _sqDist: function(t, e) {
                            var n = e.x - t.x,
                                i = e.y - t.y;
                            return n * n + i * i
                        }
                    },
                    function() {
                        L.QuickHull = {
                            getDistant: function(t, e) {
                                var n = e[1].lat - e[0].lat;
                                return (e[0].lng - e[1].lng) * (t.lat - e[0].lat) + n * (t.lng - e[0].lng)
                            },
                            findMostDistantPointFromBaseLine: function(t, e) {
                                var n, i, o, r = 0,
                                    s = null,
                                    a = [];
                                for (n = e.length - 1; n >= 0; n--) i = e[n], (o = this.getDistant(i, t)) > 0 && (a.push(i), o > r && (r = o, s = i));
                                return {
                                    maxPoint: s,
                                    newPoints: a
                                }
                            },
                            buildConvexHull: function(t, e) {
                                var n = [],
                                    i = this.findMostDistantPointFromBaseLine(t, e);
                                return i.maxPoint ? (n = n.concat(this.buildConvexHull([t[0], i.maxPoint], i.newPoints)), n = n.concat(this.buildConvexHull([i.maxPoint, t[1]], i.newPoints))) : [t[0]]
                            },
                            getConvexHull: function(t) {
                                var e, n = !1,
                                    i = !1,
                                    o = !1,
                                    r = !1,
                                    s = null,
                                    a = null,
                                    h = null,
                                    u = null,
                                    l = null,
                                    c = null;
                                for (e = t.length - 1; e >= 0; e--) {
                                    var p = t[e];
                                    (!1 === n || p.lat > n) && (s = p, n = p.lat), (!1 === i || p.lat < i) && (a = p, i = p.lat), (!1 === o || p.lng > o) && (h = p, o = p.lng), (!1 === r || p.lng < r) && (u = p, r = p.lng)
                                }
                                return i !== n ? (c = a, l = s) : (c = u, l = h), [].concat(this.buildConvexHull([c, l], t), this.buildConvexHull([l, c], t))
                            }
                        }
                    }(), L.MarkerCluster.include({
                        getConvexHull: function() {
                            var t, e, n = this.getAllChildMarkers(),
                                i = [];
                            for (e = n.length - 1; e >= 0; e--) t = n[e].getLatLng(), i.push(t);
                            return L.QuickHull.getConvexHull(i)
                        }
                    }), L.MarkerCluster.include({
                        _2PI: 2 * Math.PI,
                        _circleFootSeparation: 25,
                        _circleStartAngle: 0,
                        _spiralFootSeparation: 28,
                        _spiralLengthStart: 11,
                        _spiralLengthFactor: 5,
                        _circleSpiralSwitchover: 9,
                        spiderfy: function() {
                            if (this._group._spiderfied !== this && !this._group._inZoomAnimation) {
                                var t, e = this.getAllChildMarkers(),
                                    n = this._group,
                                    i = n._map,
                                    o = i.latLngToLayerPoint(this._latlng);
                                this._group._unspiderfy(), this._group._spiderfied = this, e.length >= this._circleSpiralSwitchover ? t = this._generatePointsSpiral(e.length, o) : (o.y += 10, t = this._generatePointsCircle(e.length, o)), this._animationSpiderfy(e, t)
                            }
                        },
                        unspiderfy: function(t) {
                            this._group._inZoomAnimation || (this._animationUnspiderfy(t), this._group._spiderfied = null)
                        },
                        _generatePointsCircle: function(t, e) {
                            var n, i, o = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + t),
                                r = o / this._2PI,
                                s = this._2PI / t,
                                a = [];
                            for (r = Math.max(r, 35), a.length = t, n = 0; n < t; n++) i = this._circleStartAngle + n * s, a[n] = new L.Point(e.x + r * Math.cos(i), e.y + r * Math.sin(i))._round();
                            return a
                        },
                        _generatePointsSpiral: function(t, e) {
                            var n, i = this._group.options.spiderfyDistanceMultiplier,
                                o = i * this._spiralLengthStart,
                                r = i * this._spiralFootSeparation,
                                s = i * this._spiralLengthFactor * this._2PI,
                                a = 0,
                                h = [];
                            for (h.length = t, n = t; n >= 0; n--) n < t && (h[n] = new L.Point(e.x + o * Math.cos(a), e.y + o * Math.sin(a))._round()), a += r / o + 5e-4 * n, o += s / a;
                            return h
                        },
                        _noanimationUnspiderfy: function() {
                            var t, e, n = this._group,
                                i = n._map,
                                o = n._featureGroup,
                                r = this.getAllChildMarkers();
                            for (n._ignoreMove = !0, this.setOpacity(1), e = r.length - 1; e >= 0; e--) t = r[e], o.removeLayer(t), t._preSpiderfyLatlng && (t.setLatLng(t._preSpiderfyLatlng), delete t._preSpiderfyLatlng), t.setZIndexOffset && t.setZIndexOffset(0), t._spiderLeg && (i.removeLayer(t._spiderLeg), delete t._spiderLeg);
                            n.fire("unspiderfied", {
                                cluster: this,
                                markers: r
                            }), n._ignoreMove = !1, n._spiderfied = null
                        }
                    }), L.MarkerClusterNonAnimated = L.MarkerCluster.extend({
                        _animationSpiderfy: function(t, e) {
                            var n, i, o, r, s = this._group,
                                a = s._map,
                                h = s._featureGroup,
                                u = this._group.options.spiderLegPolylineOptions;
                            for (s._ignoreMove = !0, n = 0; n < t.length; n++) r = a.layerPointToLatLng(e[n]), i = t[n], o = new L.Polyline([this._latlng, r], u), a.addLayer(o), i._spiderLeg = o, i._preSpiderfyLatlng = i._latlng, i.setLatLng(r), i.setZIndexOffset && i.setZIndexOffset(1e6), h.addLayer(i);
                            this.setOpacity(.3), s._ignoreMove = !1, s.fire("spiderfied", {
                                cluster: this,
                                markers: t
                            })
                        },
                        _animationUnspiderfy: function() {
                            this._noanimationUnspiderfy()
                        }
                    }), L.MarkerCluster.include({
                        _animationSpiderfy: function(t, e) {
                            var n, i, o, r, s, a, h = this,
                                u = this._group,
                                l = u._map,
                                c = u._featureGroup,
                                p = this._latlng,
                                f = l.latLngToLayerPoint(p),
                                d = L.Path.SVG,
                                _ = L.extend({}, this._group.options.spiderLegPolylineOptions),
                                g = _.opacity;
                            for (void 0 === g && (g = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity), d ? (_.opacity = 0, _.className = (_.className || "") + " leaflet-cluster-spider-leg") : _.opacity = g, u._ignoreMove = !0, n = 0; n < t.length; n++) i = t[n], a = l.layerPointToLatLng(e[n]), o = new L.Polyline([p, a], _), l.addLayer(o), i._spiderLeg = o, d && (r = o._path, s = r.getTotalLength() + .1, r.style.strokeDasharray = s, r.style.strokeDashoffset = s), i.setZIndexOffset && i.setZIndexOffset(1e6), i.clusterHide && i.clusterHide(), c.addLayer(i), i._setPos && i._setPos(f);
                            for (u._forceLayout(), u._animationStart(), n = t.length - 1; n >= 0; n--) a = l.layerPointToLatLng(e[n]), i = t[n], i._preSpiderfyLatlng = i._latlng, i.setLatLng(a), i.clusterShow && i.clusterShow(), d && (o = i._spiderLeg, r = o._path, r.style.strokeDashoffset = 0, o.setStyle({
                                opacity: g
                            }));
                            this.setOpacity(.3), u._ignoreMove = !1, setTimeout(function() {
                                u._animationEnd(), u.fire("spiderfied", {
                                    cluster: h,
                                    markers: t
                                })
                            }, 200)
                        },
                        _animationUnspiderfy: function(t) {
                            var e, n, i, o, r, s, a = this,
                                h = this._group,
                                u = h._map,
                                l = h._featureGroup,
                                c = t ? u._latLngToNewLayerPoint(this._latlng, t.zoom, t.center) : u.latLngToLayerPoint(this._latlng),
                                p = this.getAllChildMarkers(),
                                f = L.Path.SVG;
                            for (h._ignoreMove = !0, h._animationStart(), this.setOpacity(1), n = p.length - 1; n >= 0; n--) e = p[n], e._preSpiderfyLatlng && (e.closePopup(), e.setLatLng(e._preSpiderfyLatlng), delete e._preSpiderfyLatlng, s = !0, e._setPos && (e._setPos(c), s = !1), e.clusterHide && (e.clusterHide(), s = !1), s && l.removeLayer(e), f && (i = e._spiderLeg, o = i._path, r = o.getTotalLength() + .1, o.style.strokeDashoffset = r, i.setStyle({
                                opacity: 0
                            })));
                            h._ignoreMove = !1, setTimeout(function() {
                                var t = 0;
                                for (n = p.length - 1; n >= 0; n--) e = p[n], e._spiderLeg && t++;
                                for (n = p.length - 1; n >= 0; n--) e = p[n], e._spiderLeg && (e.clusterShow && e.clusterShow(), e.setZIndexOffset && e.setZIndexOffset(0), t > 1 && l.removeLayer(e), u.removeLayer(e._spiderLeg), delete e._spiderLeg);
                                h._animationEnd(), h.fire("unspiderfied", {
                                    cluster: a,
                                    markers: p
                                })
                            }, 200)
                        }
                    }), L.MarkerClusterGroup.include({
                        _spiderfied: null,
                        unspiderfy: function() {
                            this._unspiderfy.apply(this, arguments)
                        },
                        _spiderfierOnAdd: function() {
                            this._map.on("click", this._unspiderfyWrapper, this), this._map.options.zoomAnimation && this._map.on("zoomstart", this._unspiderfyZoomStart, this), this._map.on("zoomend", this._noanimationUnspiderfy, this), L.Browser.touch || this._map.getRenderer(this)
                        },
                        _spiderfierOnRemove: function() {
                            this._map.off("click", this._unspiderfyWrapper, this), this._map.off("zoomstart", this._unspiderfyZoomStart, this), this._map.off("zoomanim", this._unspiderfyZoomAnim, this), this._map.off("zoomend", this._noanimationUnspiderfy, this), this._noanimationUnspiderfy()
                        },
                        _unspiderfyZoomStart: function() {
                            this._map && this._map.on("zoomanim", this._unspiderfyZoomAnim, this)
                        },
                        _unspiderfyZoomAnim: function(t) {
                            L.DomUtil.hasClass(this._map._mapPane, "leaflet-touching") || (this._map.off("zoomanim", this._unspiderfyZoomAnim, this), this._unspiderfy(t))
                        },
                        _unspiderfyWrapper: function() {
                            this._unspiderfy()
                        },
                        _unspiderfy: function(t) {
                            this._spiderfied && this._spiderfied.unspiderfy(t)
                        },
                        _noanimationUnspiderfy: function() {
                            this._spiderfied && this._spiderfied._noanimationUnspiderfy()
                        },
                        _unspiderfyLayer: function(t) {
                            t._spiderLeg && (this._featureGroup.removeLayer(t), t.clusterShow && t.clusterShow(), t.setZIndexOffset && t.setZIndexOffset(0), this._map.removeLayer(t._spiderLeg), delete t._spiderLeg)
                        }
                    }), L.MarkerClusterGroup.include({
                        refreshClusters: function(t) {
                            return t ? t instanceof L.MarkerClusterGroup ? t = t._topClusterLevel.getAllChildMarkers() : t instanceof L.LayerGroup ? t = t._layers : t instanceof L.MarkerCluster ? t = t.getAllChildMarkers() : t instanceof L.Marker && (t = [t]) : t = this._topClusterLevel.getAllChildMarkers(), this._flagParentsIconsNeedUpdate(t), this._refreshClustersIcons(), this.options.singleMarkerMode && this._refreshSingleMarkerModeMarkers(t), this
                        },
                        _flagParentsIconsNeedUpdate: function(t) {
                            var e, n;
                            for (e in t)
                                for (n = t[e].__parent; n;) n._iconNeedsUpdate = !0, n = n.__parent
                        },
                        _refreshSingleMarkerModeMarkers: function(t) {
                            var e, n;
                            for (e in t) n = t[e], this.hasLayer(n) && n.setIcon(this._overrideMarkerIcon(n))
                        }
                    }), L.Marker.include({
                        refreshIconOptions: function(t, e) {
                            var n = this.options.icon;
                            return L.setOptions(n, t), this.setIcon(n), e && this.__parent && this.__parent._group.refreshClusters(this), this
                        }
                    }), t.MarkerClusterGroup = e, t.MarkerCluster = n
            }(e)
        }()
    });
    ! function(t) {
        function e(i) {
            if (n[i]) return n[i].exports;
            var o = n[i] = {
                i: i,
                l: !1,
                exports: {}
            };
            return t[i].call(o.exports, o, o.exports, e), o.l = !0, o.exports
        }
        var n = {};
        e.m = t, e.c = n, e.d = function(t, n, i) {
            e.o(t, n) || Object.defineProperty(t, n, {
                configurable: !1,
                enumerable: !0,
                get: i
            })
        }, e.n = function(t) {
            var n = t && t.__esModule ? function() {
                return t.default
            } : function() {
                return t
            };
            return e.d(n, "a", n), n
        }, e.o = function(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e)
        }, e.p = "", e(e.s = 7)
    }([
        function(t, e, n) {
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.default = void 0;
            var i, o = (i = n(3)) && i.__esModule ? i : {
                    default: i
                },
                r = L.Class.extend({
                    includes: [o.default],
                    options: {
                        snappable: !0,
                        snapDistance: 20,
                        cursorMarker: !0,
                        finishOnDoubleClick: !1,
                        finishOn: null,
                        allowSelfIntersection: !0,
                        templineStyle: {},
                        hintlineStyle: {
                            dashArray: "5,5"
                        },
                        markerStyle: {
                            draggable: !0
                        }
                    },
                    initialize: function(t) {
                        var e = this;
                        this._map = t, this.shapes = ["Marker", "Line", "Poly", "Rectangle", "Circle", "Cut"], this.shapes.forEach(function(t) {
                            e[t] = new L.PM.Draw[t](e._map)
                        })
                    },
                    setPathOptions: function(t) {
                        this.options.pathOptions = t
                    },
                    getShapes: function() {
                        return this.shapes
                    },
                    enable: function(t, e) {
                        if (!t) throw new Error("Error: Please pass a shape as a parameter. Possible shapes are: ".concat(this.getShapes().join(",")));
                        this.disable(), this[t].enable(e)
                    },
                    disable: function() {
                        var t = this;
                        this.shapes.forEach(function(e) {
                            t[e].disable()
                        })
                    },
                    addControls: function() {
                        var t = this;
                        this.shapes.forEach(function(e) {
                            t[e].addButton()
                        })
                    }
                });
            e.default = r
        },
        function(t, e, n) {
            function i(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.default = void 0;
            var o = i(n(3)),
                r = i(n(27)),
                s = L.Class.extend({
                    includes: [r.default, o.default],
                    options: {
                        snappable: !0,
                        snapDistance: 20,
                        allowSelfIntersection: !0,
                        draggable: !0
                    },
                    isPolygon: function() {
                        return this._layer instanceof L.Polygon
                    }
                });
            e.default = s
        },
        function(t, e, i) {
            function o(t, e, n) {
                if (!h(n = n || {})) throw new Error("options is invalid");
                var i = n.bbox,
                    o = n.id;
                if (void 0 === t) throw new Error("geometry is required");
                if (e && e.constructor !== Object) throw new Error("properties must be an Object");
                i && u(i), o && l(o);
                var r = {
                    type: "Feature"
                };
                return o && (r.id = o), i && (r.bbox = i), r.properties = e || {}, r.geometry = t, r
            }

            function r(t, e, n) {
                if (!t) throw new Error("coordinates is required");
                if (!Array.isArray(t)) throw new Error("coordinates must be an Array");
                if (t.length < 2) throw new Error("coordinates must be at least 2 numbers long");
                if (!a(t[0]) || !a(t[1])) throw new Error("coordinates must contain numbers");
                return o({
                    type: "Point",
                    coordinates: t
                }, e, n)
            }

            function s(t, e, n) {
                if (!t) throw new Error("coordinates is required");
                if (t.length < 2) throw new Error("coordinates must be an array of two or more positions");
                if (!a(t[0][1]) || !a(t[0][1])) throw new Error("coordinates must contain numbers");
                return o({
                    type: "LineString",
                    coordinates: t
                }, e, n)
            }

            function a(t) {
                return !isNaN(t) && null !== t && !Array.isArray(t)
            }

            function h(t) {
                return !!t && t.constructor === Object
            }

            function u(t) {
                if (!t) throw new Error("bbox is required");
                if (!Array.isArray(t)) throw new Error("bbox must be an Array");
                if (4 !== t.length && 6 !== t.length) throw new Error("bbox must be an Array of 4 or 6 numbers");
                t.forEach(function(t) {
                    if (!a(t)) throw new Error("bbox must only contain numbers")
                })
            }

            function l(t) {
                if (!t) throw new Error("id is required");
                if (-1 === ["string", "number"].indexOf(void 0 === t ? "undefined" : n(t))) throw new Error("id must be a number or a string")
            }
            i.d(e, "a", function() {
                return o
            }), i.d(e, "e", function() {
                return r
            }), i.d(e, "d", function() {
                return s
            }), i.d(e, "b", function() {
                return a
            }), i.d(e, "c", function() {
                return h
            })
        },
        function(t, e, n) {
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.default = void 0;
            var i = {
                _initSnappableMarkers: function() {
                    this.options.snapDistance = this.options.snapDistance || 30, this.isPolygon() ? this._markers.map(this._assignEvents, this) : this._assignEvents(this._markers), this._layer.off("pm:dragstart", this._unsnap, this), this._layer.on("pm:dragstart", this._unsnap, this)
                },
                _assignEvents: function(t) {
                    var e = this;
                    t.forEach(function(t) {
                        t.off("drag", e._handleSnapping, e), t.on("drag", e._handleSnapping, e), t.off("dragend", e._cleanupSnapping, e), t.on("dragend", e._cleanupSnapping, e)
                    })
                },
                _unsnap: function() {
                    delete this._snapLatLng
                },
                _cleanupSnapping: function() {
                    delete this._snapList, this._map.off("pm:remove", this._handleSnapLayerRemoval, this), this.debugIndicatorLines && this.debugIndicatorLines.forEach(function(t) {
                        t.remove()
                    })
                },
                _handleSnapLayerRemoval: function(t) {
                    var e = t.layer,
                        n = this._snapList.findIndex(function(t) {
                            return t._leaflet_id === e._leaflet_id
                        });
                    this._snapList.splice(n, 1)
                },
                _handleSnapping: function(t) {
                    var e = this;
                    if (t.originalEvent.altKey) return !1;
                    if (void 0 === this._snapList && this._createSnapList(t), this._snapList.length <= 0) return !1;
                    var n, i = t.target,
                        o = this._calcClosestLayer(i.getLatLng(), this._snapList);
                    n = o.layer instanceof L.Marker || o.layer instanceof L.CircleMarker ? o.latlng : this._checkPrioritiySnapping(o);
                    var r = this.options.snapDistance,
                        s = {
                            marker: i,
                            snapLatLng: n,
                            segment: o.segment,
                            layer: this._layer,
                            layerInteractedWith: o.layer
                        };
                    if (o.distance < r) {
                        i.setLatLng(n), i._snapped = !0;
                        var a = this._snapLatLng || {},
                            h = n || {};
                        a.lat === h.lat && a.lng === h.lng || (e._snapLatLng = n, i.fire("pm:snap", s), e._layer.fire("pm:snap", s))
                    } else this._snapLatLng && (this._unsnap(s), i._snapped = !1, s.marker.fire("pm:unsnap", s), this._layer.fire("pm:unsnap", s));
                    return !0
                },
                _checkPrioritiySnapping: function(t) {
                    var e, n = this._map,
                        i = t.segment[0],
                        o = t.segment[1],
                        r = t.latlng,
                        s = this._getDistance(n, i, r),
                        a = this._getDistance(n, o, r),
                        h = s < a ? i : o;
                    return e = (s < a ? s : a) < this.options.snapDistance ? h : r, Object.assign({}, e)
                },
                _createSnapList: function() {
                    var t = this,
                        e = [],
                        n = [],
                        i = this._map;
                    i.eachLayer(function(o) {
                        if (o instanceof L.Polyline || o instanceof L.Marker || o instanceof L.CircleMarker) {
                            e.push(o), i.off("pm:remove", t._handleSnapLayerRemoval, t), i.on("pm:remove", t._handleSnapLayerRemoval, t);
                            var r = L.polyline([], {
                                color: "red",
                                pmIgnore: !0
                            });
                            n.push(r)
                        }
                    }), e = (e = (e = e.filter(function(e) {
                        return t._layer !== e
                    })).filter(function(t) {
                        return t._latlng || t._latlngs && t._latlngs.length > 0
                    })).filter(function(t) {
                        return !t._pmTempLayer
                    }), this._otherSnapLayers ? this._snapList = e.concat(this._otherSnapLayers) : this._snapList = e, this.debugIndicatorLines = n
                },
                _calcClosestLayer: function(t, e) {
                    var n = this,
                        i = {};
                    return e.forEach(function(e, o) {
                        var r = n._calcLayerDistances(t, e);
                        n.debugIndicatorLines[o].setLatLngs([t, r.latlng]), (void 0 === i.distance || r.distance < i.distance) && ((i = r).layer = e)
                    }), i
                },
                _calcLayerDistances: function(t, e) {
                    var n, i, o, r = this,
                        s = this._map,
                        a = e instanceof L.Polygon,
                        h = !(e instanceof L.Polygon) && e instanceof L.Polyline,
                        u = e instanceof L.Marker || e instanceof L.CircleMarker,
                        l = t;
                    if (a) n = e.getLatLngs()[0];
                    else if (h) n = e.getLatLngs();
                    else if (u) return n = e.getLatLng(), {
                        latlng: Object.assign({}, n),
                        distance: this._getDistance(s, n, l)
                    };
                    n.forEach(function(t, e) {
                        var h, u = t;
                        h = a ? e + 1 === n.length ? 0 : e + 1 : e + 1 === n.length ? void 0 : e + 1;
                        var c = n[h];
                        if (c) {
                            var p = r._getDistanceToSegment(s, l, u, c);
                            (void 0 === o || p < o) && (o = p, i = [u, c])
                        }
                        return !0
                    });
                    var c = this._getClosestPointOnSegment(s, t, i[0], i[1]);
                    return {
                        latlng: Object.assign({}, c),
                        segment: i,
                        distance: o
                    }
                },
                _getClosestPointOnSegment: function(t, e, n, i) {
                    var o = t.getMaxZoom();
                    o === 1 / 0 && (o = t.getZoom());
                    var r = t.project(e, o),
                        s = t.project(n, o),
                        a = t.project(i, o),
                        h = L.LineUtil.closestPointOnSegment(r, s, a);
                    return t.unproject(h, o)
                },
                _getDistanceToSegment: function(t, e, n, i) {
                    var o = t.latLngToLayerPoint(e),
                        r = t.latLngToLayerPoint(n),
                        s = t.latLngToLayerPoint(i);
                    return L.LineUtil.pointToSegmentDistance(o, r, s)
                },
                _getDistance: function(t, e, n) {
                    return t.latLngToLayerPoint(e).distanceTo(t.latLngToLayerPoint(n))
                }
            };
            e.default = i
        },
        function(t, e, n) {
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = n(2);
            e.default = function(t) {
                var e, n, o = {
                    type: "FeatureCollection",
                    features: []
                };
                if ("LineString" === (n = "Feature" === t.type ? t.geometry : t).type) e = [n.coordinates];
                else if ("MultiLineString" === n.type) e = n.coordinates;
                else if ("MultiPolygon" === n.type) e = [].concat.apply([], n.coordinates);
                else {
                    if ("Polygon" !== n.type) throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry");
                    e = n.coordinates
                }
                return e.forEach(function(t) {
                    e.forEach(function(e) {
                        for (var n = 0; n < t.length - 1; n++)
                            for (var r = n; r < e.length - 1; r++) {
                                if (t === e) {
                                    if (1 === Math.abs(n - r)) continue;
                                    if (0 === n && r === t.length - 2 && t[n][0] === t[t.length - 1][0] && t[n][1] === t[t.length - 1][1]) continue
                                }
                                var s = (a = t[n][0], h = t[n][1], u = t[n + 1][0], l = t[n + 1][1], c = e[r][0], p = e[r][1], f = e[r + 1][0], d = e[r + 1][1], _ = void 0, g = void 0, m = void 0, y = void 0, v = void 0, v = {
                                    x: null,
                                    y: null,
                                    onLine1: !1,
                                    onLine2: !1
                                }, 0 == (_ = (d - p) * (u - a) - (f - c) * (l - h)) ? null !== v.x && null !== v.y && v : (y = (u - a) * (g = h - p) - (l - h) * (m = a - c), g = ((f - c) * g - (d - p) * m) / _, m = y / _, v.x = a + g * (u - a), v.y = h + g * (l - h), g >= 0 && g <= 1 && (v.onLine1 = !0), m >= 0 && m <= 1 && (v.onLine2 = !0), !(!v.onLine1 || !v.onLine2) && [v.x, v.y]));
                                s && o.features.push(Object(i.e)([s[0], s[1]]))
                            }
                        var a, h, u, l, c, p, f, d, _, g, m, y, v
                    })
                }), o
            }
        },
        function(t, e, i) {
            function o(t, e, n) {
                void 0 === n && (n = {});
                var i = {
                    type: "Feature"
                };
                return (0 === n.id || n.id) && (i.id = n.id), n.bbox && (i.bbox = n.bbox), i.properties = e || {}, i.geometry = t, i
            }

            function r(t, e, n) {
                return void 0 === n && (n = {}), o({
                    type: "Point",
                    coordinates: t
                }, e, n)
            }

            function s(t, e, n) {
                void 0 === n && (n = {});
                for (var i = 0, r = t; i < r.length; i++) {
                    var s = r[i];
                    if (s.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
                    for (var a = 0; a < s[s.length - 1].length; a++)
                        if (s[s.length - 1][a] !== s[0][a]) throw new Error("First and last Position are not equivalent.")
                }
                return o({
                    type: "Polygon",
                    coordinates: t
                }, e, n)
            }

            function a(t, e, n) {
                if (void 0 === n && (n = {}), t.length < 2) throw new Error("coordinates must be an array of two or more positions");
                return o({
                    type: "LineString",
                    coordinates: t
                }, e, n)
            }

            function h(t, e) {
                void 0 === e && (e = {});
                var n = {
                    type: "FeatureCollection"
                };
                return e.id && (n.id = e.id), e.bbox && (n.bbox = e.bbox), n.features = t, n
            }

            function u(t, e, n) {
                return void 0 === n && (n = {}), o({
                    type: "MultiLineString",
                    coordinates: t
                }, e, n)
            }

            function l(t, e, n) {
                return void 0 === n && (n = {}), o({
                    type: "MultiPoint",
                    coordinates: t
                }, e, n)
            }

            function c(t, e, n) {
                return void 0 === n && (n = {}), o({
                    type: "MultiPolygon",
                    coordinates: t
                }, e, n)
            }

            function p(t, n) {
                void 0 === n && (n = "kilometers");
                var i = e.factors[n];
                if (!i) throw new Error(n + " units is invalid");
                return t * i
            }

            function f(t, n) {
                void 0 === n && (n = "kilometers");
                var i = e.factors[n];
                if (!i) throw new Error(n + " units is invalid");
                return t / i
            }

            function d(t) {
                return t % (2 * Math.PI) * 180 / Math.PI
            }

            function _(t) {
                return !isNaN(t) && null !== t && !Array.isArray(t)
            }
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.earthRadius = 6371008.8, e.factors = {
                centimeters: 100 * e.earthRadius,
                centimetres: 100 * e.earthRadius,
                degrees: e.earthRadius / 111325,
                feet: 3.28084 * e.earthRadius,
                inches: 39.37 * e.earthRadius,
                kilometers: e.earthRadius / 1e3,
                kilometres: e.earthRadius / 1e3,
                meters: e.earthRadius,
                metres: e.earthRadius,
                miles: e.earthRadius / 1609.344,
                millimeters: 1e3 * e.earthRadius,
                millimetres: 1e3 * e.earthRadius,
                nauticalmiles: e.earthRadius / 1852,
                radians: 1,
                yards: e.earthRadius / 1.0936
            }, e.unitsFactors = {
                centimeters: 100,
                centimetres: 100,
                degrees: 1 / 111325,
                feet: 3.28084,
                inches: 39.37,
                kilometers: .001,
                kilometres: .001,
                meters: 1,
                metres: 1,
                miles: 1 / 1609.344,
                millimeters: 1e3,
                millimetres: 1e3,
                nauticalmiles: 1 / 1852,
                radians: 1 / e.earthRadius,
                yards: 1 / 1.0936
            }, e.areaFactors = {
                acres: 247105e-9,
                centimeters: 1e4,
                centimetres: 1e4,
                feet: 10.763910417,
                inches: 1550.003100006,
                kilometers: 1e-6,
                kilometres: 1e-6,
                meters: 1,
                metres: 1,
                miles: 3.86e-7,
                millimeters: 1e6,
                millimetres: 1e6,
                yards: 1.195990046
            }, e.feature = o, e.geometry = function(t, e, n) {
                switch (void 0 === n && (n = {}), t) {
                    case "Point":
                        return r(e).geometry;
                    case "LineString":
                        return a(e).geometry;
                    case "Polygon":
                        return s(e).geometry;
                    case "MultiPoint":
                        return l(e).geometry;
                    case "MultiLineString":
                        return u(e).geometry;
                    case "MultiPolygon":
                        return c(e).geometry;
                    default:
                        throw new Error(t + " is invalid")
                }
            }, e.point = r, e.points = function(t, e, n) {
                return void 0 === n && (n = {}), h(t.map(function(t) {
                    return r(t, e)
                }), n)
            }, e.polygon = s, e.polygons = function(t, e, n) {
                return void 0 === n && (n = {}), h(t.map(function(t) {
                    return s(t, e)
                }), n)
            }, e.lineString = a, e.lineStrings = function(t, e, n) {
                return void 0 === n && (n = {}), h(t.map(function(t) {
                    return a(t, e)
                }), n)
            }, e.featureCollection = h, e.multiLineString = u, e.multiPoint = l, e.multiPolygon = c, e.geometryCollection = function(t, e, n) {
                return void 0 === n && (n = {}), o({
                    type: "GeometryCollection",
                    geometries: t
                }, e, n)
            }, e.round = function(t, e) {
                if (void 0 === e && (e = 0), e && !(e >= 0)) throw new Error("precision must be a positive number");
                var n = Math.pow(10, e || 0);
                return Math.round(t * n) / n
            }, e.radiansToLength = p, e.lengthToRadians = f, e.lengthToDegrees = function(t, e) {
                return d(f(t, e))
            }, e.bearingToAzimuth = function(t) {
                var e = t % 360;
                return e < 0 && (e += 360), e
            }, e.radiansToDegrees = d, e.degreesToRadians = function(t) {
                return t % 360 * Math.PI / 180
            }, e.convertLength = function(t, e, n) {
                if (void 0 === e && (e = "kilometers"), void 0 === n && (n = "kilometers"), !(t >= 0)) throw new Error("length must be a positive number");
                return p(f(t, e), n)
            }, e.convertArea = function(t, n, i) {
                if (void 0 === n && (n = "meters"), void 0 === i && (i = "kilometers"), !(t >= 0)) throw new Error("area must be a positive number");
                var o = e.areaFactors[n];
                if (!o) throw new Error("invalid original units");
                var r = e.areaFactors[i];
                if (!r) throw new Error("invalid final units");
                return t / o * r
            }, e.isNumber = _, e.isObject = function(t) {
                return !!t && t.constructor === Object
            }, e.validateBBox = function(t) {
                if (!t) throw new Error("bbox is required");
                if (!Array.isArray(t)) throw new Error("bbox must be an Array");
                if (4 !== t.length && 6 !== t.length) throw new Error("bbox must be an Array of 4 or 6 numbers");
                t.forEach(function(t) {
                    if (!_(t)) throw new Error("bbox must only contain numbers")
                })
            }, e.validateId = function(t) {
                if (!t) throw new Error("id is required");
                if (-1 === ["string", "number"].indexOf(void 0 === t ? "undefined" : n(t))) throw new Error("id must be a number or a string")
            }, e.radians2degrees = function() {
                throw new Error("method has been renamed to `radiansToDegrees`")
            }, e.degrees2radians = function() {
                throw new Error("method has been renamed to `degreesToRadians`")
            }, e.distanceToDegrees = function() {
                throw new Error("method has been renamed to `lengthToDegrees`")
            }, e.distanceToRadians = function() {
                throw new Error("method has been renamed to `lengthToRadians`")
            }, e.radiansToDistance = function() {
                throw new Error("method has been renamed to `radiansToLength`")
            }, e.bearingToAngle = function() {
                throw new Error("method has been renamed to `bearingToAzimuth`")
            }, e.convertDistance = function() {
                throw new Error("method has been renamed to `convertLength`")
            }
        },
        function(t, e, n) {
            function i(t, e) {
                var n, i, o, r, s, a, h, u, l, c, p = 0,
                    f = "FeatureCollection" === t.type,
                    d = "Feature" === t.type,
                    _ = f ? t.features.length : 1;
                for (n = 0; n < _; n++) {
                    for (a = f ? t.features[n].geometry : d ? t.geometry : t, u = f ? t.features[n].properties : d ? t.properties : {}, l = f ? t.features[n].bbox : d ? t.bbox : void 0, c = f ? t.features[n].id : d ? t.id : void 0, s = (h = !!a && "GeometryCollection" === a.type) ? a.geometries.length : 1, o = 0; o < s; o++)
                        if (null !== (r = h ? a.geometries[o] : a)) switch (r.type) {
                            case "Point":
                            case "LineString":
                            case "MultiPoint":
                            case "Polygon":
                            case "MultiLineString":
                            case "MultiPolygon":
                                if (!1 === e(r, p, u, l, c)) return !1;
                                break;
                            case "GeometryCollection":
                                for (i = 0; i < r.geometries.length; i++)
                                    if (!1 === e(r.geometries[i], p, u, l, c)) return !1;
                                break;
                            default:
                                throw new Error("Unknown Geometry Type")
                        } else if (!1 === e(null, p, u, l, c)) return !1;
                    p++
                }
            }

            function o(t, e, n) {
                var o = n;
                return i(t, function(t, i, r, s, a) {
                    o = 0 === i && void 0 === n ? t : e(o, t, i, r, s, a)
                }), o
            }

            function r(t, e) {
                i(t, function(t, n, i, o, r) {
                    var a, h = null === t ? null : t.type;
                    switch (h) {
                        case null:
                        case "Point":
                        case "LineString":
                        case "Polygon":
                            return !1 !== e(Object(s.a)(t, i, {
                                bbox: o,
                                id: r
                            }), n, 0) && void 0
                    }
                    switch (h) {
                        case "MultiPoint":
                            a = "Point";
                            break;
                        case "MultiLineString":
                            a = "LineString";
                            break;
                        case "MultiPolygon":
                            a = "Polygon"
                    }
                    for (var u = 0; u < t.coordinates.length; u++) {
                        var l = {
                            type: a,
                            coordinates: t.coordinates[u]
                        };
                        if (!1 === e(Object(s.a)(l, i), n, u)) return !1
                    }
                })
            }
            n.d(e, "b", function() {
                return o
            }), n.d(e, "a", function() {
                return r
            });
            var s = n(2)
        },
        function(t, e, n) {
            t.exports = n(8)
        },
        function(t, e, n) {
            function i(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }
            n(9);
            var o = n(10),
                r = i(n(11)),
                s = i(n(12)),
                a = i(n(0));
            n(14), n(15), n(16), n(17), n(18), n(19);
            var h = i(n(1));
            n(28), n(29), n(30), n(31), n(32), n(33), n(34), n(35), L.PM = L.PM || {
                Map: r.default,
                Toolbar: s.default,
                Draw: a.default,
                Edit: h.default,
                version: o.version,
                initialize: function() {
                    this.addInitHooks()
                },
                addInitHooks: function() {
                    L.Map.addInitHook(function() {
                        this.options.pmIgnore || (this.pm = new L.PM.Map(this))
                    }), L.LayerGroup.addInitHook(function() {
                        this.pm = new L.PM.Edit.LayerGroup(this)
                    }), L.Marker.addInitHook(function() {
                        this.options.pmIgnore || (this.pm = new L.PM.Edit.Marker(this))
                    }), L.Polyline.addInitHook(function() {
                        this.options.pmIgnore || (this.pm = new L.PM.Edit.Line(this))
                    }), L.Polygon.addInitHook(function() {
                        this.options.pmIgnore || (this.pm = new L.PM.Edit.Poly(this))
                    }), L.Rectangle.addInitHook(function() {
                        this.options.pmIgnore || (this.pm = new L.PM.Edit.Rectangle(this))
                    }), L.Circle.addInitHook(function() {
                        this.options.pmIgnore || (this.pm = new L.PM.Edit.Circle(this))
                    })
                }
            }, L.PM.initialize()
        },
        function(t, e, n) {
            Array.prototype.findIndex = Array.prototype.findIndex || function(t) {
                if (null === this) throw new TypeError("Array.prototype.findIndex called on null or undefined");
                if ("function" != typeof t) throw new TypeError("callback must be a function");
                for (var e = Object(this), n = e.length >>> 0, i = arguments[1], o = 0; o < n; o++)
                    if (t.call(i, e[o], o, e)) return o;
                return -1
            }, Array.prototype.find = Array.prototype.find || function(t) {
                if (null === this) throw new TypeError("Array.prototype.find called on null or undefined");
                if ("function" != typeof t) throw new TypeError("callback must be a function");
                for (var e = Object(this), n = e.length >>> 0, i = arguments[1], o = 0; o < n; o++) {
                    var r = e[o];
                    if (t.call(i, r, o, e)) return r
                }
            }, "function" != typeof Object.assign && (Object.assign = function(t) {
                if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                t = Object(t);
                for (var e = 1; e < arguments.length; e++) {
                    var n = arguments[e];
                    if (null != n)
                        for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
                }
                return t
            }), [Element.prototype, CharacterData.prototype, DocumentType.prototype].forEach(function(t) {
                t.hasOwnProperty("remove") || Object.defineProperty(t, "remove", {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    value: function() {
                        this.parentNode.removeChild(this)
                    }
                })
            })
        },
        function(t, e) {
            t.exports = {
                name: "leaflet.pm",
                version: "0.24.0",
                description: "A Leaflet Plugin For Editing Geometry Layers in Leaflet 1.0",
                keywords: ["leaflet", "polygon management", "geometry editing", "map data", "map overlay", "polygon", "geojson", "leaflet-draw", "data-field-geojson", "ui-leaflet-draw"],
                files: ["dist"],
                main: "dist/leaflet.pm.min.js",
                dependencies: {
                    "@turf/difference": "^5.1.5",
                    "@turf/intersect": "^6.1.2",
                    "@turf/kinks": "^5.1.5"
                },
                devDependencies: {
                    "@babel/core": "^7.0.0-beta.40",
                    "@babel/preset-env": "^7.0.0-beta.40",
                    "babel-loader": "^8.0.0-beta.0",
                    "css-loader": "^0.28.0",
                    eslint: "^4.18.2",
                    "eslint-config-airbnb-base": "^12.1.0",
                    "eslint-plugin-import": "^2.9.0",
                    "extract-text-webpack-plugin": "^3.0.2",
                    "file-loader": "^0.11.1",
                    leaflet: "^1.3.1",
                    "style-loader": "^0.19.0",
                    tape: "^4.9.0",
                    "tape-run": "^3.0.4",
                    "uglifyjs-webpack-plugin": "^1.1.0",
                    "url-loader": "^0.6.2",
                    webpack: "^3.11.0"
                },
                peerDependencies: {
                    leaflet: "^1.2.0"
                },
                scripts: {
                    start: "npm run dev",
                    dev: "./node_modules/.bin/webpack --config=webpack.dev.js",
                    test: "browserify ./spec/test.spec.js | tape-run",
                    build: "./node_modules/.bin/webpack --config=webpack.build.js",
                    prepare: "npm run build"
                },
                repository: {
                    type: "git",
                    url: "git+https://github.com/codeofsumit/leaflet.pm.git"
                },
                author: {
                    name: "Sumit Kumar",
                    email: "sk@outlook.com",
                    url: "http://twitter.com/TweetsOfSumit"
                },
                license: "MIT",
                bugs: {
                    url: "https://github.com/codeofsumit/leaflet.pm/issues"
                },
                homepage: "https://leafletpm.now.sh"
            }
        },
        function(t, e, n) {
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.default = void 0;
            var i = L.Class.extend({
                initialize: function(t) {
                    var e = this;
                    this.map = t, this.Draw = new L.PM.Draw(t), this.Toolbar = new L.PM.Toolbar(t), this.map.on("layerremove", function(t) {
                        t.layer.pm && !t.layer._pmTempLayer && e.map.fire("pm:remove", t)
                    }), this._globalRemovalMode = !1
                },
                addControls: function(t) {
                    this.Toolbar.addControls(t)
                },
                removeControls: function() {
                    this.Toolbar.removeControls()
                },
                toggleControls: function() {
                    this.Toolbar.toggleControls()
                },
                controlsVisible: function() {
                    return this.Toolbar.isVisible
                },
                enableDraw: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "Poly",
                        e = arguments.length > 1 ? arguments[1] : void 0;
                    this.Draw.enable(t, e)
                },
                disableDraw: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "Poly";
                    this.Draw.disable(t)
                },
                setPathOptions: function(t) {
                    this.Draw.setPathOptions(t)
                },
                removeLayer: function(t) {
                    var e = t.target;
                    e._layers || e.pm && e.pm.dragging() || t.target.remove()
                },
                toggleGlobalRemovalMode: function() {
                    var t = this;
                    this.globalRemovalEnabled() ? (this._globalRemovalMode = !1, this.map.eachLayer(function(e) {
                        e.off("click", t.removeLayer)
                    })) : (this._globalRemovalMode = !0, this.map.eachLayer(function(e) {
                        e.pm && e.on("click", t.removeLayer)
                    })), this.Toolbar.toggleButton("deleteLayer", this._globalRemovalMode)
                },
                globalRemovalEnabled: function() {
                    return this._globalRemovalMode
                },
                globalEditEnabled: function() {
                    return this._globalEditMode
                },
                enableGlobalEditMode: function(t) {
                    var e = [];
                    this.map.eachLayer(function(t) {
                        (t instanceof L.Polyline || t instanceof L.Marker || t instanceof L.Circle) && e.push(t)
                    }), e = (e = e.filter(function(t) {
                        return !!t.pm
                    })).filter(function(t) {
                        return !t._pmTempLayer
                    }), this._globalEditMode = !0, e.forEach(function(e) {
                        e.pm.enable(t)
                    }), this.Toolbar.toggleButton("editPolygon", this._globalEditMode), this._fireEditModeEvent(!0)
                },
                disableGlobalEditMode: function() {
                    var t = [];
                    this.map.eachLayer(function(e) {
                        (e instanceof L.Polyline || e instanceof L.Marker || e instanceof L.Circle) && t.push(e)
                    }), t = (t = t.filter(function(t) {
                        return !!t.pm
                    })).filter(function(t) {
                        return !t._pmTempLayer
                    }), this._globalEditMode = !1, t.forEach(function(t) {
                        t.pm.disable()
                    }), this.Toolbar.toggleButton("editPolygon", this._globalEditMode), this._fireEditModeEvent(!1)
                },
                _fireEditModeEvent: function(t) {
                    this.map.fire("pm:globaleditmodetoggled", {
                        enabled: t,
                        map: this.map
                    })
                },
                toggleGlobalEditMode: function(t) {
                    this.globalEditEnabled() ? this.disableGlobalEditMode() : this.enableGlobalEditMode(t)
                }
            });
            e.default = i
        },
        function(t, e, n) {
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.default = void 0;
            var i, o = (i = n(13)) && i.__esModule ? i : {
                default: i
            };
            L.Control.PMButton = o.default;
            var r = L.Class.extend({
                options: {
                    drawMarker: !0,
                    drawPolygon: !0,
                    drawPolyline: !0,
                    drawCircle: !0,
                    drawRectangle: !0,
                    editMode: !0,
                    cutPolygon: !0,
                    dragPolygon: !1,
                    removalMode: !0,
                    position: "topleft"
                },
                initialize: function(t) {
                    this.map = t, this.buttons = {}, this.isVisible = !1, this.container = L.DomUtil.create("div", "leaflet-pm-toolbar leaflet-bar leaflet-control"), this._defineButtons()
                },
                getButtons: function() {
                    return this.buttons
                },
                addControls: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.options;
                    void 0 !== t.editPolygon && (t.editMode = t.editPolygon), void 0 !== t.deleteLayer && (t.removalMode = t.deleteLayer), L.Util.setOptions(this, t), this._showHideButtons(), this.isVisible = !0
                },
                removeControls: function() {
                    var t = this.getButtons();
                    for (var e in t) t[e].remove();
                    this.isVisible = !1
                },
                toggleControls: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.options;
                    this.isVisible ? this.removeControls() : this.addControls(t)
                },
                _addButton: function(t, e) {
                    return this.buttons[t] = e, this.options[t] = this.options[t] || !1, this.buttons[t]
                },
                triggerClickOnToggledButtons: function(t) {
                    for (var e in this.buttons) this.buttons[e] !== t && this.buttons[e].toggled() && this.buttons[e]._triggerClick()
                },
                toggleButton: function(t, e) {
                    return "editPolygon" === t && (t = "editMode"), "deleteLayer" === t && (t = "removalMode"), this.triggerClickOnToggledButtons(this.buttons[t]), this.buttons[t].toggle(e)
                },
                _defineButtons: function() {
                    var t = this,
                        e = {
                            className: " leaflet-pm-icon-delete",
                            onClick: function() {},
                            afterClick: function() {
                                t.map.pm.toggleGlobalRemovalMode()
                            },
                            doToggle: !0,
                            toggleStatus: !1,
                            disableOtherButtons: !0,
                            position: this.options.position
                        },
                        n = {
                            className: "leaflet-pm-icon-polygon",
                            onClick: function() {},
                            afterClick: function() {
                                t.map.pm.Draw.Poly.toggle()
                            },
                            doToggle: !0,
                            toggleStatus: !1,
                            disableOtherButtons: !0,
                            position: this.options.position
                        },
                        i = {
                            className: "leaflet-pm-icon-cut",
                            onClick: function() {},
                            afterClick: function() {
                                t.map.pm.Draw.Cut.toggle({
                                    snappable: !0,
                                    cursorMarker: !0,
                                    allowSelfIntersection: !1
                                })
                            },
                            doToggle: !0,
                            toggleStatus: !1,
                            disableOtherButtons: !0,
                            position: this.options.position
                        },
                        o = {
                            className: "leaflet-pm-icon-marker",
                            onClick: function() {},
                            afterClick: function() {
                                t.map.pm.Draw.Marker.toggle()
                            },
                            doToggle: !0,
                            toggleStatus: !1,
                            disableOtherButtons: !0,
                            position: this.options.position
                        },
                        r = {
                            className: "leaflet-pm-icon-polyline",
                            onClick: function() {},
                            afterClick: function() {
                                t.map.pm.Draw.Line.toggle()
                            },
                            doToggle: !0,
                            toggleStatus: !1,
                            disableOtherButtons: !0,
                            position: this.options.position
                        },
                        s = {
                            className: "leaflet-pm-icon-circle",
                            onClick: function() {},
                            afterClick: function() {
                                t.map.pm.Draw.Circle.toggle()
                            },
                            doToggle: !0,
                            toggleStatus: !1,
                            disableOtherButtons: !0,
                            position: this.options.position
                        },
                        a = {
                            className: "leaflet-pm-icon-rectangle",
                            onClick: function() {},
                            afterClick: function() {
                                t.map.pm.Draw.Rectangle.toggle()
                            },
                            doToggle: !0,
                            toggleStatus: !1,
                            disableOtherButtons: !0,
                            position: this.options.position
                        },
                        h = {
                            className: "leaflet-pm-icon-edit",
                            onClick: function() {},
                            afterClick: function() {
                                t.map.pm.toggleGlobalEditMode()
                            },
                            doToggle: !0,
                            toggleStatus: !1,
                            disableOtherButtons: !0,
                            position: this.options.position
                        },
                        u = {
                            className: "leaflet-pm-icon-drag",
                            onClick: function() {},
                            afterClick: function() {},
                            doToggle: !0,
                            toggleStatus: !1,
                            disableOtherButtons: !0,
                            position: this.options.position
                        };
                    this._addButton("drawMarker", new L.Control.PMButton(o)), this._addButton("drawPolyline", new L.Control.PMButton(r)), this._addButton("drawRectangle", new L.Control.PMButton(a)), this._addButton("drawPolygon", new L.Control.PMButton(n)), this._addButton("drawCircle", new L.Control.PMButton(s)), this._addButton("cutPolygon", new L.Control.PMButton(i)), this._addButton("editMode", new L.Control.PMButton(h)), this._addButton("dragPolygon", new L.Control.PMButton(u)), this._addButton("removalMode", new L.Control.PMButton(e))
                },
                _showHideButtons: function() {
                    this.removeControls();
                    var t = this.getButtons();
                    for (var e in t) this.options[e] && (t[e].setPosition(this.options.position), t[e].addTo(this.map))
                }
            });
            e.default = r
        },
        function(t, e, n) {
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.default = void 0;
            var i = L.Control.extend({
                options: {
                    position: "topleft"
                },
                initialize: function(t) {
                    this._button = L.Util.setOptions(this, t)
                },
                onAdd: function(t) {
                    return this._map = t, this._container = this._map.pm.Toolbar.container, this.buttonsDomNode = this._makeButton(this._button), this._container.appendChild(this.buttonsDomNode), this._container
                },
                onRemove: function() {
                    return this.buttonsDomNode.remove(), this._container
                },
                getText: function() {
                    return this._button.text
                },
                getIconUrl: function() {
                    return this._button.iconUrl
                },
                destroy: function() {
                    this._button = {}, this._update()
                },
                toggle: function(t) {
                    return this._button.toggleStatus = "boolean" == typeof t ? t : !this._button.toggleStatus, this._applyStyleClasses(), this._button.toggleStatus
                },
                toggled: function() {
                    return this._button.toggleStatus
                },
                onCreate: function() {
                    this.toggle(!1)
                },
                _triggerClick: function(t) {
                    this._button.onClick(t), this._clicked(t), this._button.afterClick(t)
                },
                _makeButton: function(t) {
                    var e = this,
                        n = L.DomUtil.create("a", "leaflet-buttons-control-button", this._container);
                    t.toggleStatus && L.DomUtil.addClass(n, "active");
                    var i = L.DomUtil.create("div", "control-icon", n);
                    return t.iconUrl && i.setAttribute("src", t.iconUrl), t.className && L.DomUtil.addClass(i, t.className), L.DomEvent.addListener(n, "click", function() {
                        e._button.disableOtherButtons && e._map.pm.Toolbar.triggerClickOnToggledButtons(e)
                    }), L.DomEvent.addListener(n, "click", this._triggerClick, this), L.DomEvent.disableClickPropagation(n), n
                },
                _applyStyleClasses: function() {
                    this._container && (this._button.toggleStatus ? L.DomUtil.addClass(this.buttonsDomNode, "active") : L.DomUtil.removeClass(this.buttonsDomNode, "active"))
                },
                _clicked: function() {
                    this._button.doToggle && this.toggle()
                }
            });
            e.default = i
        },
        function(t, e, n) {
            var i, o = (i = n(0)) && i.__esModule ? i : {
                default: i
            };
            o.default.Marker = o.default.extend({
                initialize: function(t) {
                    this._map = t, this._shape = "Marker", this.toolbarButtonName = "drawMarker"
                },
                enable: function(t) {
                    L.Util.setOptions(this, t), this._enabled = !0, this._map.on("click", this._createMarker, this), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !0), this._hintMarker = L.marker([0, 0], this.options.markerStyle), this._hintMarker._pmTempLayer = !0, this._hintMarker.addTo(this._map), this._layer = this._hintMarker, this._map.on("mousemove", this._syncHintMarker, this), this._map.fire("pm:drawstart", {
                        shape: this._shape,
                        workingLayer: this._layer
                    }), this._map.eachLayer(function(t) {
                        t instanceof L.Marker && t.pm && t.pm.enable()
                    })
                },
                disable: function() {
                    this._enabled && (this._map.off("click", this._createMarker, this), this._hintMarker.remove(), this._map.off("mousemove", this._syncHintMarker, this), this._map.eachLayer(function(t) {
                        t instanceof L.Marker && t.pm && !t._pmTempLayer && t.pm.disable()
                    }), this._map.fire("pm:drawend", {
                        shape: this._shape
                    }), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !1), this._enabled = !1)
                },
                enabled: function() {
                    return this._enabled
                },
                toggle: function(t) {
                    this.enabled() ? this.disable() : this.enable(t)
                },
                _createMarker: function(t) {
                    if (t.latlng) {
                        this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);
                        var e = this._hintMarker.getLatLng(),
                            n = new L.Marker(e, this.options.markerStyle);
                        n.addTo(this._map), n.pm.enable(), this.disable(), this._map.fire("pm:create", {
                            shape: this._shape,
                            marker: n,
                            layer: n
                        }), this._cleanupSnapping()
                    }
                },
                _syncHintMarker: function(t) {
                    if (this._hintMarker.setLatLng(t.latlng), this.options.snappable) {
                        var e = t;
                        e.target = this._hintMarker, this._handleSnapping(e)
                    }
                }
            })
        },
        function(t, e, n) {
            function i(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }
            var o = i(n(4)),
                r = i(n(0));
            r.default.Line = r.default.extend({
                initialize: function(t) {
                    this._map = t, this._shape = "Line", this.toolbarButtonName = "drawPolyline", this._doesSelfIntersect = !1
                },
                enable: function(t) {
                    L.Util.setOptions(this, t), this.options.finishOnDoubleClick && !this.options.finishOn && (this.options.finishOn = "dblclick"), this._enabled = !0, this._layerGroup = new L.LayerGroup, this._layerGroup._pmTempLayer = !0, this._layerGroup.addTo(this._map), this._layer = L.polyline([], this.options.templineStyle), this._layer._pmTempLayer = !0, this._layerGroup.addLayer(this._layer), this._hintline = L.polyline([], this.options.hintlineStyle), this._hintline._pmTempLayer = !0, this._layerGroup.addLayer(this._hintline), this._hintMarker = L.marker(this._map.getCenter(), {
                        icon: L.divIcon({
                            className: "marker-icon cursor-marker"
                        })
                    }), this._hintMarker._pmTempLayer = !0, this._layerGroup.addLayer(this._hintMarker), this.options.cursorMarker && L.DomUtil.addClass(this._hintMarker._icon, "visible"), this._map._container.style.cursor = "crosshair", this._map.on("click", this._createVertex, this), this.options.finishOn && this._map.on(this.options.finishOn, this._finishShape, this), "dblclick" === this.options.finishOn && (this.tempMapDoubleClickZoomState = this._map.doubleClickZoom._enabled, this.tempMapDoubleClickZoomState && this._map.doubleClickZoom.disable()), this._map.on("mousemove", this._syncHintMarker, this), this._hintMarker.on("move", this._syncHintLine, this), this._map.fire("pm:drawstart", {
                        shape: this._shape,
                        workingLayer: this._layer
                    }), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !0), this._otherSnapLayers = []
                },
                disable: function() {
                    this._enabled && (this._enabled = !1, this._map._container.style.cursor = "default", this._map.off("click", this._createVertex, this), this._map.off("mousemove", this._syncHintMarker, this), this.options.finishOn && this._map.off(this.options.finishOn, this._finishShape, this), this.tempMapDoubleClickZoomState && this._map.doubleClickZoom.enable(), this._map.removeLayer(this._layerGroup), this._map.fire("pm:drawend", {
                        shape: this._shape
                    }), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !1), this.options.snappable && this._cleanupSnapping())
                },
                enabled: function() {
                    return this._enabled
                },
                toggle: function(t) {
                    this.enabled() ? this.disable() : this.enable(t)
                },
                hasSelfIntersection: function() {
                    return (0, o.default)(this._layer.toGeoJSON()).features.length > 0
                },
                _syncHintLine: function() {
                    var t = this._layer.getLatLngs();
                    if (t.length > 0) {
                        var e = t[t.length - 1];
                        this._hintline.setLatLngs([e, this._hintMarker.getLatLng()])
                    }
                },
                _syncHintMarker: function(t) {
                    if (this._hintMarker.setLatLng(t.latlng), this.options.snappable) {
                        var e = t;
                        e.target = this._hintMarker, this._handleSnapping(e)
                    }
                    this.options.allowSelfIntersection || this._handleSelfIntersection()
                },
                _handleSelfIntersection: function() {
                    var t = L.polyline(this._layer.getLatLngs());
                    t.addLatLng(this._hintMarker.getLatLng());
                    var e = (0, o.default)(t.toGeoJSON());
                    this._doesSelfIntersect = e.features.length > 0, this._doesSelfIntersect ? this._hintline.setStyle({
                        color: "red"
                    }) : this._hintline.setStyle(this.options.hintlineStyle)
                },
                _createVertex: function(t) {
                    if (this.options.allowSelfIntersection || !this._doesSelfIntersect) {
                        this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);
                        var e = this._hintMarker.getLatLng();
                        if (e.equals(this._layer.getLatLngs()[0])) this._finishShape(t);
                        else {
                            var n = 0 === this._layer.getLatLngs().length;
                            this._layer.addLatLng(e);
                            var i = this._createMarker(e, n);
                            this._hintline.setLatLngs([e, e]), this._layer.fire("pm:vertexadded", {
                                shape: this._shape,
                                workingLayer: this._layer,
                                marker: i,
                                latlng: e
                            })
                        }
                    }
                },
                _finishShape: function() {
                    if (this.options.allowSelfIntersection || !this._doesSelfIntersect) {
                        var t = this._layer.getLatLngs(),
                            e = L.polyline(t, this.options.pathOptions).addTo(this._map);
                        this.disable(), this._map.fire("pm:create", {
                            shape: this._shape,
                            layer: e
                        }), this.options.snappable && this._cleanupSnapping()
                    }
                },
                _createMarker: function(t) {
                    var e = new L.Marker(t, {
                        draggable: !1,
                        icon: L.divIcon({
                            className: "marker-icon"
                        })
                    });
                    return e._pmTempLayer = !0, this._layerGroup.addLayer(e), e.on("click", this._finishShape, this), e
                }
            })
        },
        function(t, e, n) {
            var i, o = (i = n(0)) && i.__esModule ? i : {
                default: i
            };
            o.default.Poly = o.default.Line.extend({
                initialize: function(t) {
                    this._map = t, this._shape = "Poly", this.toolbarButtonName = "drawPolygon"
                },
                _finishShape: function(t) {
                    if (this.options.allowSelfIntersection || !this._doesSelfIntersect) {
                        var e = this._layer.getLatLngs();
                        t && "dblclick" === t.type && e.splice(e.length - 1, 1);
                        var n = L.polygon(e, this.options.pathOptions).addTo(this._map);
                        this.disable(), this._map.fire("pm:create", {
                            shape: this._shape,
                            layer: n
                        }), this._cleanupSnapping(), this._otherSnapLayers.splice(this._tempSnapLayerIndex, 1), delete this._tempSnapLayerIndex
                    }
                },
                _createMarker: function(t, e) {
                    var n = new L.Marker(t, {
                        draggable: !1,
                        icon: L.divIcon({
                            className: "marker-icon"
                        })
                    });
                    return n._pmTempLayer = !0, this._layerGroup.addLayer(n), e && (n.on("click", this._finishShape, this), this._tempSnapLayerIndex = this._otherSnapLayers.push(n) - 1, this.options.snappable && this._cleanupSnapping()), n
                }
            })
        },
        function(t, e, n) {
            var i, o = (i = n(0)) && i.__esModule ? i : {
                default: i
            };
            o.default.Rectangle = o.default.extend({
                initialize: function(t) {
                    this._map = t, this._shape = "Rectangle", this.toolbarButtonName = "drawRectangle"
                },
                enable: function(t) {
                    if (L.Util.setOptions(this, t), this._enabled = !0, this._layerGroup = new L.LayerGroup, this._layerGroup._pmTempLayer = !0, this._layerGroup.addTo(this._map), this._layer = L.rectangle([
                        [0, 0],
                        [0, 0]
                    ], this.options.pathOptions), this._layer._pmTempLayer = !0, this._startMarker = L.marker([0, 0], {
                        icon: L.divIcon({
                            className: "marker-icon rect-start-marker"
                        }),
                        draggable: !0,
                        zIndexOffset: 100,
                        opacity: this.options.cursorMarker ? 1 : 0
                    }), this._startMarker._pmTempLayer = !0, this._layerGroup.addLayer(this._startMarker), this._hintMarker = L.marker([0, 0], {
                        icon: L.divIcon({
                            className: "marker-icon cursor-marker"
                        })
                    }), this._hintMarker._pmTempLayer = !0, this._layerGroup.addLayer(this._hintMarker), this.options.cursorMarker) {
                        L.DomUtil.addClass(this._hintMarker._icon, "visible"), this._styleMarkers = [];
                        for (var e = 0; e < 2; e += 1) {
                            var n = L.marker([0, 0], {
                                icon: L.divIcon({
                                    className: "marker-icon rect-style-marker"
                                }),
                                draggable: !0,
                                zIndexOffset: 100
                            });
                            n._pmTempLayer = !0, this._layerGroup.addLayer(n), this._styleMarkers.push(n)
                        }
                    }
                    this._map._container.style.cursor = "crosshair", this._map.on("click", this._placeStartingMarkers, this), this._map.on("mousemove", this._syncHintMarker, this), this._map.fire("pm:drawstart", {
                        shape: this._shape,
                        workingLayer: this._layer
                    }), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !0), this._otherSnapLayers = []
                },
                disable: function() {
                    this._enabled && (this._enabled = !1, this._map._container.style.cursor = "default", this._map.off("click", this._finishShape, this), this._map.off("click", this._placeStartingMarkers, this), this._map.off("mousemove", this._syncHintMarker, this), this._map.removeLayer(this._layerGroup), this._map.fire("pm:drawend", {
                        shape: this._shape
                    }), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !1), this.options.snappable && this._cleanupSnapping())
                },
                enabled: function() {
                    return this._enabled
                },
                toggle: function(t) {
                    this.enabled() ? this.disable() : this.enable(t)
                },
                _placeStartingMarkers: function(t) {
                    this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);
                    var e = this._hintMarker.getLatLng();
                    L.DomUtil.addClass(this._startMarker._icon, "visible"), this._startMarker.setLatLng(e), this.options.cursorMarker && this._styleMarkers && this._styleMarkers.forEach(function(t) {
                        L.DomUtil.addClass(t._icon, "visible"), t.setLatLng(e)
                    }), this._map.off("click", this._placeStartingMarkers, this), this._map.on("click", this._finishShape, this), this._setRectangleOrigin()
                },
                _setRectangleOrigin: function() {
                    var t = this._startMarker.getLatLng();
                    t && (this._layerGroup.addLayer(this._layer), this._layer.setLatLngs([t, t]), this._hintMarker.on("move", this._syncRectangleSize, this))
                },
                _syncHintMarker: function(t) {
                    if (this._hintMarker.setLatLng(t.latlng), this.options.snappable) {
                        var e = t;
                        e.target = this._hintMarker, this._handleSnapping(e)
                    }
                },
                _syncRectangleSize: function() {
                    var t = this,
                        e = this._startMarker.getLatLng(),
                        n = this._hintMarker.getLatLng();
                    if (this._layer.setBounds([e, n]), this.options.cursorMarker && this._styleMarkers) {
                        var i = [];
                        this._findCorners().forEach(function(e) {
                            e.equals(t._startMarker.getLatLng()) || e.equals(t._hintMarker.getLatLng()) || i.push(e)
                        }), i.forEach(function(e, n) {
                            t._styleMarkers[n].setLatLng(e)
                        })
                    }
                },
                _finishShape: function() {
                    var t = this._startMarker.getLatLng(),
                        e = this._hintMarker.getLatLng(),
                        n = L.rectangle([t, e], this.options.pathOptions).addTo(this._map);
                    this.disable(), this._map.fire("pm:create", {
                        shape: this._shape,
                        layer: n
                    })
                },
                _findCorners: function() {
                    var t = this._layer.getBounds();
                    return [t.getNorthWest(), t.getNorthEast(), t.getSouthEast(), t.getSouthWest()]
                }
            })
        },
        function(t, e, n) {
            var i, o = (i = n(0)) && i.__esModule ? i : {
                default: i
            };
            o.default.Circle = o.default.extend({
                initialize: function(t) {
                    this._map = t, this._shape = "Circle", this.toolbarButtonName = "drawCircle"
                },
                enable: function(t) {
                    L.Util.setOptions(this, t), this.options.radius = 0, this._enabled = !0, this._layerGroup = new L.LayerGroup, this._layerGroup._pmTempLayer = !0, this._layerGroup.addTo(this._map), this._layer = L.circle([0, 0], this.options.templineStyle), this._layer._pmTempLayer = !0, this._layerGroup.addLayer(this._layer), this._centerMarker = L.marker([0, 0], {
                        icon: L.divIcon({
                            className: "marker-icon"
                        }),
                        draggable: !1,
                        zIndexOffset: 100
                    }), this._centerMarker._pmTempLayer = !0, this._layerGroup.addLayer(this._centerMarker), this._hintMarker = L.marker([0, 0], {
                        icon: L.divIcon({
                            className: "marker-icon cursor-marker"
                        })
                    }), this._hintMarker._pmTempLayer = !0, this._layerGroup.addLayer(this._hintMarker), this.options.cursorMarker && L.DomUtil.addClass(this._hintMarker._icon, "visible"), this._hintline = L.polyline([], this.options.hintlineStyle), this._hintline._pmTempLayer = !0, this._layerGroup.addLayer(this._hintline), this._map._container.style.cursor = "crosshair", this._map.on("click", this._placeCenterMarker, this), this._map.on("mousemove", this._syncHintMarker, this), this._map.fire("pm:drawstart", {
                        shape: this._shape,
                        workingLayer: this._layer
                    }), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !0), this._otherSnapLayers = []
                },
                disable: function() {
                    this._enabled && (this._enabled = !1, this._map._container.style.cursor = "default", this._map.off("click", this._finishShape, this), this._map.off("click", this._placeCenterMarker, this), this._map.off("mousemove", this._syncHintMarker, this), this._map.removeLayer(this._layerGroup), this._map.fire("pm:drawend", {
                        shape: this._shape
                    }), this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, !1), this.options.snappable && this._cleanupSnapping())
                },
                enabled: function() {
                    return this._enabled
                },
                toggle: function(t) {
                    this.enabled() ? this.disable() : this.enable(t)
                },
                _syncHintLine: function() {
                    var t = this._centerMarker.getLatLng();
                    this._hintline.setLatLngs([t, this._hintMarker.getLatLng()])
                },
                _syncCircleRadius: function() {
                    var t = this._centerMarker.getLatLng(),
                        e = this._hintMarker.getLatLng(),
                        n = t.distanceTo(e);
                    this._layer.setRadius(n)
                },
                _syncHintMarker: function(t) {
                    if (this._hintMarker.setLatLng(t.latlng), this.options.snappable) {
                        var e = t;
                        e.target = this._hintMarker, this._handleSnapping(e)
                    }
                },
                _placeCenterMarker: function(t) {
                    this._hintMarker._snapped || this._hintMarker.setLatLng(t.latlng);
                    var e = this._hintMarker.getLatLng();
                    this._centerMarker.setLatLng(e), this._map.off("click", this._placeCenterMarker, this), this._map.on("click", this._finishShape, this), this._placeCircleCenter()
                },
                _placeCircleCenter: function() {
                    var t = this._centerMarker.getLatLng();
                    t && (this._layer.setLatLng(t), this._hintMarker.on("move", this._syncHintLine, this), this._hintMarker.on("move", this._syncCircleRadius, this), this._layer.fire("pm:centerplaced", {
                        shape: this._shape,
                        workingLayer: this._layer,
                        latlng: t
                    }))
                },
                _finishShape: function() {
                    var t = this._centerMarker.getLatLng(),
                        e = this._hintMarker.getLatLng(),
                        n = t.distanceTo(e),
                        i = L.circle(t, {
                            radius: n
                        }).addTo(this._map);
                    this.disable(), this._map.fire("pm:create", {
                        shape: this._shape,
                        layer: i
                    })
                },
                _createMarker: function(t) {
                    var e = new L.Marker(t, {
                        draggable: !1,
                        icon: L.divIcon({
                            className: "marker-icon"
                        })
                    });
                    return e._pmTempLayer = !0, this._layerGroup.addLayer(e), e
                }
            })
        },
        function(t, e, n) {
            function i(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }
            var o = i(n(20)),
                r = i(n(23)),
                s = i(n(0));
            s.default.Cut = s.default.Poly.extend({
                initialize: function(t) {
                    this._map = t, this._shape = "Cut", this.toolbarButtonName = "cutPolygon"
                },
                _cut: function(t) {
                    var e = this,
                        n = this._map._layers,
                        i = [];
                    Object.keys(n).map(function(t) {
                        return n[t]
                    }).filter(function(t) {
                        return t.pm
                    }).filter(function(t) {
                        return t instanceof L.Polygon
                    }).filter(function(e) {
                        return e !== t
                    }).filter(function(e) {
                        try {
                            return !!(0, o.default)(t.toGeoJSON(), e.toGeoJSON())
                        } catch (t) {
                            return console.error("You cant cut polygons with self-intersections"), !1
                        }
                    }).forEach(function(n) {
                        var o = (0, r.default)(n.toGeoJSON(), t.toGeoJSON());
                        if ("MultiPolygon" === o.geometry.type) o.geometry.coordinates.reduce(function(t, e) {
                            return t.push({
                                type: "Polygon",
                                coordinates: e
                            }), t
                        }, []).forEach(function(t) {
                            var o = L.geoJSON(t, n.options);
                            i.push(o), o.addTo(e._map), o.pm.enable(e.options), o.pm.disable()
                        });
                        else {
                            var s = L.geoJSON(o, n.options).addTo(e._map);
                            i.push(s), s.addTo(e._map), s.pm.enable(e.options), s.pm.disable()
                        }
                        n.fire("pm:cut", {
                            shape: e._shape,
                            layer: n,
                            resultingLayers: i
                        }), e._map.fire("pm:cut", {
                            shape: e._shape,
                            cuttedLayer: n,
                            resultingLayers: i
                        }), n._pmTempLayer = !0, t._pmTempLayer = !0, n.remove(), t.remove()
                    })
                },
                _finishShape: function() {
                    var t = this._layer.getLatLngs(),
                        e = L.polygon(t, this.options.pathOptions);
                    this._cut(e), this.disable(), this._cleanupSnapping(), this._otherSnapLayers.splice(this._tempSnapLayerIndex, 1), delete this._tempSnapLayerIndex
                }
            })
        },
        function(t, e, n) {
            var i = this && this.__importStar || function(t) {
                if (t && t.__esModule) return t;
                var e = {};
                if (null != t)
                    for (var n in t) Object.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                return e.default = t, e
            };
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var o = n(5),
                r = n(21),
                s = i(n(22));
            e.default = function t(e, n, i) {
                void 0 === i && (i = {});
                var a = r.getGeom(e),
                    h = r.getGeom(n);
                if ("Polygon" === a.type && "Polygon" === h.type) {
                    var u = s.intersection(a.coordinates, h.coordinates);
                    if (null === u || 0 === u.length) return null;
                    if (1 === u.length) {
                        var l = u[0][0][0],
                            c = u[0][0][u[0][0].length - 1];
                        return l[0] === c[0] && l[1] === c[1] ? o.polygon(u[0], i.properties) : null
                    }
                    return o.multiPolygon(u, i.properties)
                }
                if ("MultiPolygon" === a.type) {
                    for (var p = [], f = 0, d = a.coordinates; f < d.length; f++) {
                        var _ = d[f],
                            g = t(r.getGeom(o.polygon(_)), h);
                        if (g) {
                            var m = r.getGeom(g);
                            if ("Polygon" === m.type) p.push(m.coordinates);
                            else {
                                if ("MultiPolygon" !== m.type) throw new Error("intersection is invalid");
                                p = p.concat(m.coordinates)
                            }
                        }
                    }
                    return 0 === p.length ? null : 1 === p.length ? o.polygon(p[0], i.properties) : o.multiPolygon(p, i.properties)
                }
                if ("MultiPolygon" === h.type) return t(h, a);
                throw new Error("poly1 and poly2 must be either polygons or multiPolygons")
            }
        },
        function(t, e, n) {
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.getCoord = function(t) {
                if (!t) throw new Error("coord is required");
                if ("Feature" === t.type && null !== t.geometry && "Point" === t.geometry.type) return t.geometry.coordinates;
                if ("Point" === t.type) return t.coordinates;
                if (Array.isArray(t) && t.length >= 2 && void 0 === t[0].length && void 0 === t[1].length) return t;
                throw new Error("coord must be GeoJSON Point or an Array of numbers")
            }, e.getCoords = function(t) {
                if (!t) throw new Error("coords is required");
                if ("Feature" === t.type && null !== t.geometry) return t.geometry.coordinates;
                if (t.coordinates) return t.coordinates;
                if (Array.isArray(t)) return t;
                throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")
            }, e.containsNumber = function t(e) {
                if (e.length > 1 && Object(i.isNumber)(e[0]) && Object(i.isNumber)(e[1])) return !0;
                if (Array.isArray(e[0]) && e[0].length) return t(e[0]);
                throw new Error("coordinates must only contain numbers")
            }, e.geojsonType = function(t, e, n) {
                if (!e || !n) throw new Error("type and name required");
                if (!t || t.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.type)
            }, e.featureOf = function(t, e, n) {
                if (!t) throw new Error("No feature passed");
                if (!n) throw new Error(".featureOf() requires a name");
                if (!t || "Feature" !== t.type || !t.geometry) throw new Error("Invalid input to " + n + ", Feature with geometry required");
                if (!t.geometry || t.geometry.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.geometry.type)
            }, e.collectionOf = function(t, e, n) {
                if (!t) throw new Error("No featureCollection passed");
                if (!n) throw new Error(".collectionOf() requires a name");
                if (!t || "FeatureCollection" !== t.type) throw new Error("Invalid input to " + n + ", FeatureCollection required");
                for (var i = 0; i < t.features.length; i++) {
                    var o = t.features[i];
                    if (!o || "Feature" !== o.type || !o.geometry) throw new Error("Invalid input to " + n + ", Feature with geometry required");
                    if (!o.geometry || o.geometry.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + o.geometry.type)
                }
            }, e.getGeom = function(t) {
                if (!t) throw new Error("geojson is required");
                if (void 0 !== t.geometry) return t.geometry;
                if (t.coordinates || t.geometries) return t;
                throw new Error("geojson must be a valid Feature or Geometry Object")
            }, e.getGeomType = function() {
                throw new Error("invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType")
            }, e.getType = function(t, e) {
                if (!t) throw new Error((e || "geojson") + " is required");
                if (t.geometry && t.geometry.type) return t.geometry.type;
                if (t.type) return t.type;
                throw new Error((e || "geojson") + " is invalid")
            };
            var i = n(5);
            n.n(i)
        },
        function(t, e, i) {
            var o, r;
            r = function() {
                return function t(e, n, i) {
                    function r(a, h) {
                        if (!n[a]) {
                            if (!e[a]) {
                                if (!h && "function" == typeof o && o) return o(a, !0);
                                if (s) return s(a, !0);
                                var u = new Error("Cannot find module '" + a + "'");
                                throw u.code = "MODULE_NOT_FOUND", u
                            }
                            var l = n[a] = {
                                exports: {}
                            };
                            e[a][0].call(l.exports, function(t) {
                                return r(e[a][1][t] || t)
                            }, l, l.exports, t, e, n, i)
                        }
                        return n[a].exports
                    }
                    for (var s = "function" == typeof o && o, a = 0; a < i.length; a++) r(i[a]);
                    return r
                }({
                    1: [
                        function(t, e, n) {
                            var i = t("./src/index"),
                                o = {
                                    union: i.union,
                                    diff: i.diff,
                                    xor: i.xor,
                                    intersection: i.intersection
                                };
                            o.default = o, e.exports = o
                        }, {
                            "./src/index": 12
                        }
                    ],
                    2: [
                        function(t, e, i) {
                            var o, r;
                            o = this, r = function() {
                                function t(t, e) {
                                    void 0 === e && (e = function(t) {
                                        return t.key
                                    });
                                    var n = [];
                                    return function t(e, n, i, o, r) {
                                        if (e) {
                                            o(n + (i ? "└── " : "├── ") + r(e) + "\n");
                                            var s = n + (i ? "    " : "│   ");
                                            e.left && t(e.left, s, !1, o, r), e.right && t(e.right, s, !0, o, r)
                                        }
                                    }(t, "", !0, function(t) {
                                        return n.push(t)
                                    }, e), n.join("")
                                }

                                function e(t) {
                                    return t ? 1 + Math.max(e(t.left), e(t.right)) : 0
                                }

                                function n(t, e) {
                                    return t > e ? 1 : t < e ? -1 : 0
                                }

                                function i(t) {
                                    var e = t.right;
                                    return t.right = e.left, e.left && (e.left.parent = t), e.parent = t.parent, e.parent && (e.parent.left === t ? e.parent.left = e : e.parent.right = e), t.parent = e, e.left = t, t.balanceFactor += 1, e.balanceFactor < 0 && (t.balanceFactor -= e.balanceFactor), e.balanceFactor += 1, t.balanceFactor > 0 && (e.balanceFactor += t.balanceFactor), e
                                }

                                function o(t) {
                                    var e = t.left;
                                    return t.left = e.right, t.left && (t.left.parent = t), e.parent = t.parent, e.parent && (e.parent.left === t ? e.parent.left = e : e.parent.right = e), t.parent = e, e.right = t, t.balanceFactor -= 1, e.balanceFactor > 0 && (t.balanceFactor -= e.balanceFactor), e.balanceFactor -= 1, t.balanceFactor < 0 && (e.balanceFactor += t.balanceFactor), e
                                }
                                var r = function(t, e) {
                                        void 0 === e && (e = !1), this._comparator = t || n, this._root = null, this._size = 0, this._noDuplicates = !!e
                                    },
                                    s = {
                                        size: {}
                                    };
                                return r.prototype.destroy = function() {
                                        return this._root = null, this
                                    }, s.size.get = function() {
                                        return this._size
                                    }, r.prototype.contains = function(t) {
                                        if (this._root)
                                            for (var e = this._root, n = this._comparator; e;) {
                                                var i = n(t, e.key);
                                                if (0 === i) return !0;
                                                e = i < 0 ? e.left : e.right
                                            }
                                        return !1
                                    }, r.prototype.next = function(t) {
                                        var e = t;
                                        if (e)
                                            if (e.right)
                                                for (e = e.right; e && e.left;) e = e.left;
                                            else
                                                for (e = t.parent; e && e.right === t;) t = e, e = e.parent;
                                        return e
                                    }, r.prototype.prev = function(t) {
                                        var e = t;
                                        if (e)
                                            if (e.left)
                                                for (e = e.left; e && e.right;) e = e.right;
                                            else
                                                for (e = t.parent; e && e.left === t;) t = e, e = e.parent;
                                        return e
                                    }, r.prototype.forEach = function(t) {
                                        for (var e = this._root, n = [], i = !1, o = 0; !i;) e ? (n.push(e), e = e.left) : n.length > 0 ? (t(e = n.pop(), o++), e = e.right) : i = !0;
                                        return this
                                    }, r.prototype.keys = function() {
                                        for (var t = this._root, e = [], n = [], i = !1; !i;) t ? (e.push(t), t = t.left) : e.length > 0 ? (t = e.pop(), n.push(t.key), t = t.right) : i = !0;
                                        return n
                                    }, r.prototype.values = function() {
                                        for (var t = this._root, e = [], n = [], i = !1; !i;) t ? (e.push(t), t = t.left) : e.length > 0 ? (t = e.pop(), n.push(t.data), t = t.right) : i = !0;
                                        return n
                                    }, r.prototype.at = function(t) {
                                        for (var e = this._root, n = [], i = !1, o = 0; !i;)
                                            if (e) n.push(e), e = e.left;
                                            else if (n.length > 0) {
                                            if (e = n.pop(), o === t) return e;
                                            o++, e = e.right
                                        } else i = !0;
                                        return null
                                    }, r.prototype.minNode = function() {
                                        var t = this._root;
                                        if (!t) return null;
                                        for (; t.left;) t = t.left;
                                        return t
                                    }, r.prototype.maxNode = function() {
                                        var t = this._root;
                                        if (!t) return null;
                                        for (; t.right;) t = t.right;
                                        return t
                                    }, r.prototype.min = function() {
                                        var t = this._root;
                                        if (!t) return null;
                                        for (; t.left;) t = t.left;
                                        return t.key
                                    }, r.prototype.max = function() {
                                        var t = this._root;
                                        if (!t) return null;
                                        for (; t.right;) t = t.right;
                                        return t.key
                                    }, r.prototype.isEmpty = function() {
                                        return !this._root
                                    }, r.prototype.pop = function() {
                                        var t = this._root,
                                            e = null;
                                        if (t) {
                                            for (; t.left;) t = t.left;
                                            e = {
                                                key: t.key,
                                                data: t.data
                                            }, this.remove(t.key)
                                        }
                                        return e
                                    }, r.prototype.find = function(t) {
                                        for (var e, n = this._root, i = this._comparator; n;) {
                                            if (0 === (e = i(t, n.key))) return n;
                                            n = e < 0 ? n.left : n.right
                                        }
                                        return null
                                    },
                                    r.prototype.insert = function(t, e) {
                                        if (!this._root) return this._root = {
                                            parent: null,
                                            left: null,
                                            right: null,
                                            balanceFactor: 0,
                                            key: t,
                                            data: e
                                        }, this._size++, this._root;
                                        var n = this._comparator,
                                            r = this._root,
                                            s = null,
                                            a = 0;
                                        if (this._noDuplicates)
                                            for (; r;) {
                                                if (s = r, 0 === (a = n(t, r.key))) return null;
                                                r = a < 0 ? r.left : r.right
                                            } else
                                                for (; r;) s = r, r = (a = n(t, r.key)) <= 0 ? r.left : r.right;
                                        var h, u = {
                                            left: null,
                                            right: null,
                                            balanceFactor: 0,
                                            parent: s,
                                            key: t,
                                            data: e
                                        };
                                        for (a <= 0 ? s.left = u : s.right = u; s && ((a = n(s.key, t)) < 0 ? s.balanceFactor -= 1 : s.balanceFactor += 1, 0 !== s.balanceFactor);) {
                                            if (s.balanceFactor < -1) {
                                                1 === s.right.balanceFactor && o(s.right), h = i(s), s === this._root && (this._root = h);
                                                break
                                            }
                                            if (s.balanceFactor > 1) {
                                                -1 === s.left.balanceFactor && i(s.left), h = o(s), s === this._root && (this._root = h);
                                                break
                                            }
                                            s = s.parent
                                        }
                                        return this._size++, u
                                    }, r.prototype.remove = function(t) {
                                        if (!this._root) return null;
                                        for (var e = this._root, n = this._comparator, r = 0; e && 0 !== (r = n(t, e.key));) e = r < 0 ? e.left : e.right;
                                        if (!e) return null;
                                        var s, a, h = e.key;
                                        if (e.left) {
                                            for (s = e.left; s.left || s.right;) {
                                                for (; s.right;) s = s.right;
                                                e.key = s.key, e.data = s.data, s.left && (e = s, s = s.left)
                                            }
                                            e.key = s.key, e.data = s.data, e = s
                                        }
                                        if (e.right) {
                                            for (a = e.right; a.left || a.right;) {
                                                for (; a.left;) a = a.left;
                                                e.key = a.key, e.data = a.data, a.right && (e = a, a = a.right)
                                            }
                                            e.key = a.key, e.data = a.data, e = a
                                        }
                                        for (var u, l = e.parent, c = e; l && (l.left === c ? l.balanceFactor -= 1 : l.balanceFactor += 1, l.balanceFactor < -1 ? (1 === l.right.balanceFactor && o(l.right), u = i(l), l === this._root && (this._root = u), l = u) : l.balanceFactor > 1 && (-1 === l.left.balanceFactor && i(l.left), u = o(l), l === this._root && (this._root = u), l = u), -1 !== l.balanceFactor && 1 !== l.balanceFactor);) c = l, l = l.parent;
                                        return e.parent && (e.parent.left === e ? e.parent.left = null : e.parent.right = null), e === this._root && (this._root = null), this._size--, h
                                    }, r.prototype.load = function(t, e) {
                                        if (void 0 === t && (t = []), void 0 === e && (e = []), Array.isArray(t))
                                            for (var n = 0, i = t.length; n < i; n++) this.insert(t[n], e[n]);
                                        return this
                                    }, r.prototype.isBalanced = function() {
                                        return function t(n) {
                                            if (null === n) return !0;
                                            var i = e(n.left),
                                                o = e(n.right);
                                            return !!(Math.abs(i - o) <= 1 && t(n.left) && t(n.right))
                                        }(this._root)
                                    }, r.prototype.toString = function(e) {
                                        return t(this._root, e)
                                    }, Object.defineProperties(r.prototype, s), r
                            }, "object" == (void 0 === i ? "undefined" : n(i)) && void 0 !== e ? e.exports = r() : o.avl = r()
                        }, {}
                    ],
                    3: [
                        function(t, e, n) {
                            function i(t, e) {
                                if (!(this instanceof i)) return new i(t, e);
                                if (this.data = t || [], this.length = this.data.length, this.compare = e || o, this.length > 0)
                                    for (var n = (this.length >> 1) - 1; n >= 0; n--) this._down(n)
                            }

                            function o(t, e) {
                                return t < e ? -1 : t > e ? 1 : 0
                            }
                            e.exports = i, e.exports.default = i, i.prototype = {
                                push: function(t) {
                                    this.data.push(t), this.length++, this._up(this.length - 1)
                                },
                                pop: function() {
                                    if (0 !== this.length) {
                                        var t = this.data[0];
                                        return this.length--, this.length > 0 && (this.data[0] = this.data[this.length], this._down(0)), this.data.pop(), t
                                    }
                                },
                                peek: function() {
                                    return this.data[0]
                                },
                                _up: function(t) {
                                    for (var e = this.data, n = this.compare, i = e[t]; t > 0;) {
                                        var o = t - 1 >> 1,
                                            r = e[o];
                                        if (n(i, r) >= 0) break;
                                        e[t] = r, t = o
                                    }
                                    e[t] = i
                                },
                                _down: function(t) {
                                    for (var e = this.data, n = this.compare, i = this.length >> 1, o = e[t]; t < i;) {
                                        var r = 1 + (t << 1),
                                            s = r + 1,
                                            a = e[r];
                                        if (s < this.length && n(e[s], a) < 0 && (r = s, a = e[s]), n(a, o) >= 0) break;
                                        e[t] = a, t = r
                                    }
                                    e[t] = o
                                }
                            }
                        }, {}
                    ],
                    4: [
                        function(t, e, n) {
                            var i = t("./signed_area");
                            e.exports = function(t, e) {
                                var n = t.point,
                                    o = e.point;
                                return n[0] > o[0] ? 1 : n[0] < o[0] ? -1 : n[1] !== o[1] ? n[1] > o[1] ? 1 : -1 : function(t, e, n, o) {
                                    return t.left !== e.left ? t.left ? 1 : -1 : 0 !== i(n, t.otherEvent.point, e.otherEvent.point) ? t.isBelow(e.otherEvent.point) ? -1 : 1 : !t.isSubject && e.isSubject ? 1 : -1
                                }(t, e, n)
                            }
                        }, {
                            "./signed_area": 16
                        }
                    ],
                    5: [
                        function(t, e, n) {
                            var i = t("./signed_area"),
                                o = t("./compare_events"),
                                r = t("./equals");
                            e.exports = function(t, e) {
                                if (t === e) return 0;
                                if (0 !== i(t.point, t.otherEvent.point, e.point) || 0 !== i(t.point, t.otherEvent.point, e.otherEvent.point)) return r(t.point, e.point) ? t.isBelow(e.otherEvent.point) ? -1 : 1 : t.point[0] === e.point[0] ? t.point[1] < e.point[1] ? -1 : 1 : 1 === o(t, e) ? e.isAbove(t.point) ? -1 : 1 : t.isBelow(e.point) ? -1 : 1;
                                if (t.isSubject !== e.isSubject) return t.isSubject ? -1 : 1;
                                var n = t.point,
                                    s = e.point;
                                return n[0] === s[0] && n[1] === s[1] ? (n = t.otherEvent.point, s = e.otherEvent.point, n[0] === s[0] && n[1] === s[1] ? 0 : t.contourId > e.contourId ? 1 : -1) : 1 === o(t, e) ? 1 : -1
                            }
                        }, {
                            "./compare_events": 4,
                            "./equals": 10,
                            "./signed_area": 16
                        }
                    ],
                    6: [
                        function(t, e, n) {
                            function i(t, e) {
                                switch (t.type) {
                                    case o.NORMAL:
                                        switch (e) {
                                            case s:
                                                return !t.otherInOut;
                                            case a:
                                                return t.otherInOut;
                                            case h:
                                                return t.isSubject && t.otherInOut || !t.isSubject && !t.otherInOut;
                                            case u:
                                                return !0
                                        }
                                        break;
                                    case o.SAME_TRANSITION:
                                        return e === s || e === a;
                                    case o.DIFFERENT_TRANSITION:
                                        return e === h;
                                    case o.NON_CONTRIBUTING:
                                        return !1
                                }
                                return !1
                            }
                            var o = t("./edge_type"),
                                r = t("./operation"),
                                s = r.INTERSECTION,
                                a = r.UNION,
                                h = r.DIFFERENCE,
                                u = r.XOR;
                            e.exports = function(t, e, n) {
                                null === e ? (t.inOut = !1, t.otherInOut = !0) : (t.isSubject === e.isSubject ? (t.inOut = !e.inOut, t.otherInOut = e.otherInOut) : (t.inOut = !e.otherInOut, t.otherInOut = e.isVertical() ? !e.inOut : e.inOut), e && (t.prevInResult = !i(e, n) || e.isVertical() ? e.prevInResult : e)), t.inResult = i(t, n)
                            }
                        }, {
                            "./edge_type": 9,
                            "./operation": 13
                        }
                    ],
                    7: [
                        function(t, e, n) {
                            function i(t, e, n, i) {
                                var o = t + 1,
                                    r = e.length;
                                if (o > r - 1) return t - 1;
                                for (var s = e[t].point, a = e[o].point; o < r && a[0] === s[0] && a[1] === s[1];) {
                                    if (!n[o]) return o;
                                    a = e[++o].point
                                }
                                for (o = t - 1; n[o] && o >= i;) o--;
                                return o
                            }
                            var o = t("./compare_events"),
                                r = t("./operation");
                            e.exports = function(t, e) {
                                var n, s, a, h = function(t) {
                                        var e, n, i, r, s = [];
                                        for (n = 0, i = t.length; n < i; n++)((e = t[n]).left && e.inResult || !e.left && e.otherEvent.inResult) && s.push(e);
                                        for (var a = !1; !a;)
                                            for (a = !0, n = 0, i = s.length; n < i; n++) n + 1 < i && 1 === o(s[n], s[n + 1]) && (r = s[n], s[n] = s[n + 1], s[n + 1] = r, a = !1);
                                        for (n = 0, i = s.length; n < i; n++)(e = s[n]).pos = n, e.left || (r = e.pos, e.pos = e.otherEvent.pos, e.otherEvent.pos = r);
                                        return s
                                    }(t),
                                    u = {},
                                    l = [];
                                for (n = 0, s = h.length; n < s; n++)
                                    if (!u[n]) {
                                        var c = [
                                            []
                                        ];
                                        h[n].isExteriorRing ? e === r.DIFFERENCE && !h[n].isSubject && l.length > 1 ? l[l.length - 1].push(c[0]) : l.push(c) : e !== r.DIFFERENCE || h[n].isSubject || 0 !== l.length ? 0 === l.length ? l.push([
                                            [c]
                                        ]) : l[l.length - 1].push(c[0]) : l.push(c);
                                        var p = l.length - 1,
                                            f = n,
                                            d = h[n].point;
                                        for (c[0].push(d); f >= n;) a = h[f], u[f] = !0, a.left ? (a.resultInOut = !1, a.contourId = p) : (a.otherEvent.resultInOut = !0, a.otherEvent.contourId = p), u[f = a.pos] = !0, c[0].push(h[f].point), f = i(f, h, u, n);
                                        a = h[f = -1 === f ? n : f], u[f] = u[a.pos] = !0, a.otherEvent.resultInOut = !0, a.otherEvent.contourId = p
                                    }
                                return l
                            }
                        }, {
                            "./compare_events": 4,
                            "./operation": 13
                        }
                    ],
                    8: [
                        function(t, e, n) {
                            var i = t("./sweep_event"),
                                o = t("./equals"),
                                r = t("./compare_events");
                            e.exports = function(t, e, n) {
                                var s = new i(e, !1, t, t.isSubject),
                                    a = new i(e, !0, t.otherEvent, t.isSubject);
                                return o(t.point, t.otherEvent.point) && console.warn("what is that, a collapsed segment?", t), s.contourId = a.contourId = t.contourId, r(a, t.otherEvent) > 0 && (t.otherEvent.left = !0, a.left = !1), t.otherEvent.otherEvent = a, t.otherEvent = s, n.push(a), n.push(s), n
                            }
                        }, {
                            "./compare_events": 4,
                            "./equals": 10,
                            "./sweep_event": 18
                        }
                    ],
                    9: [
                        function(t, e, n) {
                            e.exports = {
                                NORMAL: 0,
                                NON_CONTRIBUTING: 1,
                                SAME_TRANSITION: 2,
                                DIFFERENT_TRANSITION: 3
                            }
                        }, {}
                    ],
                    10: [
                        function(t, e, n) {
                            e.exports = function(t, e) {
                                return t[0] === e[0] && t[1] === e[1]
                            }
                        }, {}
                    ],
                    11: [
                        function(t, e, n) {
                            function i(t, e, n, i, o, a) {
                                var l, c, p, f, d, _;
                                for (l = 0, c = t.length - 1; l < c; l++)
                                    if (p = t[l], f = t[l + 1], d = new r(p, !1, void 0, e), _ = new r(f, !1, d, e), d.otherEvent = _, p[0] !== f[0] || p[1] !== f[1]) {
                                        d.contourId = _.contourId = n, a || (d.isExteriorRing = !1, _.isExteriorRing = !1), s(d, _) > 0 ? _.left = !0 : d.left = !0;
                                        var g = p[0],
                                            m = p[1];
                                        o[0] = u(o[0], g), o[1] = u(o[1], m), o[2] = h(o[2], g), o[3] = h(o[3], m), i.push(d), i.push(_)
                                    }
                            }
                            var o = t("tinyqueue"),
                                r = t("./sweep_event"),
                                s = t("./compare_events"),
                                a = t("./operation"),
                                h = Math.max,
                                u = Math.min,
                                l = 0;
                            e.exports = function(t, e, n, r, h) {
                                var u, c, p, f, d, _, g = new o(null, s);
                                for (p = 0, f = t.length; p < f; p++)
                                    for (d = 0, _ = (u = t[p]).length; d < _; d++)(c = 0 === d) && l++, i(u[d], !0, l, g, n, c);
                                for (p = 0, f = e.length; p < f; p++)
                                    for (d = 0, _ = (u = e[p]).length; d < _; d++) c = 0 === d, h === a.DIFFERENCE && (c = !1), c && l++, i(u[d], !1, l, g, r, c);
                                return g
                            }
                        }, {
                            "./compare_events": 4,
                            "./operation": 13,
                            "./sweep_event": 18,
                            tinyqueue: 3
                        }
                    ],
                    12: [
                        function(t, e, n) {
                            function i(t, e, n) {
                                "number" == typeof t[0][0][0] && (t = [t]), "number" == typeof e[0][0][0] && (e = [e]);
                                var i = function(t, e, n) {
                                    var i = null;
                                    return t.length * e.length == 0 && (n === a.INTERSECTION ? i = h : n === a.DIFFERENCE ? i = t : n !== a.UNION && n !== a.XOR || (i = 0 === t.length ? e : t)), i
                                }(t, e, n);
                                if (i) return i === h ? null : i;
                                var u = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                                    l = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                                    c = s(t, e, u, l, n);
                                if (i = function(t, e, n, i, o) {
                                    var r = null;
                                    return (n[0] > i[2] || i[0] > n[2] || n[1] > i[3] || i[1] > n[3]) && (o === a.INTERSECTION ? r = h : o === a.DIFFERENCE ? r = t : o !== a.UNION && o !== a.XOR || (r = t.concat(e))), r
                                }(t, e, u, l, n)) return i === h ? null : i;
                                var p = o(c, t, e, u, l, n);
                                return r(p, n)
                            }
                            var o = t("./subdivide_segments"),
                                r = t("./connect_edges"),
                                s = t("./fill_queue"),
                                a = t("./operation"),
                                h = [];
                            i.union = function(t, e) {
                                return i(t, e, a.UNION)
                            }, i.diff = function(t, e) {
                                return i(t, e, a.DIFFERENCE)
                            }, i.xor = function(t, e) {
                                return i(t, e, a.XOR)
                            }, i.intersection = function(t, e) {
                                return i(t, e, a.INTERSECTION)
                            }, i.operations = a, e.exports = i, e.exports.default = i
                        }, {
                            "./connect_edges": 7,
                            "./fill_queue": 11,
                            "./operation": 13,
                            "./subdivide_segments": 17
                        }
                    ],
                    13: [
                        function(t, e, n) {
                            e.exports = {
                                INTERSECTION: 0,
                                UNION: 1,
                                DIFFERENCE: 2,
                                XOR: 3
                            }
                        }, {}
                    ],
                    14: [
                        function(t, e, n) {
                            var i = t("./divide_segment"),
                                o = t("./segment_intersection"),
                                r = t("./equals"),
                                s = t("./compare_events"),
                                a = t("./edge_type");
                            e.exports = function(t, e, n) {
                                var h = o(t.point, t.otherEvent.point, e.point, e.otherEvent.point),
                                    u = h ? h.length : 0;
                                if (0 === u) return 0;
                                if (1 === u && (r(t.point, e.point) || r(t.otherEvent.point, e.otherEvent.point))) return 0;
                                if (2 === u && t.isSubject === e.isSubject) return 0;
                                if (1 === u) return r(t.point, h[0]) || r(t.otherEvent.point, h[0]) || i(t, h[0], n), r(e.point, h[0]) || r(e.otherEvent.point, h[0]) || i(e, h[0], n), 1;
                                var l = [],
                                    c = !1,
                                    p = !1;
                                return r(t.point, e.point) ? c = !0 : 1 === s(t, e) ? l.push(e, t) : l.push(t, e), r(t.otherEvent.point, e.otherEvent.point) ? p = !0 : 1 === s(t.otherEvent, e.otherEvent) ? l.push(e.otherEvent, t.otherEvent) : l.push(t.otherEvent, e.otherEvent), c && p || c ? (e.type = a.NON_CONTRIBUTING, t.type = e.inOut === t.inOut ? a.SAME_TRANSITION : a.DIFFERENT_TRANSITION, c && !p && i(l[1].otherEvent, l[0].point, n), 2) : p ? (i(l[0], l[1].point, n), 3) : l[0] !== l[3].otherEvent ? (i(l[0], l[1].point, n), i(l[1], l[2].point, n), 3) : (i(l[0], l[1].point, n), i(l[3].otherEvent, l[2].point, n), 3)
                            }
                        }, {
                            "./compare_events": 4,
                            "./divide_segment": 8,
                            "./edge_type": 9,
                            "./equals": 10,
                            "./segment_intersection": 15
                        }
                    ],
                    15: [
                        function(t, e, n) {
                            function i(t, e) {
                                return t[0] * e[1] - t[1] * e[0]
                            }

                            function o(t, e) {
                                return t[0] * e[0] + t[1] * e[1]
                            }
                            e.exports = function(t, e, n, r, s) {
                                function a(t, e, n) {
                                    return [t[0] + e * n[0], t[1] + e * n[1]]
                                }
                                var h = [e[0] - t[0], e[1] - t[1]],
                                    u = [r[0] - n[0], r[1] - n[1]],
                                    l = [n[0] - t[0], n[1] - t[1]],
                                    c = i(h, u),
                                    p = c * c,
                                    f = o(h, h);
                                if (p > 1e-9 * f * o(u, u)) {
                                    var d = i(l, u) / c;
                                    if (d < 0 || d > 1) return null;
                                    var _ = i(l, h) / c;
                                    return _ < 0 || _ > 1 ? null : s ? null : [a(t, d, h)]
                                }
                                var g = o(l, l);
                                if ((p = (c = i(l, h)) * c) > 1e-9 * f * g) return null;
                                var m = o(h, l) / f,
                                    y = m + o(h, u) / f,
                                    v = Math.min(m, y),
                                    L = Math.max(m, y);
                                return v <= 1 && L >= 0 ? 1 === v ? s ? null : [a(t, v > 0 ? v : 0, h)] : 0 === L ? s ? null : [a(t, L < 1 ? L : 1, h)] : s && 0 === v && 1 === L ? null : [a(t, v > 0 ? v : 0, h), a(t, L < 1 ? L : 1, h)] : null
                            }
                        }, {}
                    ],
                    16: [
                        function(t, e, n) {
                            e.exports = function(t, e, n) {
                                return (t[0] - n[0]) * (e[1] - n[1]) - (e[0] - n[0]) * (t[1] - n[1])
                            }
                        }, {}
                    ],
                    17: [
                        function(t, e, n) {
                            var i = t("avl"),
                                o = t("./compute_fields"),
                                r = t("./possible_intersection"),
                                s = t("./compare_segments"),
                                a = t("./operation");
                            e.exports = function(t, e, n, h, u, l) {
                                for (var c, p, f, d = new i(s), _ = [], g = Math.min(h[2], u[2]), m = a.INTERSECTION, y = a.DIFFERENCE; t.length;) {
                                    var v = t.pop();
                                    if (_.push(v), l === m && v.point[0] > g || l === y && v.point[0] > h[2]) break;
                                    if (v.left) {
                                        p = c = d.insert(v), c = c !== (f = d.minNode()) ? d.prev(c) : null, p = d.next(p);
                                        var L, x = c ? c.key : null;
                                        if (o(v, x, l), p && 2 === r(v, p.key, t) && (o(v, x, l), o(v, p.key, l)), c && 2 === r(c.key, v, t)) {
                                            var b = c;
                                            L = (b = b !== f ? d.prev(b) : null) ? b.key : null, o(x, L, l), o(v, x, l)
                                        }
                                    } else v = v.otherEvent, p = c = d.find(v), c && p && (c = c !== f ? d.prev(c) : null, p = d.next(p), d.remove(v), p && c && r(c.key, p.key, t))
                                }
                                return _
                            }
                        }, {
                            "./compare_segments": 5,
                            "./compute_fields": 6,
                            "./operation": 13,
                            "./possible_intersection": 14,
                            avl: 2
                        }
                    ],
                    18: [
                        function(t, e, n) {
                            function i(t, e, n, i, r) {
                                this.left = e, this.point = t, this.otherEvent = n, this.isSubject = i, this.type = r || o.NORMAL, this.inOut = !1, this.otherInOut = !1, this.prevInResult = null, this.inResult = !1, this.resultInOut = !1, this.isExteriorRing = !0
                            }
                            var o = t("./edge_type");
                            i.prototype = {
                                isBelow: function(t) {
                                    var e = this.point,
                                        n = this.otherEvent.point;
                                    return this.left ? (e[0] - t[0]) * (n[1] - t[1]) - (n[0] - t[0]) * (e[1] - t[1]) > 0 : (n[0] - t[0]) * (e[1] - t[1]) - (e[0] - t[0]) * (n[1] - t[1]) > 0
                                },
                                isAbove: function(t) {
                                    return !this.isBelow(t)
                                },
                                isVertical: function() {
                                    return this.point[0] === this.otherEvent.point[0]
                                },
                                clone: function() {
                                    var t = new i(this.point, this.left, this.otherEvent, this.isSubject, this.type);
                                    return t.inResult = this.inResult, t.prevInResult = this.prevInResult, t.isExteriorRing = this.isExteriorRing, t.inOut = this.inOut, t.otherInOut = this.otherInOut, t
                                }
                            }, e.exports = i
                        }, {
                            "./edge_type": 9
                        }
                    ]
                }, {}, [1])(1)
            }, t.exports = r()
        },
        function(t, e, n) {
            function i(t) {
                switch (t.type) {
                    case "Polygon":
                        return Object(r.a)(t) > 1 ? t : null;
                    case "MultiPolygon":
                        var e = [];
                        if (Object(h.a)(t, function(t) {
                            Object(r.a)(t) > 1 && e.push(t.geometry.coordinates)
                        }), e.length) return {
                            type: "MultiPolygon",
                            coordinates: e
                        }
                }
            }
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var o = n(24),
                r = (n.n(o), n(25)),
                s = n(2),
                a = n(26),
                h = n(6);
            e.default = function(t, e) {
                var n = Object(a.a)(t),
                    r = Object(a.a)(e),
                    h = t.properties || {};
                if (n = i(n), r = i(r), !n) return null;
                if (!r) return Object(s.a)(n, h);
                var u = new o.GeoJSONReader,
                    l = u.read(n),
                    c = u.read(r),
                    p = o.OverlayOp.difference(l, c);
                if (p.isEmpty()) return null;
                var f = (new o.GeoJSONWriter).write(p);
                return Object(s.a)(f, h)
            }
        },
        function(t, e, n) {
            ! function(t) {
                function e() {}

                function n(t) {
                    this.message = t || ""
                }

                function i(t) {
                    this.message = t || ""
                }

                function o(t) {
                    this.message = t || ""
                }

                function r() {}

                function s(t) {
                    return null === t ? Rt : t.color
                }

                function a(t) {
                    return null === t ? null : t.parent
                }

                function h(t, e) {
                    null !== t && (t.color = e)
                }

                function u(t) {
                    return null === t ? null : t.left
                }

                function l(t) {
                    return null === t ? null : t.right
                }

                function c() {
                    this.root_ = null, this.size_ = 0
                }

                function p() {}

                function f() {
                    this.array_ = [], arguments[0] instanceof Lt && this.addAll(arguments[0])
                }

                function d() {}

                function _(t) {
                    this.message = t || ""
                }

                function g() {
                    this.array_ = []
                }
                "fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", {
                    configurable: !0,
                    value: function(t) {
                        if (void 0 === this || null === this) throw new TypeError(this + " is not an object");
                        var e = Object(this),
                            n = Math.max(Math.min(e.length, 9007199254740991), 0) || 0,
                            i = 1 in arguments && parseInt(Number(arguments[1]), 10) || 0;
                        i = i < 0 ? Math.max(n + i, 0) : Math.min(i, n);
                        var o = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : n;
                        for (o = o < 0 ? Math.max(n + arguments[2], 0) : Math.min(o, n); i < o;) e[i] = t, ++i;
                        return e
                    },
                    writable: !0
                }), Number.isFinite = Number.isFinite || function(t) {
                    return "number" == typeof t && isFinite(t)
                }, Number.isInteger = Number.isInteger || function(t) {
                    return "number" == typeof t && isFinite(t) && Math.floor(t) === t
                }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function(t) {
                    return t != t
                }, Math.trunc = Math.trunc || function(t) {
                    return t < 0 ? Math.ceil(t) : Math.floor(t)
                };
                var m = function() {};
                m.prototype.interfaces_ = function() {
                    return []
                }, m.prototype.getClass = function() {
                    return m
                }, m.prototype.equalsWithTolerance = function(t, e, n) {
                    return Math.abs(t - e) <= n
                };
                var y = function(t) {
                        function e(e) {
                            t.call(this, e), this.name = "IllegalArgumentException", this.message = e, this.stack = (new t).stack
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e
                    }(Error),
                    v = function() {},
                    L = {
                        MAX_VALUE: {
                            configurable: !0
                        }
                    };
                v.isNaN = function(t) {
                    return Number.isNaN(t)
                }, v.doubleToLongBits = function(t) {
                    return t
                }, v.longBitsToDouble = function(t) {
                    return t
                }, v.isInfinite = function(t) {
                    return !Number.isFinite(t)
                }, L.MAX_VALUE.get = function() {
                    return Number.MAX_VALUE
                }, Object.defineProperties(v, L);
                var x = function() {},
                    b = function() {},
                    E = function() {},
                    C = function t() {
                        if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) this.x = 0, this.y = 0, this.z = t.NULL_ORDINATE;
                        else if (1 === arguments.length) {
                            var e = arguments[0];
                            this.x = e.x, this.y = e.y, this.z = e.z
                        } else 2 === arguments.length ? (this.x = arguments[0], this.y = arguments[1], this.z = t.NULL_ORDINATE) : 3 === arguments.length && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2])
                    },
                    I = {
                        DimensionalComparator: {
                            configurable: !0
                        },
                        serialVersionUID: {
                            configurable: !0
                        },
                        NULL_ORDINATE: {
                            configurable: !0
                        },
                        X: {
                            configurable: !0
                        },
                        Y: {
                            configurable: !0
                        },
                        Z: {
                            configurable: !0
                        }
                    };
                C.prototype.setOrdinate = function(t, e) {
                    switch (t) {
                        case C.X:
                            this.x = e;
                            break;
                        case C.Y:
                            this.y = e;
                            break;
                        case C.Z:
                            this.z = e;
                            break;
                        default:
                            throw new y("Invalid ordinate index: " + t)
                    }
                }, C.prototype.equals2D = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return this.x === t.x && this.y === t.y
                    }
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        return !!m.equalsWithTolerance(this.x, e.x, n) && !!m.equalsWithTolerance(this.y, e.y, n)
                    }
                }, C.prototype.getOrdinate = function(t) {
                    switch (t) {
                        case C.X:
                            return this.x;
                        case C.Y:
                            return this.y;
                        case C.Z:
                            return this.z
                    }
                    throw new y("Invalid ordinate index: " + t)
                }, C.prototype.equals3D = function(t) {
                    return this.x === t.x && this.y === t.y && (this.z === t.z || v.isNaN(this.z)) && v.isNaN(t.z)
                }, C.prototype.equals = function(t) {
                    return t instanceof C && this.equals2D(t)
                }, C.prototype.equalInZ = function(t, e) {
                    return m.equalsWithTolerance(this.z, t.z, e)
                }, C.prototype.compareTo = function(t) {
                    var e = t;
                    return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0
                }, C.prototype.clone = function() {}, C.prototype.copy = function() {
                    return new C(this)
                }, C.prototype.toString = function() {
                    return "(" + this.x + ", " + this.y + ", " + this.z + ")"
                }, C.prototype.distance3D = function(t) {
                    var e = this.x - t.x,
                        n = this.y - t.y,
                        i = this.z - t.z;
                    return Math.sqrt(e * e + n * n + i * i)
                }, C.prototype.distance = function(t) {
                    var e = this.x - t.x,
                        n = this.y - t.y;
                    return Math.sqrt(e * e + n * n)
                }, C.prototype.hashCode = function() {
                    var t = 17;
                    return 37 * (t = 37 * t + C.hashCode(this.x)) + C.hashCode(this.y)
                }, C.prototype.setCoordinate = function(t) {
                    this.x = t.x, this.y = t.y, this.z = t.z
                }, C.prototype.interfaces_ = function() {
                    return [x, b, e]
                }, C.prototype.getClass = function() {
                    return C
                }, C.hashCode = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0],
                            e = v.doubleToLongBits(t);
                        return Math.trunc((e ^ e) >>> 32)
                    }
                }, I.DimensionalComparator.get = function() {
                    return w
                }, I.serialVersionUID.get = function() {
                    return 0x5cbf2c235c7e5800
                }, I.NULL_ORDINATE.get = function() {
                    return v.NaN
                }, I.X.get = function() {
                    return 0
                }, I.Y.get = function() {
                    return 1
                }, I.Z.get = function() {
                    return 2
                }, Object.defineProperties(C, I);
                var w = function(t) {
                    if (this._dimensionsToTest = 2, 0 === arguments.length);
                    else if (1 === arguments.length) {
                        var e = arguments[0];
                        if (2 !== e && 3 !== e) throw new y("only 2 or 3 dimensions may be specified");
                        this._dimensionsToTest = e
                    }
                };
                w.prototype.compare = function(t, e) {
                    var n = t,
                        i = e,
                        o = w.compare(n.x, i.x);
                    if (0 !== o) return o;
                    var r = w.compare(n.y, i.y);
                    return 0 !== r ? r : this._dimensionsToTest <= 2 ? 0 : w.compare(n.z, i.z)
                }, w.prototype.interfaces_ = function() {
                    return [E]
                }, w.prototype.getClass = function() {
                    return w
                }, w.compare = function(t, e) {
                    return t < e ? -1 : t > e ? 1 : v.isNaN(t) ? v.isNaN(e) ? 0 : -1 : v.isNaN(e) ? 1 : 0
                };
                var M = function() {};
                M.prototype.create = function() {}, M.prototype.interfaces_ = function() {
                    return []
                }, M.prototype.getClass = function() {
                    return M
                };
                var S = function() {},
                    P = {
                        INTERIOR: {
                            configurable: !0
                        },
                        BOUNDARY: {
                            configurable: !0
                        },
                        EXTERIOR: {
                            configurable: !0
                        },
                        NONE: {
                            configurable: !0
                        }
                    };
                S.prototype.interfaces_ = function() {
                    return []
                }, S.prototype.getClass = function() {
                    return S
                }, S.toLocationSymbol = function(t) {
                    switch (t) {
                        case S.EXTERIOR:
                            return "e";
                        case S.BOUNDARY:
                            return "b";
                        case S.INTERIOR:
                            return "i";
                        case S.NONE:
                            return "-"
                    }
                    throw new y("Unknown location value: " + t)
                }, P.INTERIOR.get = function() {
                    return 0
                }, P.BOUNDARY.get = function() {
                    return 1
                }, P.EXTERIOR.get = function() {
                    return 2
                }, P.NONE.get = function() {
                    return -1
                }, Object.defineProperties(S, P);
                var N = function(t, e) {
                        return t.interfaces_ && t.interfaces_().indexOf(e) > -1
                    },
                    T = function() {},
                    O = {
                        LOG_10: {
                            configurable: !0
                        }
                    };
                T.prototype.interfaces_ = function() {
                    return []
                }, T.prototype.getClass = function() {
                    return T
                }, T.log10 = function(t) {
                    var e = Math.log(t);
                    return v.isInfinite(e) ? e : v.isNaN(e) ? e : e / T.LOG_10
                }, T.min = function(t, e, n, i) {
                    var o = t;
                    return e < o && (o = e), n < o && (o = n), i < o && (o = i), o
                }, T.clamp = function() {
                    if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                        var t = arguments[0],
                            e = arguments[1],
                            n = arguments[2];
                        return t < e ? e : t > n ? n : t
                    }
                    if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                        var i = arguments[0],
                            o = arguments[1],
                            r = arguments[2];
                        return i < o ? o : i > r ? r : i
                    }
                }, T.wrap = function(t, e) {
                    return t < 0 ? e - -t % e : t % e
                }, T.max = function() {
                    if (3 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1],
                            n = arguments[2],
                            i = t;
                        return e > i && (i = e), n > i && (i = n), i
                    }
                    if (4 === arguments.length) {
                        var o = arguments[0],
                            r = arguments[1],
                            s = arguments[2],
                            a = arguments[3],
                            h = o;
                        return r > h && (h = r), s > h && (h = s), a > h && (h = a), h
                    }
                }, T.average = function(t, e) {
                    return (t + e) / 2
                }, O.LOG_10.get = function() {
                    return Math.log(10)
                }, Object.defineProperties(T, O);
                var A = function(t) {
                    this.str = t
                };
                A.prototype.append = function(t) {
                    this.str += t
                }, A.prototype.setCharAt = function(t, e) {
                    this.str = this.str.substr(0, t) + e + this.str.substr(t + 1)
                }, A.prototype.toString = function(t) {
                    return this.str
                };
                var R = function(t) {
                    this.value = t
                };
                R.prototype.intValue = function() {
                    return this.value
                }, R.prototype.compareTo = function(t) {
                    return this.value < t ? -1 : this.value > t ? 1 : 0
                }, R.isNaN = function(t) {
                    return Number.isNaN(t)
                };
                var D = function() {};
                D.isWhitespace = function(t) {
                    return t <= 32 && t >= 0 || 127 === t
                }, D.toUpperCase = function(t) {
                    return t.toUpperCase()
                };
                var k = function t() {
                        if (this._hi = 0, this._lo = 0, 0 === arguments.length) this.init(0);
                        else if (1 === arguments.length) {
                            if ("number" == typeof arguments[0]) {
                                var e = arguments[0];
                                this.init(e)
                            } else if (arguments[0] instanceof t) {
                                var n = arguments[0];
                                this.init(n)
                            } else if ("string" == typeof arguments[0]) {
                                var i = arguments[0];
                                t.call(this, t.parse(i))
                            }
                        } else if (2 === arguments.length) {
                            var o = arguments[0],
                                r = arguments[1];
                            this.init(o, r)
                        }
                    },
                    F = {
                        PI: {
                            configurable: !0
                        },
                        TWO_PI: {
                            configurable: !0
                        },
                        PI_2: {
                            configurable: !0
                        },
                        E: {
                            configurable: !0
                        },
                        NaN: {
                            configurable: !0
                        },
                        EPS: {
                            configurable: !0
                        },
                        SPLIT: {
                            configurable: !0
                        },
                        MAX_PRINT_DIGITS: {
                            configurable: !0
                        },
                        TEN: {
                            configurable: !0
                        },
                        ONE: {
                            configurable: !0
                        },
                        SCI_NOT_EXPONENT_CHAR: {
                            configurable: !0
                        },
                        SCI_NOT_ZERO: {
                            configurable: !0
                        }
                    };
                k.prototype.le = function(t) {
                    return (this._hi < t._hi || this._hi === t._hi) && this._lo <= t._lo
                }, k.prototype.extractSignificantDigits = function(t, e) {
                    var n = this.abs(),
                        i = k.magnitude(n._hi),
                        o = k.TEN.pow(i);
                    (n = n.divide(o)).gt(k.TEN) ? (n = n.divide(k.TEN), i += 1) : n.lt(k.ONE) && (n = n.multiply(k.TEN), i -= 1);
                    for (var r = i + 1, s = new A, a = k.MAX_PRINT_DIGITS - 1, h = 0; h <= a; h++) {
                        t && h === r && s.append(".");
                        var u = Math.trunc(n._hi);
                        if (u < 0) break;
                        var l = !1,
                            c = 0;
                        u > 9 ? (l = !0, c = "9") : c = "0" + u, s.append(c), n = n.subtract(k.valueOf(u)).multiply(k.TEN), l && n.selfAdd(k.TEN);
                        var p = !0,
                            f = k.magnitude(n._hi);
                        if (f < 0 && Math.abs(f) >= a - h && (p = !1), !p) break
                    }
                    return e[0] = i, s.toString()
                }, k.prototype.sqr = function() {
                    return this.multiply(this)
                }, k.prototype.doubleValue = function() {
                    return this._hi + this._lo
                }, k.prototype.subtract = function() {
                    if (arguments[0] instanceof k) {
                        var t = arguments[0];
                        return this.add(t.negate())
                    }
                    if ("number" == typeof arguments[0]) {
                        var e = arguments[0];
                        return this.add(-e)
                    }
                }, k.prototype.equals = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return this._hi === t._hi && this._lo === t._lo
                    }
                }, k.prototype.isZero = function() {
                    return 0 === this._hi && 0 === this._lo
                }, k.prototype.selfSubtract = function() {
                    if (arguments[0] instanceof k) {
                        var t = arguments[0];
                        return this.isNaN() ? this : this.selfAdd(-t._hi, -t._lo)
                    }
                    if ("number" == typeof arguments[0]) {
                        var e = arguments[0];
                        return this.isNaN() ? this : this.selfAdd(-e, 0)
                    }
                }, k.prototype.getSpecialNumberString = function() {
                    return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null
                }, k.prototype.min = function(t) {
                    return this.le(t) ? this : t
                }, k.prototype.selfDivide = function() {
                    if (1 === arguments.length) {
                        if (arguments[0] instanceof k) {
                            var t = arguments[0];
                            return this.selfDivide(t._hi, t._lo)
                        }
                        if ("number" == typeof arguments[0]) {
                            var e = arguments[0];
                            return this.selfDivide(e, 0)
                        }
                    } else if (2 === arguments.length) {
                        var n, i, o, r, s = arguments[0],
                            a = arguments[1],
                            h = null,
                            u = null,
                            l = null,
                            c = null;
                        return o = this._hi / s, c = (h = (l = k.SPLIT * o) - (h = l - o)) * (u = (c = k.SPLIT * s) - (u = c - s)) - (r = o * s) + h * (i = s - u) + (n = o - h) * u + n * i, c = o + (l = (this._hi - r - c + this._lo - o * a) / s), this._hi = c, this._lo = o - c + l, this
                    }
                }, k.prototype.dump = function() {
                    return "DD<" + this._hi + ", " + this._lo + ">"
                }, k.prototype.divide = function() {
                    if (arguments[0] instanceof k) {
                        var t, e, n, i, o = arguments[0],
                            r = null,
                            s = null,
                            a = null,
                            h = null;
                        return t = (n = this._hi / o._hi) - (r = (a = k.SPLIT * n) - (r = a - n)), h = r * (s = (h = k.SPLIT * o._hi) - (s = h - o._hi)) - (i = n * o._hi) + r * (e = o._hi - s) + t * s + t * e, a = (this._hi - i - h + this._lo - n * o._lo) / o._hi, new k(h = n + a, n - h + a)
                    }
                    if ("number" == typeof arguments[0]) {
                        var u = arguments[0];
                        return v.isNaN(u) ? k.createNaN() : k.copy(this).selfDivide(u, 0)
                    }
                }, k.prototype.ge = function(t) {
                    return (this._hi > t._hi || this._hi === t._hi) && this._lo >= t._lo
                }, k.prototype.pow = function(t) {
                    if (0 === t) return k.valueOf(1);
                    var e = new k(this),
                        n = k.valueOf(1),
                        i = Math.abs(t);
                    if (i > 1)
                        for (; i > 0;) i % 2 == 1 && n.selfMultiply(e), (i /= 2) > 0 && (e = e.sqr());
                    else n = e;
                    return t < 0 ? n.reciprocal() : n
                }, k.prototype.ceil = function() {
                    if (this.isNaN()) return k.NaN;
                    var t = Math.ceil(this._hi),
                        e = 0;
                    return t === this._hi && (e = Math.ceil(this._lo)), new k(t, e)
                }, k.prototype.compareTo = function(t) {
                    var e = t;
                    return this._hi < e._hi ? -1 : this._hi > e._hi ? 1 : this._lo < e._lo ? -1 : this._lo > e._lo ? 1 : 0
                }, k.prototype.rint = function() {
                    return this.isNaN() ? this : this.add(.5).floor()
                }, k.prototype.setValue = function() {
                    if (arguments[0] instanceof k) {
                        var t = arguments[0];
                        return this.init(t), this
                    }
                    if ("number" == typeof arguments[0]) {
                        var e = arguments[0];
                        return this.init(e), this
                    }
                }, k.prototype.max = function(t) {
                    return this.ge(t) ? this : t
                }, k.prototype.sqrt = function() {
                    if (this.isZero()) return k.valueOf(0);
                    if (this.isNegative()) return k.NaN;
                    var t = 1 / Math.sqrt(this._hi),
                        e = this._hi * t,
                        n = k.valueOf(e),
                        i = this.subtract(n.sqr())._hi * (.5 * t);
                    return n.add(i)
                }, k.prototype.selfAdd = function() {
                    if (1 === arguments.length) {
                        if (arguments[0] instanceof k) {
                            var t = arguments[0];
                            return this.selfAdd(t._hi, t._lo)
                        }
                        if ("number" == typeof arguments[0]) {
                            var e, n, i, o, r, s = arguments[0],
                                a = null;
                            return a = (i = this._hi + s) - (o = i - this._hi), n = (r = (a = s - o + (this._hi - a)) + this._lo) + (i - (e = i + r)), this._hi = e + n, this._lo = n + (e - this._hi), this
                        }
                    } else if (2 === arguments.length) {
                        var h, u, l, c, p = arguments[0],
                            f = arguments[1],
                            d = null,
                            _ = null,
                            g = null;
                        l = this._hi + p, u = this._lo + f, _ = l - (g = l - this._hi), d = u - (c = u - this._lo);
                        var m = (h = l + (g = (_ = p - g + (this._hi - _)) + u)) + (g = (d = f - c + (this._lo - d)) + (g + (l - h))),
                            y = g + (h - m);
                        return this._hi = m, this._lo = y, this
                    }
                }, k.prototype.selfMultiply = function() {
                    if (1 === arguments.length) {
                        if (arguments[0] instanceof k) {
                            var t = arguments[0];
                            return this.selfMultiply(t._hi, t._lo)
                        }
                        if ("number" == typeof arguments[0]) {
                            var e = arguments[0];
                            return this.selfMultiply(e, 0)
                        }
                    } else if (2 === arguments.length) {
                        var n, i, o = arguments[0],
                            r = arguments[1],
                            s = null,
                            a = null,
                            h = null,
                            u = null;
                        s = (h = k.SPLIT * this._hi) - this._hi, u = k.SPLIT * o, s = h - s, n = this._hi - s, a = u - o;
                        var l = (h = this._hi * o) + (u = s * (a = u - a) - h + s * (i = o - a) + n * a + n * i + (this._hi * r + this._lo * o)),
                            c = u + (s = h - l);
                        return this._hi = l, this._lo = c, this
                    }
                }, k.prototype.selfSqr = function() {
                    return this.selfMultiply(this)
                }, k.prototype.floor = function() {
                    if (this.isNaN()) return k.NaN;
                    var t = Math.floor(this._hi),
                        e = 0;
                    return t === this._hi && (e = Math.floor(this._lo)), new k(t, e)
                }, k.prototype.negate = function() {
                    return this.isNaN() ? this : new k(-this._hi, -this._lo)
                }, k.prototype.clone = function() {}, k.prototype.multiply = function() {
                    if (arguments[0] instanceof k) {
                        var t = arguments[0];
                        return t.isNaN() ? k.createNaN() : k.copy(this).selfMultiply(t)
                    }
                    if ("number" == typeof arguments[0]) {
                        var e = arguments[0];
                        return v.isNaN(e) ? k.createNaN() : k.copy(this).selfMultiply(e, 0)
                    }
                }, k.prototype.isNaN = function() {
                    return v.isNaN(this._hi)
                }, k.prototype.intValue = function() {
                    return Math.trunc(this._hi)
                }, k.prototype.toString = function() {
                    var t = k.magnitude(this._hi);
                    return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation()
                }, k.prototype.toStandardNotation = function() {
                    var t = this.getSpecialNumberString();
                    if (null !== t) return t;
                    var e = new Array(1).fill(null),
                        n = this.extractSignificantDigits(!0, e),
                        i = e[0] + 1,
                        o = n;
                    if ("." === n.charAt(0)) o = "0" + n;
                    else if (i < 0) o = "0." + k.stringOfChar("0", -i) + n;
                    else if (-1 === n.indexOf(".")) {
                        var r = i - n.length;
                        o = n + k.stringOfChar("0", r) + ".0"
                    }
                    return this.isNegative() ? "-" + o : o
                }, k.prototype.reciprocal = function() {
                    var t, e, n, i, o = null,
                        r = null,
                        s = null,
                        a = null;
                    t = (n = 1 / this._hi) - (o = (s = k.SPLIT * n) - (o = s - n)), r = (a = k.SPLIT * this._hi) - this._hi;
                    var h = n + (s = (1 - (i = n * this._hi) - (a = o * (r = a - r) - i + o * (e = this._hi - r) + t * r + t * e) - n * this._lo) / this._hi);
                    return new k(h, n - h + s)
                }, k.prototype.toSciNotation = function() {
                    if (this.isZero()) return k.SCI_NOT_ZERO;
                    var t = this.getSpecialNumberString();
                    if (null !== t) return t;
                    var e = new Array(1).fill(null),
                        n = this.extractSignificantDigits(!1, e),
                        i = k.SCI_NOT_EXPONENT_CHAR + e[0];
                    if ("0" === n.charAt(0)) throw new Error("Found leading zero: " + n);
                    var o = "";
                    n.length > 1 && (o = n.substring(1));
                    var r = n.charAt(0) + "." + o;
                    return this.isNegative() ? "-" + r + i : r + i
                }, k.prototype.abs = function() {
                    return this.isNaN() ? k.NaN : this.isNegative() ? this.negate() : new k(this)
                }, k.prototype.isPositive = function() {
                    return (this._hi > 0 || 0 === this._hi) && this._lo > 0
                }, k.prototype.lt = function(t) {
                    return (this._hi < t._hi || this._hi === t._hi) && this._lo < t._lo
                }, k.prototype.add = function() {
                    if (arguments[0] instanceof k) {
                        var t = arguments[0];
                        return k.copy(this).selfAdd(t)
                    }
                    if ("number" == typeof arguments[0]) {
                        var e = arguments[0];
                        return k.copy(this).selfAdd(e)
                    }
                }, k.prototype.init = function() {
                    if (1 === arguments.length) {
                        if ("number" == typeof arguments[0]) {
                            var t = arguments[0];
                            this._hi = t, this._lo = 0
                        } else if (arguments[0] instanceof k) {
                            var e = arguments[0];
                            this._hi = e._hi, this._lo = e._lo
                        }
                    } else if (2 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1];
                        this._hi = n, this._lo = i
                    }
                }, k.prototype.gt = function(t) {
                    return (this._hi > t._hi || this._hi === t._hi) && this._lo > t._lo
                }, k.prototype.isNegative = function() {
                    return (this._hi < 0 || 0 === this._hi) && this._lo < 0
                }, k.prototype.trunc = function() {
                    return this.isNaN() ? k.NaN : this.isPositive() ? this.floor() : this.ceil()
                }, k.prototype.signum = function() {
                    return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0
                }, k.prototype.interfaces_ = function() {
                    return [e, x, b]
                }, k.prototype.getClass = function() {
                    return k
                }, k.sqr = function(t) {
                    return k.valueOf(t).selfMultiply(t)
                }, k.valueOf = function() {
                    if ("string" == typeof arguments[0]) {
                        var t = arguments[0];
                        return k.parse(t)
                    }
                    if ("number" == typeof arguments[0]) {
                        var e = arguments[0];
                        return new k(e)
                    }
                }, k.sqrt = function(t) {
                    return k.valueOf(t).sqrt()
                }, k.parse = function(t) {
                    for (var e = 0, n = t.length; D.isWhitespace(t.charAt(e));) e++;
                    var i = !1;
                    if (e < n) {
                        var o = t.charAt(e);
                        "-" !== o && "+" !== o || (e++, "-" === o && (i = !0))
                    }
                    for (var r = new k, s = 0, a = 0, h = 0; !(e >= n);) {
                        var u = t.charAt(e);
                        if (e++, D.isDigit(u)) {
                            var l = u - "0";
                            r.selfMultiply(k.TEN), r.selfAdd(l), s++
                        } else {
                            if ("." !== u) {
                                if ("e" === u || "E" === u) {
                                    var c = t.substring(e);
                                    try {
                                        h = R.parseInt(c)
                                    } catch (e) {
                                        throw e instanceof Error ? new Error("Invalid exponent " + c + " in string " + t) : e
                                    }
                                    break
                                }
                                throw new Error("Unexpected character '" + u + "' at position " + e + " in string " + t)
                            }
                            a = s
                        }
                    }
                    var p = r,
                        f = s - a - h;
                    if (0 === f) p = r;
                    else if (f > 0) {
                        var d = k.TEN.pow(f);
                        p = r.divide(d)
                    } else if (f < 0) {
                        var _ = k.TEN.pow(-f);
                        p = r.multiply(_)
                    }
                    return i ? p.negate() : p
                }, k.createNaN = function() {
                    return new k(v.NaN, v.NaN)
                }, k.copy = function(t) {
                    return new k(t)
                }, k.magnitude = function(t) {
                    var e = Math.abs(t),
                        n = Math.log(e) / Math.log(10),
                        i = Math.trunc(Math.floor(n));
                    return 10 * Math.pow(10, i) <= e && (i += 1), i
                }, k.stringOfChar = function(t, e) {
                    for (var n = new A, i = 0; i < e; i++) n.append(t);
                    return n.toString()
                }, F.PI.get = function() {
                    return new k(3.141592653589793, 1.2246467991473532e-16)
                }, F.TWO_PI.get = function() {
                    return new k(6.283185307179586, 2.4492935982947064e-16)
                }, F.PI_2.get = function() {
                    return new k(1.5707963267948966, 6.123233995736766e-17)
                }, F.E.get = function() {
                    return new k(2.718281828459045, 1.4456468917292502e-16)
                }, F.NaN.get = function() {
                    return new k(v.NaN, v.NaN)
                }, F.EPS.get = function() {
                    return 1.23259516440783e-32
                }, F.SPLIT.get = function() {
                    return 134217729
                }, F.MAX_PRINT_DIGITS.get = function() {
                    return 32
                }, F.TEN.get = function() {
                    return k.valueOf(10)
                }, F.ONE.get = function() {
                    return k.valueOf(1)
                }, F.SCI_NOT_EXPONENT_CHAR.get = function() {
                    return "E"
                }, F.SCI_NOT_ZERO.get = function() {
                    return "0.0E0"
                }, Object.defineProperties(k, F);
                var z = function() {},
                    B = {
                        DP_SAFE_EPSILON: {
                            configurable: !0
                        }
                    };
                z.prototype.interfaces_ = function() {
                    return []
                }, z.prototype.getClass = function() {
                    return z
                }, z.orientationIndex = function(t, e, n) {
                    var i = z.orientationIndexFilter(t, e, n);
                    if (i <= 1) return i;
                    var o = k.valueOf(e.x).selfAdd(-t.x),
                        r = k.valueOf(e.y).selfAdd(-t.y),
                        s = k.valueOf(n.x).selfAdd(-e.x),
                        a = k.valueOf(n.y).selfAdd(-e.y);
                    return o.selfMultiply(a).selfSubtract(r.selfMultiply(s)).signum()
                }, z.signOfDet2x2 = function(t, e, n, i) {
                    return t.multiply(i).selfSubtract(e.multiply(n)).signum()
                }, z.intersection = function(t, e, n, i) {
                    var o = k.valueOf(i.y).selfSubtract(n.y).selfMultiply(k.valueOf(e.x).selfSubtract(t.x)),
                        r = k.valueOf(i.x).selfSubtract(n.x).selfMultiply(k.valueOf(e.y).selfSubtract(t.y)),
                        s = o.subtract(r),
                        a = k.valueOf(i.x).selfSubtract(n.x).selfMultiply(k.valueOf(t.y).selfSubtract(n.y)),
                        h = k.valueOf(i.y).selfSubtract(n.y).selfMultiply(k.valueOf(t.x).selfSubtract(n.x)),
                        u = a.subtract(h).selfDivide(s).doubleValue(),
                        l = k.valueOf(t.x).selfAdd(k.valueOf(e.x).selfSubtract(t.x).selfMultiply(u)).doubleValue(),
                        c = k.valueOf(e.x).selfSubtract(t.x).selfMultiply(k.valueOf(t.y).selfSubtract(n.y)),
                        p = k.valueOf(e.y).selfSubtract(t.y).selfMultiply(k.valueOf(t.x).selfSubtract(n.x)),
                        f = c.subtract(p).selfDivide(s).doubleValue(),
                        d = k.valueOf(n.y).selfAdd(k.valueOf(i.y).selfSubtract(n.y).selfMultiply(f)).doubleValue();
                    return new C(l, d)
                }, z.orientationIndexFilter = function(t, e, n) {
                    var i = null,
                        o = (t.x - n.x) * (e.y - n.y),
                        r = (t.y - n.y) * (e.x - n.x),
                        s = o - r;
                    if (o > 0) {
                        if (r <= 0) return z.signum(s);
                        i = o + r
                    } else {
                        if (!(o < 0)) return z.signum(s);
                        if (r >= 0) return z.signum(s);
                        i = -o - r
                    }
                    var a = z.DP_SAFE_EPSILON * i;
                    return s >= a || -s >= a ? z.signum(s) : 2
                }, z.signum = function(t) {
                    return t > 0 ? 1 : t < 0 ? -1 : 0
                }, B.DP_SAFE_EPSILON.get = function() {
                    return 1e-15
                }, Object.defineProperties(z, B);
                var G = function() {},
                    U = {
                        X: {
                            configurable: !0
                        },
                        Y: {
                            configurable: !0
                        },
                        Z: {
                            configurable: !0
                        },
                        M: {
                            configurable: !0
                        }
                    };
                U.X.get = function() {
                    return 0
                }, U.Y.get = function() {
                    return 1
                }, U.Z.get = function() {
                    return 2
                }, U.M.get = function() {
                    return 3
                }, G.prototype.setOrdinate = function(t, e, n) {}, G.prototype.size = function() {}, G.prototype.getOrdinate = function(t, e) {}, G.prototype.getCoordinate = function() {}, G.prototype.getCoordinateCopy = function(t) {}, G.prototype.getDimension = function() {}, G.prototype.getX = function(t) {}, G.prototype.clone = function() {}, G.prototype.expandEnvelope = function(t) {}, G.prototype.copy = function() {}, G.prototype.getY = function(t) {}, G.prototype.toCoordinateArray = function() {}, G.prototype.interfaces_ = function() {
                    return [b]
                }, G.prototype.getClass = function() {
                    return G
                }, Object.defineProperties(G, U);
                var j = function() {},
                    q = function(t) {
                        function e() {
                            t.call(this, "Projective point not representable on the Cartesian plane.")
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e
                    }(j),
                    Z = function() {};
                Z.arraycopy = function(t, e, n, i, o) {
                    for (var r = 0, s = e; s < e + o; s++) n[i + r] = t[s], r++
                }, Z.getProperty = function(t) {
                    return {
                        "line.separator": "\n"
                    }[t]
                };
                var V = function t() {
                    if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1;
                    else if (1 === arguments.length) {
                        var e = arguments[0];
                        this.x = e.x, this.y = e.y, this.w = 1
                    } else if (2 === arguments.length) {
                        if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                            var n = arguments[0],
                                i = arguments[1];
                            this.x = n, this.y = i, this.w = 1
                        } else if (arguments[0] instanceof t && arguments[1] instanceof t) {
                            var o = arguments[0],
                                r = arguments[1];
                            this.x = o.y * r.w - r.y * o.w, this.y = r.x * o.w - o.x * r.w, this.w = o.x * r.y - r.x * o.y
                        } else if (arguments[0] instanceof C && arguments[1] instanceof C) {
                            var s = arguments[0],
                                a = arguments[1];
                            this.x = s.y - a.y, this.y = a.x - s.x, this.w = s.x * a.y - a.x * s.y
                        }
                    } else if (3 === arguments.length) {
                        var h = arguments[0],
                            u = arguments[1],
                            l = arguments[2];
                        this.x = h, this.y = u, this.w = l
                    } else if (4 === arguments.length) {
                        var c = arguments[0],
                            p = arguments[1],
                            f = arguments[2],
                            d = arguments[3],
                            _ = c.y - p.y,
                            g = p.x - c.x,
                            m = c.x * p.y - p.x * c.y,
                            y = f.y - d.y,
                            v = d.x - f.x,
                            L = f.x * d.y - d.x * f.y;
                        this.x = g * L - v * m, this.y = y * m - _ * L, this.w = _ * v - y * g
                    }
                };
                V.prototype.getY = function() {
                    var t = this.y / this.w;
                    if (v.isNaN(t) || v.isInfinite(t)) throw new q;
                    return t
                }, V.prototype.getX = function() {
                    var t = this.x / this.w;
                    if (v.isNaN(t) || v.isInfinite(t)) throw new q;
                    return t
                }, V.prototype.getCoordinate = function() {
                    var t = new C;
                    return t.x = this.getX(), t.y = this.getY(), t
                }, V.prototype.interfaces_ = function() {
                    return []
                }, V.prototype.getClass = function() {
                    return V
                }, V.intersection = function(t, e, n, i) {
                    var o = t.y - e.y,
                        r = e.x - t.x,
                        s = t.x * e.y - e.x * t.y,
                        a = n.y - i.y,
                        h = i.x - n.x,
                        u = n.x * i.y - i.x * n.y,
                        l = o * h - a * r,
                        c = (r * u - h * s) / l,
                        p = (a * s - o * u) / l;
                    if (v.isNaN(c) || v.isInfinite(c) || v.isNaN(p) || v.isInfinite(p)) throw new q;
                    return new C(c, p)
                };
                var H = function t() {
                        if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length) this.init();
                        else if (1 === arguments.length) {
                            if (arguments[0] instanceof C) {
                                var e = arguments[0];
                                this.init(e.x, e.x, e.y, e.y)
                            } else if (arguments[0] instanceof t) {
                                var n = arguments[0];
                                this.init(n)
                            }
                        } else if (2 === arguments.length) {
                            var i = arguments[0],
                                o = arguments[1];
                            this.init(i.x, o.x, i.y, o.y)
                        } else if (4 === arguments.length) {
                            var r = arguments[0],
                                s = arguments[1],
                                a = arguments[2],
                                h = arguments[3];
                            this.init(r, s, a, h)
                        }
                    },
                    Y = {
                        serialVersionUID: {
                            configurable: !0
                        }
                    };
                H.prototype.getArea = function() {
                    return this.getWidth() * this.getHeight()
                }, H.prototype.equals = function(t) {
                    if (!(t instanceof H)) return !1;
                    var e = t;
                    return this.isNull() ? e.isNull() : this._maxx === e.getMaxX() && this._maxy === e.getMaxY() && this._minx === e.getMinX() && this._miny === e.getMinY()
                }, H.prototype.intersection = function(t) {
                    if (this.isNull() || t.isNull() || !this.intersects(t)) return new H;
                    var e = this._minx > t._minx ? this._minx : t._minx,
                        n = this._miny > t._miny ? this._miny : t._miny,
                        i = this._maxx < t._maxx ? this._maxx : t._maxx,
                        o = this._maxy < t._maxy ? this._maxy : t._maxy;
                    return new H(e, i, n, o)
                }, H.prototype.isNull = function() {
                    return this._maxx < this._minx
                }, H.prototype.getMaxX = function() {
                    return this._maxx
                }, H.prototype.covers = function() {
                    if (1 === arguments.length) {
                        if (arguments[0] instanceof C) {
                            var t = arguments[0];
                            return this.covers(t.x, t.y)
                        }
                        if (arguments[0] instanceof H) {
                            var e = arguments[0];
                            return !this.isNull() && !e.isNull() && e.getMinX() >= this._minx && e.getMaxX() <= this._maxx && e.getMinY() >= this._miny && e.getMaxY() <= this._maxy
                        }
                    } else if (2 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1];
                        return !this.isNull() && n >= this._minx && n <= this._maxx && i >= this._miny && i <= this._maxy
                    }
                }, H.prototype.intersects = function() {
                    if (1 === arguments.length) {
                        if (arguments[0] instanceof H) {
                            var t = arguments[0];
                            return !this.isNull() && !t.isNull() && !(t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny)
                        }
                        if (arguments[0] instanceof C) {
                            var e = arguments[0];
                            return this.intersects(e.x, e.y)
                        }
                    } else if (2 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1];
                        return !this.isNull() && !(n > this._maxx || n < this._minx || i > this._maxy || i < this._miny)
                    }
                }, H.prototype.getMinY = function() {
                    return this._miny
                }, H.prototype.getMinX = function() {
                    return this._minx
                }, H.prototype.expandToInclude = function() {
                    if (1 === arguments.length) {
                        if (arguments[0] instanceof C) {
                            var t = arguments[0];
                            this.expandToInclude(t.x, t.y)
                        } else if (arguments[0] instanceof H) {
                            var e = arguments[0];
                            if (e.isNull()) return null;
                            this.isNull() ? (this._minx = e.getMinX(), this._maxx = e.getMaxX(), this._miny = e.getMinY(), this._maxy = e.getMaxY()) : (e._minx < this._minx && (this._minx = e._minx), e._maxx > this._maxx && (this._maxx = e._maxx), e._miny < this._miny && (this._miny = e._miny), e._maxy > this._maxy && (this._maxy = e._maxy))
                        }
                    } else if (2 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1];
                        this.isNull() ? (this._minx = n, this._maxx = n, this._miny = i, this._maxy = i) : (n < this._minx && (this._minx = n), n > this._maxx && (this._maxx = n), i < this._miny && (this._miny = i), i > this._maxy && (this._maxy = i))
                    }
                }, H.prototype.minExtent = function() {
                    if (this.isNull()) return 0;
                    var t = this.getWidth(),
                        e = this.getHeight();
                    return t < e ? t : e
                }, H.prototype.getWidth = function() {
                    return this.isNull() ? 0 : this._maxx - this._minx
                }, H.prototype.compareTo = function(t) {
                    var e = t;
                    return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this._minx < e._minx ? -1 : this._minx > e._minx ? 1 : this._miny < e._miny ? -1 : this._miny > e._miny ? 1 : this._maxx < e._maxx ? -1 : this._maxx > e._maxx ? 1 : this._maxy < e._maxy ? -1 : this._maxy > e._maxy ? 1 : 0
                }, H.prototype.translate = function(t, e) {
                    if (this.isNull()) return null;
                    this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e)
                }, H.prototype.toString = function() {
                    return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]"
                }, H.prototype.setToNull = function() {
                    this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1
                }, H.prototype.getHeight = function() {
                    return this.isNull() ? 0 : this._maxy - this._miny
                }, H.prototype.maxExtent = function() {
                    if (this.isNull()) return 0;
                    var t = this.getWidth(),
                        e = this.getHeight();
                    return t > e ? t : e
                }, H.prototype.expandBy = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        this.expandBy(t, t)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        if (this.isNull()) return null;
                        this._minx -= e, this._maxx += e, this._miny -= n, this._maxy += n, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull()
                    }
                }, H.prototype.contains = function() {
                    if (1 === arguments.length) {
                        if (arguments[0] instanceof H) {
                            var t = arguments[0];
                            return this.covers(t)
                        }
                        if (arguments[0] instanceof C) {
                            var e = arguments[0];
                            return this.covers(e)
                        }
                    } else if (2 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1];
                        return this.covers(n, i)
                    }
                }, H.prototype.centre = function() {
                    return this.isNull() ? null : new C((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2)
                }, H.prototype.init = function() {
                    if (0 === arguments.length) this.setToNull();
                    else if (1 === arguments.length) {
                        if (arguments[0] instanceof C) {
                            var t = arguments[0];
                            this.init(t.x, t.x, t.y, t.y)
                        } else if (arguments[0] instanceof H) {
                            var e = arguments[0];
                            this._minx = e._minx, this._maxx = e._maxx, this._miny = e._miny, this._maxy = e._maxy
                        }
                    } else if (2 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1];
                        this.init(n.x, i.x, n.y, i.y)
                    } else if (4 === arguments.length) {
                        var o = arguments[0],
                            r = arguments[1],
                            s = arguments[2],
                            a = arguments[3];
                        o < r ? (this._minx = o, this._maxx = r) : (this._minx = r, this._maxx = o), s < a ? (this._miny = s, this._maxy = a) : (this._miny = a, this._maxy = s)
                    }
                }, H.prototype.getMaxY = function() {
                    return this._maxy
                }, H.prototype.distance = function(t) {
                    if (this.intersects(t)) return 0;
                    var e = 0;
                    this._maxx < t._minx ? e = t._minx - this._maxx : this._minx > t._maxx && (e = this._minx - t._maxx);
                    var n = 0;
                    return this._maxy < t._miny ? n = t._miny - this._maxy : this._miny > t._maxy && (n = this._miny - t._maxy), 0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n)
                }, H.prototype.hashCode = function() {
                    var t = 17;
                    return 37 * (t = 37 * (t = 37 * (t = 37 * t + C.hashCode(this._minx)) + C.hashCode(this._maxx)) + C.hashCode(this._miny)) + C.hashCode(this._maxy)
                }, H.prototype.interfaces_ = function() {
                    return [x, e]
                }, H.prototype.getClass = function() {
                    return H
                }, H.intersects = function() {
                    if (3 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1],
                            n = arguments[2];
                        return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y)
                    }
                    if (4 === arguments.length) {
                        var i = arguments[0],
                            o = arguments[1],
                            r = arguments[2],
                            s = arguments[3],
                            a = Math.min(r.x, s.x),
                            h = Math.max(r.x, s.x),
                            u = Math.min(i.x, o.x),
                            l = Math.max(i.x, o.x);
                        return !(u > h || l < a || (a = Math.min(r.y, s.y), h = Math.max(r.y, s.y), u = Math.min(i.y, o.y), l = Math.max(i.y, o.y), u > h || l < a))
                    }
                }, Y.serialVersionUID.get = function() {
                    return 0x51845cd552189800
                }, Object.defineProperties(H, Y);
                var W = {
                        typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
                        emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/,
                        spaces: /\s+/,
                        parenComma: /\)\s*,\s*\(/,
                        doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/,
                        trimParens: /^\s*\(?(.*?)\)?\s*$/
                    },
                    X = function(t) {
                        this.geometryFactory = t || new me
                    };
                X.prototype.read = function(t) {
                    var e, n, i;
                    t = t.replace(/[\n\r]/g, " ");
                    var o = W.typeStr.exec(t);
                    if (-1 !== t.search("EMPTY") && ((o = W.emptyTypeStr.exec(t))[2] = void 0), o && (n = o[1].toLowerCase(), i = o[2], K[n] && (e = K[n].apply(this, [i]))), void 0 === e) throw new Error("Could not parse WKT " + t);
                    return e
                }, X.prototype.write = function(t) {
                    return this.extractGeometry(t)
                }, X.prototype.extractGeometry = function(t) {
                    var e = t.getGeometryType().toLowerCase();
                    if (!J[e]) return null;
                    var n = e.toUpperCase();
                    return t.isEmpty() ? n + " EMPTY" : n + "(" + J[e].apply(this, [t]) + ")"
                };
                var J = {
                        coordinate: function(t) {
                            return t.x + " " + t.y
                        },
                        point: function(t) {
                            return J.coordinate.call(this, t._coordinates._coordinates[0])
                        },
                        multipoint: function(t) {
                            for (var e = [], n = 0, i = t._geometries.length; n < i; ++n) e.push("(" + J.point.apply(this, [t._geometries[n]]) + ")");
                            return e.join(",")
                        },
                        linestring: function(t) {
                            for (var e = [], n = 0, i = t._points._coordinates.length; n < i; ++n) e.push(J.coordinate.apply(this, [t._points._coordinates[n]]));
                            return e.join(",")
                        },
                        linearring: function(t) {
                            for (var e = [], n = 0, i = t._points._coordinates.length; n < i; ++n) e.push(J.coordinate.apply(this, [t._points._coordinates[n]]));
                            return e.join(",")
                        },
                        multilinestring: function(t) {
                            for (var e = [], n = 0, i = t._geometries.length; n < i; ++n) e.push("(" + J.linestring.apply(this, [t._geometries[n]]) + ")");
                            return e.join(",")
                        },
                        polygon: function(t) {
                            var e = [];
                            e.push("(" + J.linestring.apply(this, [t._shell]) + ")");
                            for (var n = 0, i = t._holes.length; n < i; ++n) e.push("(" + J.linestring.apply(this, [t._holes[n]]) + ")");
                            return e.join(",")
                        },
                        multipolygon: function(t) {
                            for (var e = [], n = 0, i = t._geometries.length; n < i; ++n) e.push("(" + J.polygon.apply(this, [t._geometries[n]]) + ")");
                            return e.join(",")
                        },
                        geometrycollection: function(t) {
                            for (var e = [], n = 0, i = t._geometries.length; n < i; ++n) e.push(this.extractGeometry(t._geometries[n]));
                            return e.join(",")
                        }
                    },
                    K = {
                        point: function(t) {
                            if (void 0 === t) return this.geometryFactory.createPoint();
                            var e = t.trim().split(W.spaces);
                            return this.geometryFactory.createPoint(new C(Number.parseFloat(e[0]), Number.parseFloat(e[1])))
                        },
                        multipoint: function(t) {
                            if (void 0 === t) return this.geometryFactory.createMultiPoint();
                            for (var e, n = t.trim().split(","), i = [], o = 0, r = n.length; o < r; ++o) e = n[o].replace(W.trimParens, "$1"), i.push(K.point.apply(this, [e]));
                            return this.geometryFactory.createMultiPoint(i)
                        },
                        linestring: function(t) {
                            if (void 0 === t) return this.geometryFactory.createLineString();
                            for (var e, n = t.trim().split(","), i = [], o = 0, r = n.length; o < r; ++o) e = n[o].trim().split(W.spaces), i.push(new C(Number.parseFloat(e[0]), Number.parseFloat(e[1])));
                            return this.geometryFactory.createLineString(i)
                        },
                        linearring: function(t) {
                            if (void 0 === t) return this.geometryFactory.createLinearRing();
                            for (var e, n = t.trim().split(","), i = [], o = 0, r = n.length; o < r; ++o) e = n[o].trim().split(W.spaces), i.push(new C(Number.parseFloat(e[0]), Number.parseFloat(e[1])));
                            return this.geometryFactory.createLinearRing(i)
                        },
                        multilinestring: function(t) {
                            if (void 0 === t) return this.geometryFactory.createMultiLineString();
                            for (var e, n = t.trim().split(W.parenComma), i = [], o = 0, r = n.length; o < r; ++o) e = n[o].replace(W.trimParens, "$1"), i.push(K.linestring.apply(this, [e]));
                            return this.geometryFactory.createMultiLineString(i)
                        },
                        polygon: function(t) {
                            if (void 0 === t) return this.geometryFactory.createPolygon();
                            for (var e, n, i, o, r = t.trim().split(W.parenComma), s = [], a = 0, h = r.length; a < h; ++a) e = r[a].replace(W.trimParens, "$1"), n = K.linestring.apply(this, [e]), i = this.geometryFactory.createLinearRing(n._points), 0 === a ? o = i : s.push(i);
                            return this.geometryFactory.createPolygon(o, s)
                        },
                        multipolygon: function(t) {
                            if (void 0 === t) return this.geometryFactory.createMultiPolygon();
                            for (var e, n = t.trim().split(W.doubleParenComma), i = [], o = 0, r = n.length; o < r; ++o) e = n[o].replace(W.trimParens, "$1"), i.push(K.polygon.apply(this, [e]));
                            return this.geometryFactory.createMultiPolygon(i)
                        },
                        geometrycollection: function(t) {
                            if (void 0 === t) return this.geometryFactory.createGeometryCollection();
                            for (var e = (t = t.replace(/,\s*([A-Za-z])/g, "|$1")).trim().split("|"), n = [], i = 0, o = e.length; i < o; ++i) n.push(this.read(e[i]));
                            return this.geometryFactory.createGeometryCollection(n)
                        }
                    },
                    Q = function(t) {
                        this.parser = new X(t)
                    };
                Q.prototype.write = function(t) {
                    return this.parser.write(t)
                }, Q.toLineString = function(t, e) {
                    if (2 !== arguments.length) throw new Error("Not implemented");
                    return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )"
                };
                var $ = function(t) {
                        function e(e) {
                            t.call(this, e), this.name = "RuntimeException", this.message = e, this.stack = (new t).stack
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e
                    }(Error),
                    tt = function(t) {
                        function e() {
                            if (t.call(this), 0 === arguments.length) t.call(this);
                            else if (1 === arguments.length) {
                                var e = arguments[0];
                                t.call(this, e)
                            }
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e
                    }($),
                    et = function() {};
                et.prototype.interfaces_ = function() {
                    return []
                }, et.prototype.getClass = function() {
                    return et
                }, et.shouldNeverReachHere = function() {
                    if (0 === arguments.length) et.shouldNeverReachHere(null);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        throw new tt("Should never reach here" + (null !== t ? ": " + t : ""))
                    }
                }, et.isTrue = function() {
                    var t, e;
                    if (1 === arguments.length) t = arguments[0], et.isTrue(t, null);
                    else if (2 === arguments.length && (t = arguments[0], e = arguments[1], !t)) throw null === e ? new tt : new tt(e)
                }, et.equals = function() {
                    var t, e, n;
                    if (2 === arguments.length) t = arguments[0], e = arguments[1], et.equals(t, e, null);
                    else if (3 === arguments.length && (t = arguments[0], e = arguments[1], n = arguments[2], !e.equals(t))) throw new tt("Expected " + t + " but encountered " + e + (null !== n ? ": " + n : ""))
                };
                var nt = function() {
                        this._result = null, this._inputLines = Array(2).fill().map(function() {
                            return Array(2)
                        }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new C, this._intPt[1] = new C, this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0
                    },
                    it = {
                        DONT_INTERSECT: {
                            configurable: !0
                        },
                        DO_INTERSECT: {
                            configurable: !0
                        },
                        COLLINEAR: {
                            configurable: !0
                        },
                        NO_INTERSECTION: {
                            configurable: !0
                        },
                        POINT_INTERSECTION: {
                            configurable: !0
                        },
                        COLLINEAR_INTERSECTION: {
                            configurable: !0
                        }
                    };
                nt.prototype.getIndexAlongSegment = function(t, e) {
                    return this.computeIntLineIndex(), this._intLineIndex[t][e]
                }, nt.prototype.getTopologySummary = function() {
                    var t = new A;
                    return this.isEndPoint() && t.append(" endpoint"), this._isProper && t.append(" proper"), this.isCollinear() && t.append(" collinear"), t.toString()
                }, nt.prototype.computeIntersection = function(t, e, n, i) {
                    this._inputLines[0][0] = t, this._inputLines[0][1] = e, this._inputLines[1][0] = n, this._inputLines[1][1] = i, this._result = this.computeIntersect(t, e, n, i)
                }, nt.prototype.getIntersectionNum = function() {
                    return this._result
                }, nt.prototype.computeIntLineIndex = function() {
                    if (0 === arguments.length) null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map(function() {
                        return Array(2)
                    }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.getEdgeDistance(t, 0) > this.getEdgeDistance(t, 1) ? (this._intLineIndex[t][0] = 0, this._intLineIndex[t][1] = 1) : (this._intLineIndex[t][0] = 1, this._intLineIndex[t][1] = 0)
                    }
                }, nt.prototype.isProper = function() {
                    return this.hasIntersection() && this._isProper
                }, nt.prototype.setPrecisionModel = function(t) {
                    this._precisionModel = t
                }, nt.prototype.isInteriorIntersection = function() {
                    if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
                    if (1 === arguments.length) {
                        for (var t = arguments[0], e = 0; e < this._result; e++)
                            if (!this._intPt[e].equals2D(this._inputLines[t][0]) && !this._intPt[e].equals2D(this._inputLines[t][1])) return !0;
                        return !1
                    }
                }, nt.prototype.getIntersection = function(t) {
                    return this._intPt[t]
                }, nt.prototype.isEndPoint = function() {
                    return this.hasIntersection() && !this._isProper
                }, nt.prototype.hasIntersection = function() {
                    return this._result !== nt.NO_INTERSECTION
                }, nt.prototype.getEdgeDistance = function(t, e) {
                    return nt.computeEdgeDistance(this._intPt[e], this._inputLines[t][0], this._inputLines[t][1])
                }, nt.prototype.isCollinear = function() {
                    return this._result === nt.COLLINEAR_INTERSECTION
                }, nt.prototype.toString = function() {
                    return Q.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Q.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary()
                }, nt.prototype.getEndpoint = function(t, e) {
                    return this._inputLines[t][e]
                }, nt.prototype.isIntersection = function(t) {
                    for (var e = 0; e < this._result; e++)
                        if (this._intPt[e].equals2D(t)) return !0;
                    return !1
                }, nt.prototype.getIntersectionAlongSegment = function(t, e) {
                    return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]]
                }, nt.prototype.interfaces_ = function() {
                    return []
                }, nt.prototype.getClass = function() {
                    return nt
                }, nt.computeEdgeDistance = function(t, e, n) {
                    var i = Math.abs(n.x - e.x),
                        o = Math.abs(n.y - e.y),
                        r = -1;
                    if (t.equals(e)) r = 0;
                    else if (t.equals(n)) r = i > o ? i : o;
                    else {
                        var s = Math.abs(t.x - e.x),
                            a = Math.abs(t.y - e.y);
                        0 !== (r = i > o ? s : a) || t.equals(e) || (r = Math.max(s, a))
                    }
                    return et.isTrue(!(0 === r && !t.equals(e)), "Bad distance calculation"), r
                }, nt.nonRobustComputeEdgeDistance = function(t, e, n) {
                    var i = t.x - e.x,
                        o = t.y - e.y,
                        r = Math.sqrt(i * i + o * o);
                    return et.isTrue(!(0 === r && !t.equals(e)), "Invalid distance calculation"), r
                }, it.DONT_INTERSECT.get = function() {
                    return 0
                }, it.DO_INTERSECT.get = function() {
                    return 1
                }, it.COLLINEAR.get = function() {
                    return 2
                }, it.NO_INTERSECTION.get = function() {
                    return 0
                }, it.POINT_INTERSECTION.get = function() {
                    return 1
                }, it.COLLINEAR_INTERSECTION.get = function() {
                    return 2
                }, Object.defineProperties(nt, it);
                var ot = function(t) {
                        function e() {
                            t.apply(this, arguments)
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isInSegmentEnvelopes = function(t) {
                            var e = new H(this._inputLines[0][0], this._inputLines[0][1]),
                                n = new H(this._inputLines[1][0], this._inputLines[1][1]);
                            return e.contains(t) && n.contains(t)
                        }, e.prototype.computeIntersection = function() {
                            if (3 !== arguments.length) return t.prototype.computeIntersection.apply(this, arguments);
                            var e = arguments[0],
                                n = arguments[1],
                                i = arguments[2];
                            if (this._isProper = !1, H.intersects(n, i, e) && 0 === at.orientationIndex(n, i, e) && 0 === at.orientationIndex(i, n, e)) return this._isProper = !0, (e.equals(n) || e.equals(i)) && (this._isProper = !1), this._result = t.POINT_INTERSECTION, null;
                            this._result = t.NO_INTERSECTION
                        }, e.prototype.normalizeToMinimum = function(t, e, n, i, o) {
                            o.x = this.smallestInAbsValue(t.x, e.x, n.x, i.x), o.y = this.smallestInAbsValue(t.y, e.y, n.y, i.y), t.x -= o.x, t.y -= o.y, e.x -= o.x, e.y -= o.y, n.x -= o.x, n.y -= o.y, i.x -= o.x, i.y -= o.y
                        }, e.prototype.safeHCoordinateIntersection = function(t, n, i, o) {
                            var r = null;
                            try {
                                r = V.intersection(t, n, i, o)
                            } catch (s) {
                                if (!(s instanceof q)) throw s;
                                r = e.nearestEndpoint(t, n, i, o)
                            }
                            return r
                        }, e.prototype.intersection = function(t, n, i, o) {
                            var r = this.intersectionWithNormalization(t, n, i, o);
                            return this.isInSegmentEnvelopes(r) || (r = new C(e.nearestEndpoint(t, n, i, o))), null !== this._precisionModel && this._precisionModel.makePrecise(r), r
                        }, e.prototype.smallestInAbsValue = function(t, e, n, i) {
                            var o = t,
                                r = Math.abs(o);
                            return Math.abs(e) < r && (o = e, r = Math.abs(e)), Math.abs(n) < r && (o = n, r = Math.abs(n)), Math.abs(i) < r && (o = i), o
                        }, e.prototype.checkDD = function(t, e, n, i, o) {
                            var r = z.intersection(t, e, n, i),
                                s = this.isInSegmentEnvelopes(r);
                            Z.out.println("DD in env = " + s + "  --------------------- " + r), o.distance(r) > 1e-4 && Z.out.println("Distance = " + o.distance(r))
                        }, e.prototype.intersectionWithNormalization = function(t, e, n, i) {
                            var o = new C(t),
                                r = new C(e),
                                s = new C(n),
                                a = new C(i),
                                h = new C;
                            this.normalizeToEnvCentre(o, r, s, a, h);
                            var u = this.safeHCoordinateIntersection(o, r, s, a);
                            return u.x += h.x, u.y += h.y, u
                        }, e.prototype.computeCollinearIntersection = function(e, n, i, o) {
                            var r = H.intersects(e, n, i),
                                s = H.intersects(e, n, o),
                                a = H.intersects(i, o, e),
                                h = H.intersects(i, o, n);
                            return r && s ? (this._intPt[0] = i, this._intPt[1] = o, t.COLLINEAR_INTERSECTION) : a && h ? (this._intPt[0] = e, this._intPt[1] = n, t.COLLINEAR_INTERSECTION) : r && a ? (this._intPt[0] = i, this._intPt[1] = e, !i.equals(e) || s || h ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : r && h ? (this._intPt[0] = i, this._intPt[1] = n, !i.equals(n) || s || a ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : s && a ? (this._intPt[0] = o, this._intPt[1] = e, !o.equals(e) || r || h ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : s && h ? (this._intPt[0] = o, this._intPt[1] = n, !o.equals(n) || r || a ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : t.NO_INTERSECTION
                        }, e.prototype.normalizeToEnvCentre = function(t, e, n, i, o) {
                            var r = t.x < e.x ? t.x : e.x,
                                s = t.y < e.y ? t.y : e.y,
                                a = t.x > e.x ? t.x : e.x,
                                h = t.y > e.y ? t.y : e.y,
                                u = n.x < i.x ? n.x : i.x,
                                l = n.y < i.y ? n.y : i.y,
                                c = n.x > i.x ? n.x : i.x,
                                p = n.y > i.y ? n.y : i.y,
                                f = ((r > u ? r : u) + (a < c ? a : c)) / 2,
                                d = ((s > l ? s : l) + (h < p ? h : p)) / 2;
                            o.x = f, o.y = d, t.x -= o.x, t.y -= o.y, e.x -= o.x, e.y -= o.y, n.x -= o.x, n.y -= o.y, i.x -= o.x, i.y -= o.y
                        }, e.prototype.computeIntersect = function(e, n, i, o) {
                            if (this._isProper = !1, !H.intersects(e, n, i, o)) return t.NO_INTERSECTION;
                            var r = at.orientationIndex(e, n, i),
                                s = at.orientationIndex(e, n, o);
                            if (r > 0 && s > 0 || r < 0 && s < 0) return t.NO_INTERSECTION;
                            var a = at.orientationIndex(i, o, e),
                                h = at.orientationIndex(i, o, n);
                            return a > 0 && h > 0 || a < 0 && h < 0 ? t.NO_INTERSECTION : 0 === r && 0 === s && 0 === a && 0 === h ? this.computeCollinearIntersection(e, n, i, o) : (0 === r || 0 === s || 0 === a || 0 === h ? (this._isProper = !1, e.equals2D(i) || e.equals2D(o) ? this._intPt[0] = e : n.equals2D(i) || n.equals2D(o) ? this._intPt[0] = n : 0 === r ? this._intPt[0] = new C(i) : 0 === s ? this._intPt[0] = new C(o) : 0 === a ? this._intPt[0] = new C(e) : 0 === h && (this._intPt[0] = new C(n))) : (this._isProper = !0, this._intPt[0] = this.intersection(e, n, i, o)), t.POINT_INTERSECTION)
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e.nearestEndpoint = function(t, e, n, i) {
                            var o = t,
                                r = at.distancePointLine(t, n, i),
                                s = at.distancePointLine(e, n, i);
                            return s < r && (r = s, o = e), (s = at.distancePointLine(n, t, e)) < r && (r = s, o = n), (s = at.distancePointLine(i, t, e)) < r && (r = s, o = i), o
                        }, e
                    }(nt),
                    rt = function() {};
                rt.prototype.interfaces_ = function() {
                    return []
                }, rt.prototype.getClass = function() {
                    return rt
                }, rt.orientationIndex = function(t, e, n) {
                    var i = e.x - t.x,
                        o = e.y - t.y,
                        r = n.x - e.x,
                        s = n.y - e.y;
                    return rt.signOfDet2x2(i, o, r, s)
                }, rt.signOfDet2x2 = function(t, e, n, i) {
                    var o = null,
                        r = null,
                        s = null;
                    if (o = 1, 0 === t || 0 === i) return 0 === e || 0 === n ? 0 : e > 0 ? n > 0 ? -o : o : n > 0 ? o : -o;
                    if (0 === e || 0 === n) return i > 0 ? t > 0 ? o : -o : t > 0 ? -o : o;
                    if (e > 0 ? i > 0 ? e <= i || (o = -o, r = t, t = n, n = r, r = e, e = i, i = r) : e <= -i ? (o = -o, n = -n, i = -i) : (r = t, t = -n, n = r, r = e, e = -i, i = r) : i > 0 ? -e <= i ? (o = -o, t = -t, e = -e) : (r = -t, t = n, n = r, r = -e, e = i, i = r) : e >= i ? (t = -t, e = -e, n = -n, i = -i) : (o = -o, r = -t, t = -n, n = r, r = -e, e = -i, i = r), t > 0) {
                        if (!(n > 0)) return o;
                        if (!(t <= n)) return o
                    } else {
                        if (n > 0) return -o;
                        if (!(t >= n)) return -o;
                        o = -o, t = -t, n = -n
                    }
                    for (;;) {
                        if (n -= (s = Math.floor(n / t)) * t, (i -= s * e) < 0) return -o;
                        if (i > e) return o;
                        if (t > n + n) {
                            if (e < i + i) return o
                        } else {
                            if (e > i + i) return -o;
                            n = t - n, i = e - i, o = -o
                        } if (0 === i) return 0 === n ? 0 : -o;
                        if (0 === n) return o;
                        if (t -= (s = Math.floor(t / n)) * n, (e -= s * i) < 0) return o;
                        if (e > i) return -o;
                        if (n > t + t) {
                            if (i < e + e) return -o
                        } else {
                            if (i > e + e) return o;
                            t = n - t, e = i - e, o = -o
                        } if (0 === e) return 0 === t ? 0 : o;
                        if (0 === t) return -o
                    }
                };
                var st = function() {
                    this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;
                    var t = arguments[0];
                    this._p = t
                };
                st.prototype.countSegment = function(t, e) {
                    if (t.x < this._p.x && e.x < this._p.x) return null;
                    if (this._p.x === e.x && this._p.y === e.y) return this._isPointOnSegment = !0, null;
                    if (t.y === this._p.y && e.y === this._p.y) {
                        var n = t.x,
                            i = e.x;
                        return n > i && (n = e.x, i = t.x), this._p.x >= n && this._p.x <= i && (this._isPointOnSegment = !0), null
                    }
                    if (t.y > this._p.y && e.y <= this._p.y || e.y > this._p.y && t.y <= this._p.y) {
                        var o = t.x - this._p.x,
                            r = t.y - this._p.y,
                            s = e.x - this._p.x,
                            a = e.y - this._p.y,
                            h = rt.signOfDet2x2(o, r, s, a);
                        if (0 === h) return this._isPointOnSegment = !0, null;
                        a < r && (h = -h), h > 0 && this._crossingCount++
                    }
                }, st.prototype.isPointInPolygon = function() {
                    return this.getLocation() !== S.EXTERIOR
                }, st.prototype.getLocation = function() {
                    return this._isPointOnSegment ? S.BOUNDARY : this._crossingCount % 2 == 1 ? S.INTERIOR : S.EXTERIOR
                }, st.prototype.isOnSegment = function() {
                    return this._isPointOnSegment
                }, st.prototype.interfaces_ = function() {
                    return []
                }, st.prototype.getClass = function() {
                    return st
                }, st.locatePointInRing = function() {
                    if (arguments[0] instanceof C && N(arguments[1], G)) {
                        for (var t = arguments[0], e = arguments[1], n = new st(t), i = new C, o = new C, r = 1; r < e.size(); r++)
                            if (e.getCoordinate(r, i), e.getCoordinate(r - 1, o), n.countSegment(i, o), n.isOnSegment()) return n.getLocation();
                        return n.getLocation()
                    }
                    if (arguments[0] instanceof C && arguments[1] instanceof Array) {
                        for (var s = arguments[0], a = arguments[1], h = new st(s), u = 1; u < a.length; u++) {
                            var l = a[u],
                                c = a[u - 1];
                            if (h.countSegment(l, c), h.isOnSegment()) return h.getLocation()
                        }
                        return h.getLocation()
                    }
                };
                var at = function() {},
                    ht = {
                        CLOCKWISE: {
                            configurable: !0
                        },
                        RIGHT: {
                            configurable: !0
                        },
                        COUNTERCLOCKWISE: {
                            configurable: !0
                        },
                        LEFT: {
                            configurable: !0
                        },
                        COLLINEAR: {
                            configurable: !0
                        },
                        STRAIGHT: {
                            configurable: !0
                        }
                    };
                at.prototype.interfaces_ = function() {
                    return []
                }, at.prototype.getClass = function() {
                    return at
                }, at.orientationIndex = function(t, e, n) {
                    return z.orientationIndex(t, e, n)
                }, at.signedArea = function() {
                    if (arguments[0] instanceof Array) {
                        var t = arguments[0];
                        if (t.length < 3) return 0;
                        for (var e = 0, n = t[0].x, i = 1; i < t.length - 1; i++) {
                            var o = t[i].x - n,
                                r = t[i + 1].y;
                            e += o * (t[i - 1].y - r)
                        }
                        return e / 2
                    }
                    if (N(arguments[0], G)) {
                        var s = arguments[0],
                            a = s.size();
                        if (a < 3) return 0;
                        var h = new C,
                            u = new C,
                            l = new C;
                        s.getCoordinate(0, u), s.getCoordinate(1, l);
                        var c = u.x;
                        l.x -= c;
                        for (var p = 0, f = 1; f < a - 1; f++) h.y = u.y, u.x = l.x, u.y = l.y, s.getCoordinate(f + 1, l), l.x -= c, p += u.x * (h.y - l.y);
                        return p / 2
                    }
                }, at.distanceLineLine = function(t, e, n, i) {
                    if (t.equals(e)) return at.distancePointLine(t, n, i);
                    if (n.equals(i)) return at.distancePointLine(i, t, e);
                    var o = !1;
                    if (H.intersects(t, e, n, i)) {
                        var r = (e.x - t.x) * (i.y - n.y) - (e.y - t.y) * (i.x - n.x);
                        if (0 === r) o = !0;
                        else {
                            var s = (t.y - n.y) * (i.x - n.x) - (t.x - n.x) * (i.y - n.y),
                                a = ((t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y)) / r,
                                h = s / r;
                            (h < 0 || h > 1 || a < 0 || a > 1) && (o = !0)
                        }
                    } else o = !0;
                    return o ? T.min(at.distancePointLine(t, n, i), at.distancePointLine(e, n, i), at.distancePointLine(n, t, e), at.distancePointLine(i, t, e)) : 0
                }, at.isPointInRing = function(t, e) {
                    return at.locatePointInRing(t, e) !== S.EXTERIOR
                }, at.computeLength = function(t) {
                    var e = t.size();
                    if (e <= 1) return 0;
                    var n = 0,
                        i = new C;
                    t.getCoordinate(0, i);
                    for (var o = i.x, r = i.y, s = 1; s < e; s++) {
                        t.getCoordinate(s, i);
                        var a = i.x,
                            h = i.y,
                            u = a - o,
                            l = h - r;
                        n += Math.sqrt(u * u + l * l), o = a, r = h
                    }
                    return n
                }, at.isCCW = function(t) {
                    var e = t.length - 1;
                    if (e < 3) throw new y("Ring has fewer than 4 points, so orientation cannot be determined");
                    for (var n = t[0], i = 0, o = 1; o <= e; o++) {
                        var r = t[o];
                        r.y > n.y && (n = r, i = o)
                    }
                    var s = i;
                    do {
                        (s -= 1) < 0 && (s = e)
                    } while (t[s].equals2D(n) && s !== i);
                    var a = i;
                    do {
                        a = (a + 1) % e
                    } while (t[a].equals2D(n) && a !== i);
                    var h = t[s],
                        u = t[a];
                    if (h.equals2D(n) || u.equals2D(n) || h.equals2D(u)) return !1;
                    var l = at.computeOrientation(h, n, u);
                    return 0 === l ? h.x > u.x : l > 0
                }, at.locatePointInRing = function(t, e) {
                    return st.locatePointInRing(t, e)
                }, at.distancePointLinePerpendicular = function(t, e, n) {
                    var i = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),
                        o = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / i;
                    return Math.abs(o) * Math.sqrt(i)
                }, at.computeOrientation = function(t, e, n) {
                    return at.orientationIndex(t, e, n)
                }, at.distancePointLine = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        if (0 === e.length) throw new y("Line array must contain at least one vertex");
                        for (var n = t.distance(e[0]), i = 0; i < e.length - 1; i++) {
                            var o = at.distancePointLine(t, e[i], e[i + 1]);
                            o < n && (n = o)
                        }
                        return n
                    }
                    if (3 === arguments.length) {
                        var r = arguments[0],
                            s = arguments[1],
                            a = arguments[2];
                        if (s.x === a.x && s.y === a.y) return r.distance(s);
                        var h = (a.x - s.x) * (a.x - s.x) + (a.y - s.y) * (a.y - s.y),
                            u = ((r.x - s.x) * (a.x - s.x) + (r.y - s.y) * (a.y - s.y)) / h;
                        if (u <= 0) return r.distance(s);
                        if (u >= 1) return r.distance(a);
                        var l = ((s.y - r.y) * (a.x - s.x) - (s.x - r.x) * (a.y - s.y)) / h;
                        return Math.abs(l) * Math.sqrt(h)
                    }
                }, at.isOnLine = function(t, e) {
                    for (var n = new ot, i = 1; i < e.length; i++) {
                        var o = e[i - 1],
                            r = e[i];
                        if (n.computeIntersection(t, o, r), n.hasIntersection()) return !0
                    }
                    return !1
                }, ht.CLOCKWISE.get = function() {
                    return -1
                }, ht.RIGHT.get = function() {
                    return at.CLOCKWISE
                }, ht.COUNTERCLOCKWISE.get = function() {
                    return 1
                }, ht.LEFT.get = function() {
                    return at.COUNTERCLOCKWISE
                }, ht.COLLINEAR.get = function() {
                    return 0
                }, ht.STRAIGHT.get = function() {
                    return at.COLLINEAR
                }, Object.defineProperties(at, ht);
                var ut = function() {};
                ut.prototype.filter = function(t) {}, ut.prototype.interfaces_ = function() {
                    return []
                }, ut.prototype.getClass = function() {
                    return ut
                };
                var lt = function() {
                        var t = arguments[0];
                        this._envelope = null, this._factory = null, this._SRID = null, this._userData = null, this._factory = t, this._SRID = t.getSRID()
                    },
                    ct = {
                        serialVersionUID: {
                            configurable: !0
                        },
                        SORTINDEX_POINT: {
                            configurable: !0
                        },
                        SORTINDEX_MULTIPOINT: {
                            configurable: !0
                        },
                        SORTINDEX_LINESTRING: {
                            configurable: !0
                        },
                        SORTINDEX_LINEARRING: {
                            configurable: !0
                        },
                        SORTINDEX_MULTILINESTRING: {
                            configurable: !0
                        },
                        SORTINDEX_POLYGON: {
                            configurable: !0
                        },
                        SORTINDEX_MULTIPOLYGON: {
                            configurable: !0
                        },
                        SORTINDEX_GEOMETRYCOLLECTION: {
                            configurable: !0
                        },
                        geometryChangedFilter: {
                            configurable: !0
                        }
                    };
                lt.prototype.isGeometryCollection = function() {
                    return this.getSortIndex() === lt.SORTINDEX_GEOMETRYCOLLECTION
                }, lt.prototype.getFactory = function() {
                    return this._factory
                }, lt.prototype.getGeometryN = function(t) {
                    return this
                }, lt.prototype.getArea = function() {
                    return 0
                }, lt.prototype.isRectangle = function() {
                    return !1
                }, lt.prototype.equals = function() {
                    if (arguments[0] instanceof lt) {
                        var t = arguments[0];
                        return null !== t && this.equalsTopo(t)
                    }
                    if (arguments[0] instanceof Object) {
                        var e = arguments[0];
                        if (!(e instanceof lt)) return !1;
                        var n = e;
                        return this.equalsExact(n)
                    }
                }, lt.prototype.equalsExact = function(t) {
                    return this === t || this.equalsExact(t, 0)
                }, lt.prototype.geometryChanged = function() {
                    this.apply(lt.geometryChangedFilter)
                }, lt.prototype.geometryChangedAction = function() {
                    this._envelope = null
                }, lt.prototype.equalsNorm = function(t) {
                    return null !== t && this.norm().equalsExact(t.norm())
                }, lt.prototype.getLength = function() {
                    return 0
                }, lt.prototype.getNumGeometries = function() {
                    return 1
                }, lt.prototype.compareTo = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0],
                            e = t;
                        return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(t)
                    }
                    if (2 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1];
                        return this.getSortIndex() !== n.getSortIndex() ? this.getSortIndex() - n.getSortIndex() : this.isEmpty() && n.isEmpty() ? 0 : this.isEmpty() ? -1 : n.isEmpty() ? 1 : this.compareToSameClass(n, i)
                    }
                }, lt.prototype.getUserData = function() {
                    return this._userData
                }, lt.prototype.getSRID = function() {
                    return this._SRID
                }, lt.prototype.getEnvelope = function() {
                    return this.getFactory().toGeometry(this.getEnvelopeInternal())
                }, lt.prototype.checkNotGeometryCollection = function(t) {
                    if (t.getSortIndex() === lt.SORTINDEX_GEOMETRYCOLLECTION) throw new y("This method does not support GeometryCollection arguments")
                }, lt.prototype.equal = function(t, e, n) {
                    return 0 === n ? t.equals(e) : t.distance(e) <= n
                }, lt.prototype.norm = function() {
                    var t = this.copy();
                    return t.normalize(), t
                }, lt.prototype.getPrecisionModel = function() {
                    return this._factory.getPrecisionModel()
                }, lt.prototype.getEnvelopeInternal = function() {
                    return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new H(this._envelope)
                }, lt.prototype.setSRID = function(t) {
                    this._SRID = t
                }, lt.prototype.setUserData = function(t) {
                    this._userData = t
                }, lt.prototype.compare = function(t, e) {
                    for (var n = t.iterator(), i = e.iterator(); n.hasNext() && i.hasNext();) {
                        var o = n.next(),
                            r = i.next(),
                            s = o.compareTo(r);
                        if (0 !== s) return s
                    }
                    return n.hasNext() ? 1 : i.hasNext() ? -1 : 0
                }, lt.prototype.hashCode = function() {
                    return this.getEnvelopeInternal().hashCode()
                }, lt.prototype.isGeometryCollectionOrDerived = function() {
                    return this.getSortIndex() === lt.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === lt.SORTINDEX_MULTIPOINT || this.getSortIndex() === lt.SORTINDEX_MULTILINESTRING || this.getSortIndex() === lt.SORTINDEX_MULTIPOLYGON
                }, lt.prototype.interfaces_ = function() {
                    return [b, x, e]
                }, lt.prototype.getClass = function() {
                    return lt
                }, lt.hasNonEmptyElements = function(t) {
                    for (var e = 0; e < t.length; e++)
                        if (!t[e].isEmpty()) return !0;
                    return !1
                }, lt.hasNullElements = function(t) {
                    for (var e = 0; e < t.length; e++)
                        if (null === t[e]) return !0;
                    return !1
                }, ct.serialVersionUID.get = function() {
                    return 0x799ea46522854c00
                }, ct.SORTINDEX_POINT.get = function() {
                    return 0
                }, ct.SORTINDEX_MULTIPOINT.get = function() {
                    return 1
                }, ct.SORTINDEX_LINESTRING.get = function() {
                    return 2
                }, ct.SORTINDEX_LINEARRING.get = function() {
                    return 3
                }, ct.SORTINDEX_MULTILINESTRING.get = function() {
                    return 4
                }, ct.SORTINDEX_POLYGON.get = function() {
                    return 5
                }, ct.SORTINDEX_MULTIPOLYGON.get = function() {
                    return 6
                }, ct.SORTINDEX_GEOMETRYCOLLECTION.get = function() {
                    return 7
                }, ct.geometryChangedFilter.get = function() {
                    return pt
                }, Object.defineProperties(lt, ct);
                var pt = function() {};
                pt.interfaces_ = function() {
                    return [ut]
                }, pt.filter = function(t) {
                    t.geometryChangedAction()
                };
                var ft = function() {};
                ft.prototype.filter = function(t) {}, ft.prototype.interfaces_ = function() {
                    return []
                }, ft.prototype.getClass = function() {
                    return ft
                };
                var dt = function() {},
                    _t = {
                        Mod2BoundaryNodeRule: {
                            configurable: !0
                        },
                        EndPointBoundaryNodeRule: {
                            configurable: !0
                        },
                        MultiValentEndPointBoundaryNodeRule: {
                            configurable: !0
                        },
                        MonoValentEndPointBoundaryNodeRule: {
                            configurable: !0
                        },
                        MOD2_BOUNDARY_RULE: {
                            configurable: !0
                        },
                        ENDPOINT_BOUNDARY_RULE: {
                            configurable: !0
                        },
                        MULTIVALENT_ENDPOINT_BOUNDARY_RULE: {
                            configurable: !0
                        },
                        MONOVALENT_ENDPOINT_BOUNDARY_RULE: {
                            configurable: !0
                        },
                        OGC_SFS_BOUNDARY_RULE: {
                            configurable: !0
                        }
                    };
                dt.prototype.isInBoundary = function(t) {}, dt.prototype.interfaces_ = function() {
                    return []
                }, dt.prototype.getClass = function() {
                    return dt
                }, _t.Mod2BoundaryNodeRule.get = function() {
                    return gt
                }, _t.EndPointBoundaryNodeRule.get = function() {
                    return mt
                }, _t.MultiValentEndPointBoundaryNodeRule.get = function() {
                    return yt
                }, _t.MonoValentEndPointBoundaryNodeRule.get = function() {
                    return vt
                }, _t.MOD2_BOUNDARY_RULE.get = function() {
                    return new gt
                }, _t.ENDPOINT_BOUNDARY_RULE.get = function() {
                    return new mt
                }, _t.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
                    return new yt
                }, _t.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
                    return new vt
                }, _t.OGC_SFS_BOUNDARY_RULE.get = function() {
                    return dt.MOD2_BOUNDARY_RULE
                }, Object.defineProperties(dt, _t);
                var gt = function() {};
                gt.prototype.isInBoundary = function(t) {
                    return t % 2 == 1
                }, gt.prototype.interfaces_ = function() {
                    return [dt]
                }, gt.prototype.getClass = function() {
                    return gt
                };
                var mt = function() {};
                mt.prototype.isInBoundary = function(t) {
                    return t > 0
                }, mt.prototype.interfaces_ = function() {
                    return [dt]
                }, mt.prototype.getClass = function() {
                    return mt
                };
                var yt = function() {};
                yt.prototype.isInBoundary = function(t) {
                    return t > 1
                }, yt.prototype.interfaces_ = function() {
                    return [dt]
                }, yt.prototype.getClass = function() {
                    return yt
                };
                var vt = function() {};
                vt.prototype.isInBoundary = function(t) {
                    return 1 === t
                }, vt.prototype.interfaces_ = function() {
                    return [dt]
                }, vt.prototype.getClass = function() {
                    return vt
                };
                var Lt = function() {};
                Lt.prototype.add = function() {}, Lt.prototype.addAll = function() {}, Lt.prototype.isEmpty = function() {}, Lt.prototype.iterator = function() {}, Lt.prototype.size = function() {}, Lt.prototype.toArray = function() {}, Lt.prototype.remove = function() {}, (n.prototype = new Error).name = "IndexOutOfBoundsException";
                var xt = function() {};
                xt.prototype.hasNext = function() {}, xt.prototype.next = function() {}, xt.prototype.remove = function() {};
                var bt = function(t) {
                    function e() {
                        t.apply(this, arguments)
                    }
                    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.get = function() {}, e.prototype.set = function() {}, e.prototype.isEmpty = function() {}, e
                }(Lt);
                (i.prototype = new Error).name = "NoSuchElementException";
                var Et = function(t) {
                        function e() {
                            t.call(this), this.array_ = [], arguments[0] instanceof Lt && this.addAll(arguments[0])
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.ensureCapacity = function() {}, e.prototype.interfaces_ = function() {
                            return [t, Lt]
                        }, e.prototype.add = function(t) {
                            return 1 === arguments.length ? this.array_.push(t) : this.array_.splice(arguments[0], arguments[1]), !0
                        }, e.prototype.clear = function() {
                            this.array_ = []
                        }, e.prototype.addAll = function(t) {
                            for (var e = t.iterator(); e.hasNext();) this.add(e.next());
                            return !0
                        }, e.prototype.set = function(t, e) {
                            var n = this.array_[t];
                            return this.array_[t] = e, n
                        }, e.prototype.iterator = function() {
                            return new Ct(this)
                        }, e.prototype.get = function(t) {
                            if (t < 0 || t >= this.size()) throw new n;
                            return this.array_[t]
                        }, e.prototype.isEmpty = function() {
                            return 0 === this.array_.length
                        }, e.prototype.size = function() {
                            return this.array_.length
                        }, e.prototype.toArray = function() {
                            for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);
                            return t
                        }, e.prototype.remove = function(t) {
                            for (var e = !1, n = 0, i = this.array_.length; n < i; n++)
                                if (this.array_[n] === t) {
                                    this.array_.splice(n, 1), e = !0;
                                    break
                                }
                            return e
                        }, e
                    }(bt),
                    Ct = function(t) {
                        function e(e) {
                            t.call(this), this.arrayList_ = e, this.position_ = 0
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.next = function() {
                            if (this.position_ === this.arrayList_.size()) throw new i;
                            return this.arrayList_.get(this.position_++)
                        }, e.prototype.hasNext = function() {
                            return this.position_ < this.arrayList_.size()
                        }, e.prototype.set = function(t) {
                            return this.arrayList_.set(this.position_ - 1, t)
                        }, e.prototype.remove = function() {
                            this.arrayList_.remove(this.arrayList_.get(this.position_))
                        }, e
                    }(xt),
                    It = function(t) {
                        function e() {
                            if (t.call(this), 0 === arguments.length);
                            else if (1 === arguments.length) {
                                var e = arguments[0];
                                this.ensureCapacity(e.length), this.add(e, !0)
                            } else if (2 === arguments.length) {
                                var n = arguments[0],
                                    i = arguments[1];
                                this.ensureCapacity(n.length), this.add(n, i)
                            }
                        }
                        t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
                        var n = {
                            coordArrayType: {
                                configurable: !0
                            }
                        };
                        return n.coordArrayType.get = function() {
                            return new Array(0).fill(null)
                        }, e.prototype.getCoordinate = function(t) {
                            return this.get(t)
                        }, e.prototype.addAll = function() {
                            if (2 === arguments.length) {
                                for (var e = arguments[0], n = arguments[1], i = !1, o = e.iterator(); o.hasNext();) this.add(o.next(), n), i = !0;
                                return i
                            }
                            return t.prototype.addAll.apply(this, arguments)
                        }, e.prototype.clone = function() {
                            for (var e = t.prototype.clone.call(this), n = 0; n < this.size(); n++) e.add(n, this.get(n).copy());
                            return e
                        }, e.prototype.toCoordinateArray = function() {
                            return this.toArray(e.coordArrayType)
                        }, e.prototype.add = function() {
                            if (1 === arguments.length) {
                                var e = arguments[0];
                                t.prototype.add.call(this, e)
                            } else if (2 === arguments.length) {
                                if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                                    var n = arguments[0],
                                        i = arguments[1];
                                    return this.add(n, i, !0), !0
                                }
                                if (arguments[0] instanceof C && "boolean" == typeof arguments[1]) {
                                    var o = arguments[0];
                                    if (!arguments[1] && this.size() >= 1 && this.get(this.size() - 1).equals2D(o)) return null;
                                    t.prototype.add.call(this, o)
                                } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
                                    var r = arguments[0],
                                        s = arguments[1];
                                    return this.add(r, s), !0
                                }
                            } else if (3 === arguments.length) {
                                if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                                    var a = arguments[0],
                                        h = arguments[1];
                                    if (arguments[2])
                                        for (var u = 0; u < a.length; u++) this.add(a[u], h);
                                    else
                                        for (var l = a.length - 1; l >= 0; l--) this.add(a[l], h);
                                    return !0
                                }
                                if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof C) {
                                    var c = arguments[0],
                                        p = arguments[1];
                                    if (!arguments[2]) {
                                        var f = this.size();
                                        if (f > 0) {
                                            if (c > 0 && this.get(c - 1).equals2D(p)) return null;
                                            if (c < f && this.get(c).equals2D(p)) return null
                                        }
                                    }
                                    t.prototype.add.call(this, c, p)
                                }
                            } else if (4 === arguments.length) {
                                var d = arguments[0],
                                    _ = arguments[1],
                                    g = arguments[2],
                                    m = arguments[3],
                                    y = 1;
                                g > m && (y = -1);
                                for (var v = g; v !== m; v += y) this.add(d[v], _);
                                return !0
                            }
                        }, e.prototype.closeRing = function() {
                            this.size() > 0 && this.add(new C(this.get(0)), !1)
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, Object.defineProperties(e, n), e
                    }(Et),
                    wt = function() {},
                    Mt = {
                        ForwardComparator: {
                            configurable: !0
                        },
                        BidirectionalComparator: {
                            configurable: !0
                        },
                        coordArrayType: {
                            configurable: !0
                        }
                    };
                Mt.ForwardComparator.get = function() {
                    return St
                }, Mt.BidirectionalComparator.get = function() {
                    return Pt
                }, Mt.coordArrayType.get = function() {
                    return new Array(0).fill(null)
                }, wt.prototype.interfaces_ = function() {
                    return []
                }, wt.prototype.getClass = function() {
                    return wt
                }, wt.isRing = function(t) {
                    return !(t.length < 4 || !t[0].equals2D(t[t.length - 1]))
                }, wt.ptNotInList = function(t, e) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        if (wt.indexOf(i, e) < 0) return i
                    }
                    return null
                }, wt.scroll = function(t, e) {
                    var n = wt.indexOf(e, t);
                    if (n < 0) return null;
                    var i = new Array(t.length).fill(null);
                    Z.arraycopy(t, n, i, 0, t.length - n), Z.arraycopy(t, 0, i, t.length - n, n), Z.arraycopy(i, 0, t, 0, t.length)
                }, wt.equals = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        if (t === e) return !0;
                        if (null === t || null === e) return !1;
                        if (t.length !== e.length) return !1;
                        for (var n = 0; n < t.length; n++)
                            if (!t[n].equals(e[n])) return !1;
                        return !0
                    }
                    if (3 === arguments.length) {
                        var i = arguments[0],
                            o = arguments[1],
                            r = arguments[2];
                        if (i === o) return !0;
                        if (null === i || null === o) return !1;
                        if (i.length !== o.length) return !1;
                        for (var s = 0; s < i.length; s++)
                            if (0 !== r.compare(i[s], o[s])) return !1;
                        return !0
                    }
                }, wt.intersection = function(t, e) {
                    for (var n = new It, i = 0; i < t.length; i++) e.intersects(t[i]) && n.add(t[i], !0);
                    return n.toCoordinateArray()
                }, wt.hasRepeatedPoints = function(t) {
                    for (var e = 1; e < t.length; e++)
                        if (t[e - 1].equals(t[e])) return !0;
                    return !1
                }, wt.removeRepeatedPoints = function(t) {
                    return wt.hasRepeatedPoints(t) ? new It(t, !1).toCoordinateArray() : t
                }, wt.reverse = function(t) {
                    for (var e = t.length - 1, n = Math.trunc(e / 2), i = 0; i <= n; i++) {
                        var o = t[i];
                        t[i] = t[e - i], t[e - i] = o
                    }
                }, wt.removeNull = function(t) {
                    for (var e = 0, n = 0; n < t.length; n++) null !== t[n] && e++;
                    var i = new Array(e).fill(null);
                    if (0 === e) return i;
                    for (var o = 0, r = 0; r < t.length; r++) null !== t[r] && (i[o++] = t[r]);
                    return i
                }, wt.copyDeep = function() {
                    if (1 === arguments.length) {
                        for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++) e[n] = new C(t[n]);
                        return e
                    }
                    if (5 === arguments.length)
                        for (var i = arguments[0], o = arguments[1], r = arguments[2], s = arguments[3], a = arguments[4], h = 0; h < a; h++) r[s + h] = new C(i[o + h])
                }, wt.isEqualReversed = function(t, e) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n],
                            o = e[t.length - n - 1];
                        if (0 !== i.compareTo(o)) return !1
                    }
                    return !0
                }, wt.envelope = function(t) {
                    for (var e = new H, n = 0; n < t.length; n++) e.expandToInclude(t[n]);
                    return e
                }, wt.toCoordinateArray = function(t) {
                    return t.toArray(wt.coordArrayType)
                }, wt.atLeastNCoordinatesOrNothing = function(t, e) {
                    return e.length >= t ? e : []
                }, wt.indexOf = function(t, e) {
                    for (var n = 0; n < e.length; n++)
                        if (t.equals(e[n])) return n;
                    return -1
                }, wt.increasingDirection = function(t) {
                    for (var e = 0; e < Math.trunc(t.length / 2); e++) {
                        var n = t.length - 1 - e,
                            i = t[e].compareTo(t[n]);
                        if (0 !== i) return i
                    }
                    return 1
                }, wt.compare = function(t, e) {
                    for (var n = 0; n < t.length && n < e.length;) {
                        var i = t[n].compareTo(e[n]);
                        if (0 !== i) return i;
                        n++
                    }
                    return n < e.length ? -1 : n < t.length ? 1 : 0
                }, wt.minCoordinate = function(t) {
                    for (var e = null, n = 0; n < t.length; n++)(null === e || e.compareTo(t[n]) > 0) && (e = t[n]);
                    return e
                }, wt.extract = function(t, e, n) {
                    e = T.clamp(e, 0, t.length);
                    var i = (n = T.clamp(n, -1, t.length)) - e + 1;
                    n < 0 && (i = 0), e >= t.length && (i = 0), n < e && (i = 0);
                    var o = new Array(i).fill(null);
                    if (0 === i) return o;
                    for (var r = 0, s = e; s <= n; s++) o[r++] = t[s];
                    return o
                }, Object.defineProperties(wt, Mt);
                var St = function() {};
                St.prototype.compare = function(t, e) {
                    return wt.compare(t, e)
                }, St.prototype.interfaces_ = function() {
                    return [E]
                }, St.prototype.getClass = function() {
                    return St
                };
                var Pt = function() {};
                Pt.prototype.compare = function(t, e) {
                    var n = t,
                        i = e;
                    if (n.length < i.length) return -1;
                    if (n.length > i.length) return 1;
                    if (0 === n.length) return 0;
                    var o = wt.compare(n, i);
                    return wt.isEqualReversed(n, i) ? 0 : o
                }, Pt.prototype.OLDcompare = function(t, e) {
                    var n = t,
                        i = e;
                    if (n.length < i.length) return -1;
                    if (n.length > i.length) return 1;
                    if (0 === n.length) return 0;
                    for (var o = wt.increasingDirection(n), r = wt.increasingDirection(i), s = o > 0 ? 0 : n.length - 1, a = r > 0 ? 0 : n.length - 1, h = 0; h < n.length; h++) {
                        var u = n[s].compareTo(i[a]);
                        if (0 !== u) return u;
                        s += o, a += r
                    }
                    return 0
                }, Pt.prototype.interfaces_ = function() {
                    return [E]
                }, Pt.prototype.getClass = function() {
                    return Pt
                };
                var Nt = function() {};
                Nt.prototype.get = function() {}, Nt.prototype.put = function() {}, Nt.prototype.size = function() {}, Nt.prototype.values = function() {}, Nt.prototype.entrySet = function() {};
                var Tt = function(t) {
                    function e() {
                        t.apply(this, arguments)
                    }
                    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e
                }(Nt);
                (o.prototype = new Error).name = "OperationNotSupported", (r.prototype = new Lt).contains = function() {};
                var Ot = function(t) {
                        function e() {
                            t.call(this), this.array_ = [], arguments[0] instanceof Lt && this.addAll(arguments[0])
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.contains = function(t) {
                            for (var e = 0, n = this.array_.length; e < n; e++)
                                if (this.array_[e] === t) return !0;
                            return !1
                        }, e.prototype.add = function(t) {
                            return !this.contains(t) && (this.array_.push(t), !0)
                        }, e.prototype.addAll = function(t) {
                            for (var e = t.iterator(); e.hasNext();) this.add(e.next());
                            return !0
                        }, e.prototype.remove = function(t) {
                            throw new Error
                        }, e.prototype.size = function() {
                            return this.array_.length
                        }, e.prototype.isEmpty = function() {
                            return 0 === this.array_.length
                        }, e.prototype.toArray = function() {
                            for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);
                            return t
                        }, e.prototype.iterator = function() {
                            return new At(this)
                        }, e
                    }(r),
                    At = function(t) {
                        function e(e) {
                            t.call(this), this.hashSet_ = e, this.position_ = 0
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.next = function() {
                            if (this.position_ === this.hashSet_.size()) throw new i;
                            return this.hashSet_.array_[this.position_++]
                        }, e.prototype.hasNext = function() {
                            return this.position_ < this.hashSet_.size()
                        }, e.prototype.remove = function() {
                            throw new o
                        }, e
                    }(xt),
                    Rt = 0;
                (c.prototype = new Tt).get = function(t) {
                    for (var e = this.root_; null !== e;) {
                        var n = t.compareTo(e.key);
                        if (n < 0) e = e.left;
                        else {
                            if (!(n > 0)) return e.value;
                            e = e.right
                        }
                    }
                    return null
                }, c.prototype.put = function(t, e) {
                    if (null === this.root_) return this.root_ = {
                        key: t,
                        value: e,
                        left: null,
                        right: null,
                        parent: null,
                        color: Rt,
                        getValue: function() {
                            return this.value
                        },
                        getKey: function() {
                            return this.key
                        }
                    }, this.size_ = 1, null;
                    var n, i, o = this.root_;
                    do {
                        if (n = o, (i = t.compareTo(o.key)) < 0) o = o.left;
                        else {
                            if (!(i > 0)) {
                                var r = o.value;
                                return o.value = e, r
                            }
                            o = o.right
                        }
                    } while (null !== o);
                    var s = {
                        key: t,
                        left: null,
                        right: null,
                        value: e,
                        parent: n,
                        color: Rt,
                        getValue: function() {
                            return this.value
                        },
                        getKey: function() {
                            return this.key
                        }
                    };
                    return i < 0 ? n.left = s : n.right = s, this.fixAfterInsertion(s), this.size_++, null
                }, c.prototype.fixAfterInsertion = function(t) {
                    for (t.color = 1; null != t && t !== this.root_ && 1 === t.parent.color;)
                        if (a(t) === u(a(a(t)))) {
                            var e = l(a(a(t)));
                            1 === s(e) ? (h(a(t), Rt), h(e, Rt), h(a(a(t)), 1), t = a(a(t))) : (t === l(a(t)) && (t = a(t), this.rotateLeft(t)), h(a(t), Rt), h(a(a(t)), 1), this.rotateRight(a(a(t))))
                        } else {
                            var n = u(a(a(t)));
                            1 === s(n) ? (h(a(t), Rt), h(n, Rt), h(a(a(t)), 1), t = a(a(t))) : (t === u(a(t)) && (t = a(t), this.rotateRight(t)), h(a(t), Rt), h(a(a(t)), 1), this.rotateLeft(a(a(t))))
                        }
                    this.root_.color = Rt
                }, c.prototype.values = function() {
                    var t = new Et,
                        e = this.getFirstEntry();
                    if (null !== e)
                        for (t.add(e.value); null !== (e = c.successor(e));) t.add(e.value);
                    return t
                }, c.prototype.entrySet = function() {
                    var t = new Ot,
                        e = this.getFirstEntry();
                    if (null !== e)
                        for (t.add(e); null !== (e = c.successor(e));) t.add(e);
                    return t
                }, c.prototype.rotateLeft = function(t) {
                    if (null != t) {
                        var e = t.right;
                        t.right = e.left, null != e.left && (e.left.parent = t), e.parent = t.parent, null === t.parent ? this.root_ = e : t.parent.left === t ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e
                    }
                }, c.prototype.rotateRight = function(t) {
                    if (null != t) {
                        var e = t.left;
                        t.left = e.right, null != e.right && (e.right.parent = t), e.parent = t.parent, null === t.parent ? this.root_ = e : t.parent.right === t ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e
                    }
                }, c.prototype.getFirstEntry = function() {
                    var t = this.root_;
                    if (null != t)
                        for (; null != t.left;) t = t.left;
                    return t
                }, c.successor = function(t) {
                    if (null === t) return null;
                    if (null !== t.right) {
                        for (var e = t.right; null !== e.left;) e = e.left;
                        return e
                    }
                    for (var n = t.parent, i = t; null !== n && i === n.right;) i = n, n = n.parent;
                    return n
                }, c.prototype.size = function() {
                    return this.size_
                };
                var Dt = function() {};
                Dt.prototype.interfaces_ = function() {
                    return []
                }, Dt.prototype.getClass = function() {
                    return Dt
                }, p.prototype = new r, (f.prototype = new p).contains = function(t) {
                    for (var e = 0, n = this.array_.length; e < n; e++)
                        if (0 === this.array_[e].compareTo(t)) return !0;
                    return !1
                }, f.prototype.add = function(t) {
                    if (this.contains(t)) return !1;
                    for (var e = 0, n = this.array_.length; e < n; e++)
                        if (1 === this.array_[e].compareTo(t)) return this.array_.splice(e, 0, t), !0;
                    return this.array_.push(t), !0
                }, f.prototype.addAll = function(t) {
                    for (var e = t.iterator(); e.hasNext();) this.add(e.next());
                    return !0
                }, f.prototype.remove = function(t) {
                    throw new o
                }, f.prototype.size = function() {
                    return this.array_.length
                }, f.prototype.isEmpty = function() {
                    return 0 === this.array_.length
                }, f.prototype.toArray = function() {
                    for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);
                    return t
                }, f.prototype.iterator = function() {
                    return new kt(this)
                };
                var kt = function(t) {
                    this.treeSet_ = t, this.position_ = 0
                };
                kt.prototype.next = function() {
                    if (this.position_ === this.treeSet_.size()) throw new i;
                    return this.treeSet_.array_[this.position_++]
                }, kt.prototype.hasNext = function() {
                    return this.position_ < this.treeSet_.size()
                }, kt.prototype.remove = function() {
                    throw new o
                };
                var Ft = function() {};
                Ft.sort = function() {
                    var t, e, n, i, o = arguments[0];
                    if (1 === arguments.length) i = function(t, e) {
                        return t.compareTo(e)
                    }, o.sort(i);
                    else if (2 === arguments.length) n = arguments[1], i = function(t, e) {
                        return n.compare(t, e)
                    }, o.sort(i);
                    else if (3 === arguments.length) {
                        (e = o.slice(arguments[1], arguments[2])).sort();
                        var r = o.slice(0, arguments[1]).concat(e, o.slice(arguments[2], o.length));
                        for (o.splice(0, o.length), t = 0; t < r.length; t++) o.push(r[t])
                    } else if (4 === arguments.length)
                        for (e = o.slice(arguments[1], arguments[2]), n = arguments[3], i = function(t, e) {
                            return n.compare(t, e)
                        }, e.sort(i), r = o.slice(0, arguments[1]).concat(e, o.slice(arguments[2], o.length)), o.splice(0, o.length), t = 0; t < r.length; t++) o.push(r[t])
                }, Ft.asList = function(t) {
                    for (var e = new Et, n = 0, i = t.length; n < i; n++) e.add(t[n]);
                    return e
                };
                var zt = function() {},
                    Bt = {
                        P: {
                            configurable: !0
                        },
                        L: {
                            configurable: !0
                        },
                        A: {
                            configurable: !0
                        },
                        FALSE: {
                            configurable: !0
                        },
                        TRUE: {
                            configurable: !0
                        },
                        DONTCARE: {
                            configurable: !0
                        },
                        SYM_FALSE: {
                            configurable: !0
                        },
                        SYM_TRUE: {
                            configurable: !0
                        },
                        SYM_DONTCARE: {
                            configurable: !0
                        },
                        SYM_P: {
                            configurable: !0
                        },
                        SYM_L: {
                            configurable: !0
                        },
                        SYM_A: {
                            configurable: !0
                        }
                    };
                Bt.P.get = function() {
                    return 0
                }, Bt.L.get = function() {
                    return 1
                }, Bt.A.get = function() {
                    return 2
                }, Bt.FALSE.get = function() {
                    return -1
                }, Bt.TRUE.get = function() {
                    return -2
                }, Bt.DONTCARE.get = function() {
                    return -3
                }, Bt.SYM_FALSE.get = function() {
                    return "F"
                }, Bt.SYM_TRUE.get = function() {
                    return "T"
                }, Bt.SYM_DONTCARE.get = function() {
                    return "*"
                }, Bt.SYM_P.get = function() {
                    return "0"
                }, Bt.SYM_L.get = function() {
                    return "1"
                }, Bt.SYM_A.get = function() {
                    return "2"
                }, zt.prototype.interfaces_ = function() {
                    return []
                }, zt.prototype.getClass = function() {
                    return zt
                }, zt.toDimensionSymbol = function(t) {
                    switch (t) {
                        case zt.FALSE:
                            return zt.SYM_FALSE;
                        case zt.TRUE:
                            return zt.SYM_TRUE;
                        case zt.DONTCARE:
                            return zt.SYM_DONTCARE;
                        case zt.P:
                            return zt.SYM_P;
                        case zt.L:
                            return zt.SYM_L;
                        case zt.A:
                            return zt.SYM_A
                    }
                    throw new y("Unknown dimension value: " + t)
                }, zt.toDimensionValue = function(t) {
                    switch (D.toUpperCase(t)) {
                        case zt.SYM_FALSE:
                            return zt.FALSE;
                        case zt.SYM_TRUE:
                            return zt.TRUE;
                        case zt.SYM_DONTCARE:
                            return zt.DONTCARE;
                        case zt.SYM_P:
                            return zt.P;
                        case zt.SYM_L:
                            return zt.L;
                        case zt.SYM_A:
                            return zt.A
                    }
                    throw new y("Unknown dimension symbol: " + t)
                }, Object.defineProperties(zt, Bt);
                var Gt = function() {};
                Gt.prototype.filter = function(t) {}, Gt.prototype.interfaces_ = function() {
                    return []
                }, Gt.prototype.getClass = function() {
                    return Gt
                };
                var Ut = function() {};
                Ut.prototype.filter = function(t, e) {}, Ut.prototype.isDone = function() {}, Ut.prototype.isGeometryChanged = function() {}, Ut.prototype.interfaces_ = function() {
                    return []
                }, Ut.prototype.getClass = function() {
                    return Ut
                };
                var jt = function(t) {
                        function e(e, n) {
                            if (t.call(this, n), this._geometries = e || [], t.hasNullElements(this._geometries)) throw new y("geometries must not contain null elements")
                        }
                        t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
                        var n = {
                            serialVersionUID: {
                                configurable: !0
                            }
                        };
                        return e.prototype.computeEnvelopeInternal = function() {
                            for (var t = new H, e = 0; e < this._geometries.length; e++) t.expandToInclude(this._geometries[e].getEnvelopeInternal());
                            return t
                        }, e.prototype.getGeometryN = function(t) {
                            return this._geometries[t]
                        }, e.prototype.getSortIndex = function() {
                            return t.SORTINDEX_GEOMETRYCOLLECTION
                        }, e.prototype.getCoordinates = function() {
                            for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = 0; n < this._geometries.length; n++)
                                for (var i = this._geometries[n].getCoordinates(), o = 0; o < i.length; o++) t[++e] = i[o];
                            return t
                        }, e.prototype.getArea = function() {
                            for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getArea();
                            return t
                        }, e.prototype.equalsExact = function() {
                            if (2 === arguments.length) {
                                var e = arguments[0],
                                    n = arguments[1];
                                if (!this.isEquivalentClass(e)) return !1;
                                var i = e;
                                if (this._geometries.length !== i._geometries.length) return !1;
                                for (var o = 0; o < this._geometries.length; o++)
                                    if (!this._geometries[o].equalsExact(i._geometries[o], n)) return !1;
                                return !0
                            }
                            return t.prototype.equalsExact.apply(this, arguments)
                        }, e.prototype.normalize = function() {
                            for (var t = 0; t < this._geometries.length; t++) this._geometries[t].normalize();
                            Ft.sort(this._geometries)
                        }, e.prototype.getCoordinate = function() {
                            return this.isEmpty() ? null : this._geometries[0].getCoordinate()
                        }, e.prototype.getBoundaryDimension = function() {
                            for (var t = zt.FALSE, e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getBoundaryDimension());
                            return t
                        }, e.prototype.getDimension = function() {
                            for (var t = zt.FALSE, e = 0; e < this._geometries.length; e++) t = Math.max(t, this._geometries[e].getDimension());
                            return t
                        }, e.prototype.getLength = function() {
                            for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getLength();
                            return t
                        }, e.prototype.getNumPoints = function() {
                            for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getNumPoints();
                            return t
                        }, e.prototype.getNumGeometries = function() {
                            return this._geometries.length
                        }, e.prototype.reverse = function() {
                            for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++) e[n] = this._geometries[n].reverse();
                            return this.getFactory().createGeometryCollection(e)
                        }, e.prototype.compareToSameClass = function() {
                            if (1 === arguments.length) {
                                var t = arguments[0],
                                    e = new f(Ft.asList(this._geometries)),
                                    n = new f(Ft.asList(t._geometries));
                                return this.compare(e, n)
                            }
                            if (2 === arguments.length) {
                                for (var i = arguments[0], o = arguments[1], r = i, s = this.getNumGeometries(), a = r.getNumGeometries(), h = 0; h < s && h < a;) {
                                    var u = this.getGeometryN(h),
                                        l = r.getGeometryN(h),
                                        c = u.compareToSameClass(l, o);
                                    if (0 !== c) return c;
                                    h++
                                }
                                return h < s ? 1 : h < a ? -1 : 0
                            }
                        }, e.prototype.apply = function() {
                            if (N(arguments[0], ft))
                                for (var t = arguments[0], e = 0; e < this._geometries.length; e++) this._geometries[e].apply(t);
                            else if (N(arguments[0], Ut)) {
                                var n = arguments[0];
                                if (0 === this._geometries.length) return null;
                                for (var i = 0; i < this._geometries.length && (this._geometries[i].apply(n), !n.isDone()); i++);
                                n.isGeometryChanged() && this.geometryChanged()
                            } else if (N(arguments[0], Gt)) {
                                var o = arguments[0];
                                o.filter(this);
                                for (var r = 0; r < this._geometries.length; r++) this._geometries[r].apply(o)
                            } else if (N(arguments[0], ut)) {
                                var s = arguments[0];
                                s.filter(this);
                                for (var a = 0; a < this._geometries.length; a++) this._geometries[a].apply(s)
                            }
                        }, e.prototype.getBoundary = function() {
                            return this.checkNotGeometryCollection(this), et.shouldNeverReachHere(), null
                        }, e.prototype.clone = function() {
                            var e = t.prototype.clone.call(this);
                            e._geometries = new Array(this._geometries.length).fill(null);
                            for (var n = 0; n < this._geometries.length; n++) e._geometries[n] = this._geometries[n].clone();
                            return e
                        }, e.prototype.getGeometryType = function() {
                            return "GeometryCollection"
                        }, e.prototype.copy = function() {
                            for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++) t[n] = this._geometries[n].copy();
                            return new e(t, this._factory)
                        }, e.prototype.isEmpty = function() {
                            for (var t = 0; t < this._geometries.length; t++)
                                if (!this._geometries[t].isEmpty()) return !1;
                            return !0
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, n.serialVersionUID.get = function() {
                            return -0x4f07bcb1f857d800
                        }, Object.defineProperties(e, n), e
                    }(lt),
                    qt = function(t) {
                        function e() {
                            t.apply(this, arguments)
                        }
                        t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
                        var n = {
                            serialVersionUID: {
                                configurable: !0
                            }
                        };
                        return e.prototype.getSortIndex = function() {
                            return lt.SORTINDEX_MULTILINESTRING
                        }, e.prototype.equalsExact = function() {
                            if (2 === arguments.length) {
                                var e = arguments[0],
                                    n = arguments[1];
                                return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n)
                            }
                            return t.prototype.equalsExact.apply(this, arguments)
                        }, e.prototype.getBoundaryDimension = function() {
                            return this.isClosed() ? zt.FALSE : 0
                        }, e.prototype.isClosed = function() {
                            if (this.isEmpty()) return !1;
                            for (var t = 0; t < this._geometries.length; t++)
                                if (!this._geometries[t].isClosed()) return !1;
                            return !0
                        }, e.prototype.getDimension = function() {
                            return 1
                        }, e.prototype.reverse = function() {
                            for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++) e[t - 1 - n] = this._geometries[n].reverse();
                            return this.getFactory().createMultiLineString(e)
                        }, e.prototype.getBoundary = function() {
                            return new Zt(this).getBoundary()
                        }, e.prototype.getGeometryType = function() {
                            return "MultiLineString"
                        }, e.prototype.copy = function() {
                            for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++) t[n] = this._geometries[n].copy();
                            return new e(t, this._factory)
                        }, e.prototype.interfaces_ = function() {
                            return [Dt]
                        }, e.prototype.getClass = function() {
                            return e
                        }, n.serialVersionUID.get = function() {
                            return 0x7155d2ab4afa8000
                        }, Object.defineProperties(e, n), e
                    }(jt),
                    Zt = function() {
                        if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, 1 === arguments.length) {
                            var t = arguments[0],
                                e = dt.MOD2_BOUNDARY_RULE;
                            this._geom = t, this._geomFact = t.getFactory(), this._bnRule = e
                        } else if (2 === arguments.length) {
                            var n = arguments[0],
                                i = arguments[1];
                            this._geom = n, this._geomFact = n.getFactory(), this._bnRule = i
                        }
                    };
                Zt.prototype.boundaryMultiLineString = function(t) {
                    if (this._geom.isEmpty()) return this.getEmptyMultiPoint();
                    var e = this.computeBoundaryCoordinates(t);
                    return 1 === e.length ? this._geomFact.createPoint(e[0]) : this._geomFact.createMultiPointFromCoords(e)
                }, Zt.prototype.getBoundary = function() {
                    return this._geom instanceof Xt ? this.boundaryLineString(this._geom) : this._geom instanceof qt ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary()
                }, Zt.prototype.boundaryLineString = function(t) {
                    return this._geom.isEmpty() ? this.getEmptyMultiPoint() : t.isClosed() ? this._bnRule.isInBoundary(2) ? t.getStartPoint() : this._geomFact.createMultiPoint() : this._geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()])
                }, Zt.prototype.getEmptyMultiPoint = function() {
                    return this._geomFact.createMultiPoint()
                }, Zt.prototype.computeBoundaryCoordinates = function(t) {
                    var e = new Et;
                    this._endpointMap = new c;
                    for (var n = 0; n < t.getNumGeometries(); n++) {
                        var i = t.getGeometryN(n);
                        0 !== i.getNumPoints() && (this.addEndpoint(i.getCoordinateN(0)), this.addEndpoint(i.getCoordinateN(i.getNumPoints() - 1)))
                    }
                    for (var o = this._endpointMap.entrySet().iterator(); o.hasNext();) {
                        var r = o.next(),
                            s = r.getValue().count;
                        this._bnRule.isInBoundary(s) && e.add(r.getKey())
                    }
                    return wt.toCoordinateArray(e)
                }, Zt.prototype.addEndpoint = function(t) {
                    var e = this._endpointMap.get(t);
                    null === e && (e = new Vt, this._endpointMap.put(t, e)), e.count++
                }, Zt.prototype.interfaces_ = function() {
                    return []
                }, Zt.prototype.getClass = function() {
                    return Zt
                }, Zt.getBoundary = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return new Zt(t).getBoundary()
                    }
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        return new Zt(e, n).getBoundary()
                    }
                };
                var Vt = function() {
                    this.count = null
                };
                Vt.prototype.interfaces_ = function() {
                    return []
                }, Vt.prototype.getClass = function() {
                    return Vt
                };
                var Ht = function() {},
                    Yt = {
                        NEWLINE: {
                            configurable: !0
                        },
                        SIMPLE_ORDINATE_FORMAT: {
                            configurable: !0
                        }
                    };
                Ht.prototype.interfaces_ = function() {
                    return []
                }, Ht.prototype.getClass = function() {
                    return Ht
                }, Ht.chars = function(t, e) {
                    for (var n = new Array(e).fill(null), i = 0; i < e; i++) n[i] = t;
                    return String(n)
                }, Ht.getStackTrace = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0],
                            e = new function() {},
                            n = new function() {}(e);
                        return t.printStackTrace(n), e.toString()
                    }
                    if (2 === arguments.length) {
                        for (var i = arguments[0], o = arguments[1], r = "", s = new function() {}(new function() {}(Ht.getStackTrace(i))), a = 0; a < o; a++) try {
                            r += s.readLine() + Ht.NEWLINE
                        } catch (t) {
                            if (!(t instanceof d)) throw t;
                            et.shouldNeverReachHere()
                        }
                        return r
                    }
                }, Ht.split = function(t, e) {
                    for (var n = e.length, i = new Et, o = "" + t, r = o.indexOf(e); r >= 0;) {
                        var s = o.substring(0, r);
                        i.add(s), r = (o = o.substring(r + n)).indexOf(e)
                    }
                    o.length > 0 && i.add(o);
                    for (var a = new Array(i.size()).fill(null), h = 0; h < a.length; h++) a[h] = i.get(h);
                    return a
                }, Ht.toString = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return Ht.SIMPLE_ORDINATE_FORMAT.format(t)
                    }
                }, Ht.spaces = function(t) {
                    return Ht.chars(" ", t)
                }, Yt.NEWLINE.get = function() {
                    return Z.getProperty("line.separator")
                }, Yt.SIMPLE_ORDINATE_FORMAT.get = function() {
                    return new function() {}("0.#")
                }, Object.defineProperties(Ht, Yt);
                var Wt = function() {};
                Wt.prototype.interfaces_ = function() {
                    return []
                }, Wt.prototype.getClass = function() {
                    return Wt
                }, Wt.copyCoord = function(t, e, n, i) {
                    for (var o = Math.min(t.getDimension(), n.getDimension()), r = 0; r < o; r++) n.setOrdinate(i, r, t.getOrdinate(e, r))
                }, Wt.isRing = function(t) {
                    var e = t.size();
                    return 0 === e || !(e <= 3) && t.getOrdinate(0, G.X) === t.getOrdinate(e - 1, G.X) && t.getOrdinate(0, G.Y) === t.getOrdinate(e - 1, G.Y)
                }, Wt.isEqual = function(t, e) {
                    var n = t.size();
                    if (n !== e.size()) return !1;
                    for (var i = Math.min(t.getDimension(), e.getDimension()), o = 0; o < n; o++)
                        for (var r = 0; r < i; r++) {
                            var s = t.getOrdinate(o, r),
                                a = e.getOrdinate(o, r);
                            if (!(t.getOrdinate(o, r) === e.getOrdinate(o, r) || v.isNaN(s) && v.isNaN(a))) return !1
                        }
                    return !0
                }, Wt.extend = function(t, e, n) {
                    var i = t.create(n, e.getDimension()),
                        o = e.size();
                    if (Wt.copy(e, 0, i, 0, o), o > 0)
                        for (var r = o; r < n; r++) Wt.copy(e, o - 1, i, r, 1);
                    return i
                }, Wt.reverse = function(t) {
                    for (var e = t.size() - 1, n = Math.trunc(e / 2), i = 0; i <= n; i++) Wt.swap(t, i, e - i)
                }, Wt.swap = function(t, e, n) {
                    if (e === n) return null;
                    for (var i = 0; i < t.getDimension(); i++) {
                        var o = t.getOrdinate(e, i);
                        t.setOrdinate(e, i, t.getOrdinate(n, i)), t.setOrdinate(n, i, o)
                    }
                }, Wt.copy = function(t, e, n, i, o) {
                    for (var r = 0; r < o; r++) Wt.copyCoord(t, e + r, n, i + r)
                }, Wt.toString = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0],
                            e = t.size();
                        if (0 === e) return "()";
                        var n = t.getDimension(),
                            i = new A;
                        i.append("(");
                        for (var o = 0; o < e; o++) {
                            o > 0 && i.append(" ");
                            for (var r = 0; r < n; r++) r > 0 && i.append(","), i.append(Ht.toString(t.getOrdinate(o, r)))
                        }
                        return i.append(")"), i.toString()
                    }
                }, Wt.ensureValidRing = function(t, e) {
                    var n = e.size();
                    return 0 === n ? e : n <= 3 ? Wt.createClosedRing(t, e, 4) : e.getOrdinate(0, G.X) === e.getOrdinate(n - 1, G.X) && e.getOrdinate(0, G.Y) === e.getOrdinate(n - 1, G.Y) ? e : Wt.createClosedRing(t, e, n + 1)
                }, Wt.createClosedRing = function(t, e, n) {
                    var i = t.create(n, e.getDimension()),
                        o = e.size();
                    Wt.copy(e, 0, i, 0, o);
                    for (var r = o; r < n; r++) Wt.copy(e, 0, i, r, 1);
                    return i
                };
                var Xt = function(t) {
                        function e(e, n) {
                            t.call(this, n), this._points = null, this.init(e)
                        }
                        t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
                        var n = {
                            serialVersionUID: {
                                configurable: !0
                            }
                        };
                        return e.prototype.computeEnvelopeInternal = function() {
                            return this.isEmpty() ? new H : this._points.expandEnvelope(new H)
                        }, e.prototype.isRing = function() {
                            return this.isClosed() && this.isSimple()
                        }, e.prototype.getSortIndex = function() {
                            return t.SORTINDEX_LINESTRING
                        }, e.prototype.getCoordinates = function() {
                            return this._points.toCoordinateArray()
                        }, e.prototype.equalsExact = function() {
                            if (2 === arguments.length) {
                                var e = arguments[0],
                                    n = arguments[1];
                                if (!this.isEquivalentClass(e)) return !1;
                                var i = e;
                                if (this._points.size() !== i._points.size()) return !1;
                                for (var o = 0; o < this._points.size(); o++)
                                    if (!this.equal(this._points.getCoordinate(o), i._points.getCoordinate(o), n)) return !1;
                                return !0
                            }
                            return t.prototype.equalsExact.apply(this, arguments)
                        }, e.prototype.normalize = function() {
                            for (var t = 0; t < Math.trunc(this._points.size() / 2); t++) {
                                var e = this._points.size() - 1 - t;
                                if (!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))) return this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e)) > 0 && Wt.reverse(this._points), null
                            }
                        }, e.prototype.getCoordinate = function() {
                            return this.isEmpty() ? null : this._points.getCoordinate(0)
                        }, e.prototype.getBoundaryDimension = function() {
                            return this.isClosed() ? zt.FALSE : 0
                        }, e.prototype.isClosed = function() {
                            return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))
                        }, e.prototype.getEndPoint = function() {
                            return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1)
                        }, e.prototype.getDimension = function() {
                            return 1
                        }, e.prototype.getLength = function() {
                            return at.computeLength(this._points)
                        }, e.prototype.getNumPoints = function() {
                            return this._points.size()
                        }, e.prototype.reverse = function() {
                            var t = this._points.copy();
                            return Wt.reverse(t), this.getFactory().createLineString(t)
                        }, e.prototype.compareToSameClass = function() {
                            if (1 === arguments.length) {
                                for (var t = arguments[0], e = 0, n = 0; e < this._points.size() && n < t._points.size();) {
                                    var i = this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));
                                    if (0 !== i) return i;
                                    e++, n++
                                }
                                return e < this._points.size() ? 1 : n < t._points.size() ? -1 : 0
                            }
                            if (2 === arguments.length) {
                                var o = arguments[0];
                                return arguments[1].compare(this._points, o._points)
                            }
                        }, e.prototype.apply = function() {
                            if (N(arguments[0], ft))
                                for (var t = arguments[0], e = 0; e < this._points.size(); e++) t.filter(this._points.getCoordinate(e));
                            else if (N(arguments[0], Ut)) {
                                var n = arguments[0];
                                if (0 === this._points.size()) return null;
                                for (var i = 0; i < this._points.size() && (n.filter(this._points, i), !n.isDone()); i++);
                                n.isGeometryChanged() && this.geometryChanged()
                            } else N(arguments[0], Gt) ? arguments[0].filter(this) : N(arguments[0], ut) && arguments[0].filter(this)
                        }, e.prototype.getBoundary = function() {
                            return new Zt(this).getBoundary()
                        }, e.prototype.isEquivalentClass = function(t) {
                            return t instanceof e
                        }, e.prototype.clone = function() {
                            var e = t.prototype.clone.call(this);
                            return e._points = this._points.clone(), e
                        }, e.prototype.getCoordinateN = function(t) {
                            return this._points.getCoordinate(t)
                        }, e.prototype.getGeometryType = function() {
                            return "LineString"
                        }, e.prototype.copy = function() {
                            return new e(this._points.copy(), this._factory)
                        }, e.prototype.getCoordinateSequence = function() {
                            return this._points
                        }, e.prototype.isEmpty = function() {
                            return 0 === this._points.size()
                        }, e.prototype.init = function(t) {
                            if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size()) throw new y("Invalid number of points in LineString (found " + t.size() + " - must be 0 or >= 2)");
                            this._points = t
                        }, e.prototype.isCoordinate = function(t) {
                            for (var e = 0; e < this._points.size(); e++)
                                if (this._points.getCoordinate(e).equals(t)) return !0;
                            return !1
                        }, e.prototype.getStartPoint = function() {
                            return this.isEmpty() ? null : this.getPointN(0)
                        }, e.prototype.getPointN = function(t) {
                            return this.getFactory().createPoint(this._points.getCoordinate(t))
                        }, e.prototype.interfaces_ = function() {
                            return [Dt]
                        }, e.prototype.getClass = function() {
                            return e
                        }, n.serialVersionUID.get = function() {
                            return 0x2b2b51ba435c8e00
                        }, Object.defineProperties(e, n), e
                    }(lt),
                    Jt = function() {};
                Jt.prototype.interfaces_ = function() {
                    return []
                }, Jt.prototype.getClass = function() {
                    return Jt
                };
                var Kt = function(t) {
                        function e(e, n) {
                            t.call(this, n), this._coordinates = e || null, this.init(this._coordinates)
                        }
                        t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
                        var n = {
                            serialVersionUID: {
                                configurable: !0
                            }
                        };
                        return e.prototype.computeEnvelopeInternal = function() {
                            if (this.isEmpty()) return new H;
                            var t = new H;
                            return t.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t
                        }, e.prototype.getSortIndex = function() {
                            return t.SORTINDEX_POINT
                        }, e.prototype.getCoordinates = function() {
                            return this.isEmpty() ? [] : [this.getCoordinate()]
                        }, e.prototype.equalsExact = function() {
                            if (2 === arguments.length) {
                                var e = arguments[0],
                                    n = arguments[1];
                                return !!this.isEquivalentClass(e) && (!(!this.isEmpty() || !e.isEmpty()) || this.isEmpty() === e.isEmpty() && this.equal(e.getCoordinate(), this.getCoordinate(), n))
                            }
                            return t.prototype.equalsExact.apply(this, arguments)
                        }, e.prototype.normalize = function() {}, e.prototype.getCoordinate = function() {
                            return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null
                        }, e.prototype.getBoundaryDimension = function() {
                            return zt.FALSE
                        }, e.prototype.getDimension = function() {
                            return 0
                        }, e.prototype.getNumPoints = function() {
                            return this.isEmpty() ? 0 : 1
                        }, e.prototype.reverse = function() {
                            return this.copy()
                        }, e.prototype.getX = function() {
                            if (null === this.getCoordinate()) throw new Error("getX called on empty Point");
                            return this.getCoordinate().x
                        }, e.prototype.compareToSameClass = function() {
                            if (1 === arguments.length) {
                                var t = arguments[0];
                                return this.getCoordinate().compareTo(t.getCoordinate())
                            }
                            if (2 === arguments.length) {
                                var e = arguments[0];
                                return arguments[1].compare(this._coordinates, e._coordinates)
                            }
                        }, e.prototype.apply = function() {
                            if (N(arguments[0], ft)) {
                                var t = arguments[0];
                                if (this.isEmpty()) return null;
                                t.filter(this.getCoordinate())
                            } else if (N(arguments[0], Ut)) {
                                var e = arguments[0];
                                if (this.isEmpty()) return null;
                                e.filter(this._coordinates, 0), e.isGeometryChanged() && this.geometryChanged()
                            } else N(arguments[0], Gt) ? arguments[0].filter(this) : N(arguments[0], ut) && arguments[0].filter(this)
                        }, e.prototype.getBoundary = function() {
                            return this.getFactory().createGeometryCollection(null)
                        }, e.prototype.clone = function() {
                            var e = t.prototype.clone.call(this);
                            return e._coordinates = this._coordinates.clone(), e
                        }, e.prototype.getGeometryType = function() {
                            return "Point"
                        }, e.prototype.copy = function() {
                            return new e(this._coordinates.copy(), this._factory)
                        }, e.prototype.getCoordinateSequence = function() {
                            return this._coordinates
                        }, e.prototype.getY = function() {
                            if (null === this.getCoordinate()) throw new Error("getY called on empty Point");
                            return this.getCoordinate().y
                        }, e.prototype.isEmpty = function() {
                            return 0 === this._coordinates.size()
                        }, e.prototype.init = function(t) {
                            null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), et.isTrue(t.size() <= 1), this._coordinates = t
                        }, e.prototype.isSimple = function() {
                            return !0
                        }, e.prototype.interfaces_ = function() {
                            return [Jt]
                        }, e.prototype.getClass = function() {
                            return e
                        }, n.serialVersionUID.get = function() {
                            return 0x44077bad161cbc00
                        }, Object.defineProperties(e, n), e
                    }(lt),
                    Qt = function() {};
                Qt.prototype.interfaces_ = function() {
                    return []
                }, Qt.prototype.getClass = function() {
                    return Qt
                };
                var $t = function(t) {
                        function e(e, n, i) {
                            if (t.call(this, i), this._shell = null, this._holes = null, null === e && (e = this.getFactory().createLinearRing()), null === n && (n = []), t.hasNullElements(n)) throw new y("holes must not contain null elements");
                            if (e.isEmpty() && t.hasNonEmptyElements(n)) throw new y("shell is empty but holes are not");
                            this._shell = e, this._holes = n
                        }
                        t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
                        var n = {
                            serialVersionUID: {
                                configurable: !0
                            }
                        };
                        return e.prototype.computeEnvelopeInternal = function() {
                            return this._shell.getEnvelopeInternal()
                        }, e.prototype.getSortIndex = function() {
                            return t.SORTINDEX_POLYGON
                        }, e.prototype.getCoordinates = function() {
                            if (this.isEmpty()) return [];
                            for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = this._shell.getCoordinates(), i = 0; i < n.length; i++) t[++e] = n[i];
                            for (var o = 0; o < this._holes.length; o++)
                                for (var r = this._holes[o].getCoordinates(), s = 0; s < r.length; s++) t[++e] = r[s];
                            return t
                        }, e.prototype.getArea = function() {
                            var t = 0;
                            t += Math.abs(at.signedArea(this._shell.getCoordinateSequence()));
                            for (var e = 0; e < this._holes.length; e++) t -= Math.abs(at.signedArea(this._holes[e].getCoordinateSequence()));
                            return t
                        }, e.prototype.isRectangle = function() {
                            if (0 !== this.getNumInteriorRing()) return !1;
                            if (null === this._shell) return !1;
                            if (5 !== this._shell.getNumPoints()) return !1;
                            for (var t = this._shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0; n < 5; n++) {
                                var i = t.getX(n);
                                if (i !== e.getMinX() && i !== e.getMaxX()) return !1;
                                var o = t.getY(n);
                                if (o !== e.getMinY() && o !== e.getMaxY()) return !1
                            }
                            for (var r = t.getX(0), s = t.getY(0), a = 1; a <= 4; a++) {
                                var h = t.getX(a),
                                    u = t.getY(a);
                                if (h !== r == (u !== s)) return !1;
                                r = h, s = u
                            }
                            return !0
                        }, e.prototype.equalsExact = function() {
                            if (2 === arguments.length) {
                                var e = arguments[0],
                                    n = arguments[1];
                                if (!this.isEquivalentClass(e)) return !1;
                                var i = e,
                                    o = this._shell,
                                    r = i._shell;
                                if (!o.equalsExact(r, n)) return !1;
                                if (this._holes.length !== i._holes.length) return !1;
                                for (var s = 0; s < this._holes.length; s++)
                                    if (!this._holes[s].equalsExact(i._holes[s], n)) return !1;
                                return !0
                            }
                            return t.prototype.equalsExact.apply(this, arguments)
                        }, e.prototype.normalize = function() {
                            if (0 === arguments.length) {
                                this.normalize(this._shell, !0);
                                for (var t = 0; t < this._holes.length; t++) this.normalize(this._holes[t], !1);
                                Ft.sort(this._holes)
                            } else if (2 === arguments.length) {
                                var e = arguments[0],
                                    n = arguments[1];
                                if (e.isEmpty()) return null;
                                var i = new Array(e.getCoordinates().length - 1).fill(null);
                                Z.arraycopy(e.getCoordinates(), 0, i, 0, i.length);
                                var o = wt.minCoordinate(e.getCoordinates());
                                wt.scroll(i, o), Z.arraycopy(i, 0, e.getCoordinates(), 0, i.length), e.getCoordinates()[i.length] = i[0], at.isCCW(e.getCoordinates()) === n && wt.reverse(e.getCoordinates())
                            }
                        }, e.prototype.getCoordinate = function() {
                            return this._shell.getCoordinate()
                        }, e.prototype.getNumInteriorRing = function() {
                            return this._holes.length
                        }, e.prototype.getBoundaryDimension = function() {
                            return 1
                        }, e.prototype.getDimension = function() {
                            return 2
                        }, e.prototype.getLength = function() {
                            var t = 0;
                            t += this._shell.getLength();
                            for (var e = 0; e < this._holes.length; e++) t += this._holes[e].getLength();
                            return t
                        }, e.prototype.getNumPoints = function() {
                            for (var t = this._shell.getNumPoints(), e = 0; e < this._holes.length; e++) t += this._holes[e].getNumPoints();
                            return t
                        }, e.prototype.reverse = function() {
                            var t = this.copy();
                            t._shell = this._shell.copy().reverse(), t._holes = new Array(this._holes.length).fill(null);
                            for (var e = 0; e < this._holes.length; e++) t._holes[e] = this._holes[e].copy().reverse();
                            return t
                        }, e.prototype.convexHull = function() {
                            return this.getExteriorRing().convexHull()
                        }, e.prototype.compareToSameClass = function() {
                            if (1 === arguments.length) {
                                var t = arguments[0],
                                    e = this._shell,
                                    n = t._shell;
                                return e.compareToSameClass(n)
                            }
                            if (2 === arguments.length) {
                                var i = arguments[0],
                                    o = arguments[1],
                                    r = i,
                                    s = this._shell,
                                    a = r._shell,
                                    h = s.compareToSameClass(a, o);
                                if (0 !== h) return h;
                                for (var u = this.getNumInteriorRing(), l = r.getNumInteriorRing(), c = 0; c < u && c < l;) {
                                    var p = this.getInteriorRingN(c),
                                        f = r.getInteriorRingN(c),
                                        d = p.compareToSameClass(f, o);
                                    if (0 !== d) return d;
                                    c++
                                }
                                return c < u ? 1 : c < l ? -1 : 0
                            }
                        }, e.prototype.apply = function(t) {
                            if (N(t, ft)) {
                                this._shell.apply(t);
                                for (var e = 0; e < this._holes.length; e++) this._holes[e].apply(t)
                            } else if (N(t, Ut)) {
                                if (this._shell.apply(t), !t.isDone())
                                    for (var n = 0; n < this._holes.length && (this._holes[n].apply(t), !t.isDone()); n++);
                                t.isGeometryChanged() && this.geometryChanged()
                            } else if (N(t, Gt)) t.filter(this);
                            else if (N(t, ut)) {
                                t.filter(this), this._shell.apply(t);
                                for (var i = 0; i < this._holes.length; i++) this._holes[i].apply(t)
                            }
                        }, e.prototype.getBoundary = function() {
                            if (this.isEmpty()) return this.getFactory().createMultiLineString();
                            var t = new Array(this._holes.length + 1).fill(null);
                            t[0] = this._shell;
                            for (var e = 0; e < this._holes.length; e++) t[e + 1] = this._holes[e];
                            return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t)
                        }, e.prototype.clone = function() {
                            var e = t.prototype.clone.call(this);
                            e._shell = this._shell.clone(), e._holes = new Array(this._holes.length).fill(null);
                            for (var n = 0; n < this._holes.length; n++) e._holes[n] = this._holes[n].clone();
                            return e
                        }, e.prototype.getGeometryType = function() {
                            return "Polygon"
                        }, e.prototype.copy = function() {
                            for (var t = this._shell.copy(), n = new Array(this._holes.length).fill(null), i = 0; i < n.length; i++) n[i] = this._holes[i].copy();
                            return new e(t, n, this._factory)
                        }, e.prototype.getExteriorRing = function() {
                            return this._shell
                        }, e.prototype.isEmpty = function() {
                            return this._shell.isEmpty()
                        }, e.prototype.getInteriorRingN = function(t) {
                            return this._holes[t]
                        }, e.prototype.interfaces_ = function() {
                            return [Qt]
                        }, e.prototype.getClass = function() {
                            return e
                        }, n.serialVersionUID.get = function() {
                            return -0x307ffefd8dc97200
                        }, Object.defineProperties(e, n), e
                    }(lt),
                    te = function(t) {
                        function e() {
                            t.apply(this, arguments)
                        }
                        t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
                        var n = {
                            serialVersionUID: {
                                configurable: !0
                            }
                        };
                        return e.prototype.getSortIndex = function() {
                            return lt.SORTINDEX_MULTIPOINT
                        }, e.prototype.isValid = function() {
                            return !0
                        }, e.prototype.equalsExact = function() {
                            if (2 === arguments.length) {
                                var e = arguments[0],
                                    n = arguments[1];
                                return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n)
                            }
                            return t.prototype.equalsExact.apply(this, arguments)
                        }, e.prototype.getCoordinate = function() {
                            if (1 === arguments.length) {
                                var e = arguments[0];
                                return this._geometries[e].getCoordinate()
                            }
                            return t.prototype.getCoordinate.apply(this, arguments)
                        }, e.prototype.getBoundaryDimension = function() {
                            return zt.FALSE
                        }, e.prototype.getDimension = function() {
                            return 0
                        }, e.prototype.getBoundary = function() {
                            return this.getFactory().createGeometryCollection(null)
                        }, e.prototype.getGeometryType = function() {
                            return "MultiPoint"
                        }, e.prototype.copy = function() {
                            for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++) t[n] = this._geometries[n].copy();
                            return new e(t, this._factory)
                        }, e.prototype.interfaces_ = function() {
                            return [Jt]
                        }, e.prototype.getClass = function() {
                            return e
                        }, n.serialVersionUID.get = function() {
                            return -0x6fb1ed4162e0fc00
                        }, Object.defineProperties(e, n), e
                    }(jt),
                    ee = function(t) {
                        function e(e, n) {
                            e instanceof C && n instanceof me && (e = n.getCoordinateSequenceFactory().create(e)), t.call(this, e, n), this.validateConstruction()
                        }
                        t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
                        var n = {
                            MINIMUM_VALID_SIZE: {
                                configurable: !0
                            },
                            serialVersionUID: {
                                configurable: !0
                            }
                        };
                        return e.prototype.getSortIndex = function() {
                            return lt.SORTINDEX_LINEARRING
                        }, e.prototype.getBoundaryDimension = function() {
                            return zt.FALSE
                        }, e.prototype.isClosed = function() {
                            return !!this.isEmpty() || t.prototype.isClosed.call(this)
                        }, e.prototype.reverse = function() {
                            var t = this._points.copy();
                            return Wt.reverse(t), this.getFactory().createLinearRing(t)
                        }, e.prototype.validateConstruction = function() {
                            if (!this.isEmpty() && !t.prototype.isClosed.call(this)) throw new y("Points of LinearRing do not form a closed linestring");
                            if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < e.MINIMUM_VALID_SIZE) throw new y("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)")
                        }, e.prototype.getGeometryType = function() {
                            return "LinearRing"
                        }, e.prototype.copy = function() {
                            return new e(this._points.copy(), this._factory)
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, n.MINIMUM_VALID_SIZE.get = function() {
                            return 4
                        }, n.serialVersionUID.get = function() {
                            return -0x3b229e262367a600
                        }, Object.defineProperties(e, n), e
                    }(Xt),
                    ne = function(t) {
                        function e() {
                            t.apply(this, arguments)
                        }
                        t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
                        var n = {
                            serialVersionUID: {
                                configurable: !0
                            }
                        };
                        return e.prototype.getSortIndex = function() {
                            return lt.SORTINDEX_MULTIPOLYGON
                        }, e.prototype.equalsExact = function() {
                            if (2 === arguments.length) {
                                var e = arguments[0],
                                    n = arguments[1];
                                return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n)
                            }
                            return t.prototype.equalsExact.apply(this, arguments)
                        }, e.prototype.getBoundaryDimension = function() {
                            return 1
                        }, e.prototype.getDimension = function() {
                            return 2
                        }, e.prototype.reverse = function() {
                            for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++) e[n] = this._geometries[n].reverse();
                            return this.getFactory().createMultiPolygon(e)
                        }, e.prototype.getBoundary = function() {
                            if (this.isEmpty()) return this.getFactory().createMultiLineString();
                            for (var t = new Et, e = 0; e < this._geometries.length; e++)
                                for (var n = this._geometries[e].getBoundary(), i = 0; i < n.getNumGeometries(); i++) t.add(n.getGeometryN(i));
                            var o = new Array(t.size()).fill(null);
                            return this.getFactory().createMultiLineString(t.toArray(o))
                        }, e.prototype.getGeometryType = function() {
                            return "MultiPolygon"
                        }, e.prototype.copy = function() {
                            for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++) t[n] = this._geometries[n].copy();
                            return new e(t, this._factory)
                        }, e.prototype.interfaces_ = function() {
                            return [Qt]
                        }, e.prototype.getClass = function() {
                            return e
                        }, n.serialVersionUID.get = function() {
                            return -0x7a5aa1369171980
                        }, Object.defineProperties(e, n), e
                    }(jt),
                    ie = function(t) {
                        this._factory = t || null, this._isUserDataCopied = !1
                    },
                    oe = {
                        NoOpGeometryOperation: {
                            configurable: !0
                        },
                        CoordinateOperation: {
                            configurable: !0
                        },
                        CoordinateSequenceOperation: {
                            configurable: !0
                        }
                    };
                ie.prototype.setCopyUserData = function(t) {
                    this._isUserDataCopied = t
                }, ie.prototype.edit = function(t, e) {
                    if (null === t) return null;
                    var n = this.editInternal(t, e);
                    return this._isUserDataCopied && n.setUserData(t.getUserData()), n
                }, ie.prototype.editInternal = function(t, e) {
                    return null === this._factory && (this._factory = t.getFactory()), t instanceof jt ? this.editGeometryCollection(t, e) : t instanceof $t ? this.editPolygon(t, e) : t instanceof Kt ? e.edit(t, this._factory) : t instanceof Xt ? e.edit(t, this._factory) : (et.shouldNeverReachHere("Unsupported Geometry class: " + t.getClass().getName()), null)
                }, ie.prototype.editGeometryCollection = function(t, e) {
                    for (var n = e.edit(t, this._factory), i = new Et, o = 0; o < n.getNumGeometries(); o++) {
                        var r = this.edit(n.getGeometryN(o), e);
                        null === r || r.isEmpty() || i.add(r)
                    }
                    return n.getClass() === te ? this._factory.createMultiPoint(i.toArray([])) : n.getClass() === qt ? this._factory.createMultiLineString(i.toArray([])) : n.getClass() === ne ? this._factory.createMultiPolygon(i.toArray([])) : this._factory.createGeometryCollection(i.toArray([]))
                }, ie.prototype.editPolygon = function(t, e) {
                    var n = e.edit(t, this._factory);
                    if (null === n && (n = this._factory.createPolygon(null)), n.isEmpty()) return n;
                    var i = this.edit(n.getExteriorRing(), e);
                    if (null === i || i.isEmpty()) return this._factory.createPolygon();
                    for (var o = new Et, r = 0; r < n.getNumInteriorRing(); r++) {
                        var s = this.edit(n.getInteriorRingN(r), e);
                        null === s || s.isEmpty() || o.add(s)
                    }
                    return this._factory.createPolygon(i, o.toArray([]))
                }, ie.prototype.interfaces_ = function() {
                    return []
                }, ie.prototype.getClass = function() {
                    return ie
                }, ie.GeometryEditorOperation = function() {}, oe.NoOpGeometryOperation.get = function() {
                    return re
                }, oe.CoordinateOperation.get = function() {
                    return se
                }, oe.CoordinateSequenceOperation.get = function() {
                    return ae
                }, Object.defineProperties(ie, oe);
                var re = function() {};
                re.prototype.edit = function(t, e) {
                    return t
                }, re.prototype.interfaces_ = function() {
                    return [ie.GeometryEditorOperation]
                }, re.prototype.getClass = function() {
                    return re
                };
                var se = function() {};
                se.prototype.edit = function(t, e) {
                    var n = this.editCoordinates(t.getCoordinates(), t);
                    return null === n ? t : t instanceof ee ? e.createLinearRing(n) : t instanceof Xt ? e.createLineString(n) : t instanceof Kt ? n.length > 0 ? e.createPoint(n[0]) : e.createPoint() : t
                }, se.prototype.interfaces_ = function() {
                    return [ie.GeometryEditorOperation]
                }, se.prototype.getClass = function() {
                    return se
                };
                var ae = function() {};
                ae.prototype.edit = function(t, e) {
                    return t instanceof ee ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t)) : t instanceof Xt ? e.createLineString(this.edit(t.getCoordinateSequence(), t)) : t instanceof Kt ? e.createPoint(this.edit(t.getCoordinateSequence(), t)) : t
                }, ae.prototype.interfaces_ = function() {
                    return [ie.GeometryEditorOperation]
                }, ae.prototype.getClass = function() {
                    return ae
                };
                var he = function() {
                        if (this._dimension = 3, this._coordinates = null, 1 === arguments.length) {
                            if (arguments[0] instanceof Array) this._coordinates = arguments[0], this._dimension = 3;
                            else if (Number.isInteger(arguments[0])) {
                                var t = arguments[0];
                                this._coordinates = new Array(t).fill(null);
                                for (var e = 0; e < t; e++) this._coordinates[e] = new C
                            } else if (N(arguments[0], G)) {
                                var n = arguments[0];
                                if (null === n) return this._coordinates = new Array(0).fill(null), null;
                                this._dimension = n.getDimension(), this._coordinates = new Array(n.size()).fill(null);
                                for (var i = 0; i < this._coordinates.length; i++) this._coordinates[i] = n.getCoordinateCopy(i)
                            }
                        } else if (2 === arguments.length)
                            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
                                var o = arguments[0],
                                    r = arguments[1];
                                this._coordinates = o, this._dimension = r, null === o && (this._coordinates = new Array(0).fill(null))
                            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                            var s = arguments[0],
                                a = arguments[1];
                            this._coordinates = new Array(s).fill(null), this._dimension = a;
                            for (var h = 0; h < s; h++) this._coordinates[h] = new C
                        }
                    },
                    ue = {
                        serialVersionUID: {
                            configurable: !0
                        }
                    };
                he.prototype.setOrdinate = function(t, e, n) {
                    switch (e) {
                        case G.X:
                            this._coordinates[t].x = n;
                            break;
                        case G.Y:
                            this._coordinates[t].y = n;
                            break;
                        case G.Z:
                            this._coordinates[t].z = n;
                            break;
                        default:
                            throw new y("invalid ordinateIndex")
                    }
                }, he.prototype.size = function() {
                    return this._coordinates.length
                }, he.prototype.getOrdinate = function(t, e) {
                    switch (e) {
                        case G.X:
                            return this._coordinates[t].x;
                        case G.Y:
                            return this._coordinates[t].y;
                        case G.Z:
                            return this._coordinates[t].z
                    }
                    return v.NaN
                }, he.prototype.getCoordinate = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return this._coordinates[t]
                    }
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        n.x = this._coordinates[e].x, n.y = this._coordinates[e].y, n.z = this._coordinates[e].z
                    }
                }, he.prototype.getCoordinateCopy = function(t) {
                    return new C(this._coordinates[t])
                }, he.prototype.getDimension = function() {
                    return this._dimension
                }, he.prototype.getX = function(t) {
                    return this._coordinates[t].x
                }, he.prototype.clone = function() {
                    for (var t = new Array(this.size()).fill(null), e = 0; e < this._coordinates.length; e++) t[e] = this._coordinates[e].clone();
                    return new he(t, this._dimension)
                }, he.prototype.expandEnvelope = function(t) {
                    for (var e = 0; e < this._coordinates.length; e++) t.expandToInclude(this._coordinates[e]);
                    return t
                }, he.prototype.copy = function() {
                    for (var t = new Array(this.size()).fill(null), e = 0; e < this._coordinates.length; e++) t[e] = this._coordinates[e].copy();
                    return new he(t, this._dimension)
                }, he.prototype.toString = function() {
                    if (this._coordinates.length > 0) {
                        var t = new A(17 * this._coordinates.length);
                        t.append("("), t.append(this._coordinates[0]);
                        for (var e = 1; e < this._coordinates.length; e++) t.append(", "), t.append(this._coordinates[e]);
                        return t.append(")"), t.toString()
                    }
                    return "()"
                }, he.prototype.getY = function(t) {
                    return this._coordinates[t].y
                }, he.prototype.toCoordinateArray = function() {
                    return this._coordinates
                }, he.prototype.interfaces_ = function() {
                    return [G, e]
                }, he.prototype.getClass = function() {
                    return he
                }, ue.serialVersionUID.get = function() {
                    return -0xcb44a778db18e00
                }, Object.defineProperties(he, ue);
                var le = function() {},
                    ce = {
                        serialVersionUID: {
                            configurable: !0
                        },
                        instanceObject: {
                            configurable: !0
                        }
                    };
                le.prototype.readResolve = function() {
                    return le.instance()
                }, le.prototype.create = function() {
                    if (1 === arguments.length) {
                        if (arguments[0] instanceof Array) {
                            var t = arguments[0];
                            return new he(t)
                        }
                        if (N(arguments[0], G)) {
                            var e = arguments[0];
                            return new he(e)
                        }
                    } else if (2 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1];
                        return i > 3 && (i = 3), i < 2 ? new he(n) : new he(n, i)
                    }
                }, le.prototype.interfaces_ = function() {
                    return [M, e]
                }, le.prototype.getClass = function() {
                    return le
                }, le.instance = function() {
                    return le.instanceObject
                }, ce.serialVersionUID.get = function() {
                    return -0x38e49fa6cf6f2e00
                }, ce.instanceObject.get = function() {
                    return new le
                }, Object.defineProperties(le, ce);
                var pe = function(t) {
                        function e() {
                            t.call(this), this.map_ = new Map
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.get = function(t) {
                            return this.map_.get(t) || null
                        }, e.prototype.put = function(t, e) {
                            return this.map_.set(t, e), e
                        }, e.prototype.values = function() {
                            for (var t = new Et, e = this.map_.values(), n = e.next(); !n.done;) t.add(n.value), n = e.next();
                            return t
                        }, e.prototype.entrySet = function() {
                            var t = new Ot;
                            return this.map_.entries().forEach(function(e) {
                                return t.add(e)
                            }), t
                        }, e.prototype.size = function() {
                            return this.map_.size()
                        }, e
                    }(Nt),
                    fe = function t() {
                        if (this._modelType = null, this._scale = null, 0 === arguments.length) this._modelType = t.FLOATING;
                        else if (1 === arguments.length)
                            if (arguments[0] instanceof _e) {
                                var e = arguments[0];
                                this._modelType = e, e === t.FIXED && this.setScale(1)
                            } else if ("number" == typeof arguments[0]) {
                            var n = arguments[0];
                            this._modelType = t.FIXED, this.setScale(n)
                        } else if (arguments[0] instanceof t) {
                            var i = arguments[0];
                            this._modelType = i._modelType, this._scale = i._scale
                        }
                    },
                    de = {
                        serialVersionUID: {
                            configurable: !0
                        },
                        maximumPreciseValue: {
                            configurable: !0
                        }
                    };
                fe.prototype.equals = function(t) {
                    if (!(t instanceof fe)) return !1;
                    var e = t;
                    return this._modelType === e._modelType && this._scale === e._scale
                }, fe.prototype.compareTo = function(t) {
                    var e = t,
                        n = this.getMaximumSignificantDigits(),
                        i = e.getMaximumSignificantDigits();
                    return new R(n).compareTo(new R(i))
                }, fe.prototype.getScale = function() {
                    return this._scale
                }, fe.prototype.isFloating = function() {
                    return this._modelType === fe.FLOATING || this._modelType === fe.FLOATING_SINGLE
                }, fe.prototype.getType = function() {
                    return this._modelType
                }, fe.prototype.toString = function() {
                    var t = "UNKNOWN";
                    return this._modelType === fe.FLOATING ? t = "Floating" : this._modelType === fe.FLOATING_SINGLE ? t = "Floating-Single" : this._modelType === fe.FIXED && (t = "Fixed (Scale=" + this.getScale() + ")"), t
                }, fe.prototype.makePrecise = function() {
                    if ("number" == typeof arguments[0]) {
                        var t = arguments[0];
                        return v.isNaN(t) ? t : this._modelType === fe.FLOATING_SINGLE ? t : this._modelType === fe.FIXED ? Math.round(t * this._scale) / this._scale : t
                    }
                    if (arguments[0] instanceof C) {
                        var e = arguments[0];
                        if (this._modelType === fe.FLOATING) return null;
                        e.x = this.makePrecise(e.x), e.y = this.makePrecise(e.y)
                    }
                }, fe.prototype.getMaximumSignificantDigits = function() {
                    var t = 16;
                    return this._modelType === fe.FLOATING ? t = 16 : this._modelType === fe.FLOATING_SINGLE ? t = 6 : this._modelType === fe.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t
                }, fe.prototype.setScale = function(t) {
                    this._scale = Math.abs(t)
                }, fe.prototype.interfaces_ = function() {
                    return [e, x]
                }, fe.prototype.getClass = function() {
                    return fe
                }, fe.mostPrecise = function(t, e) {
                    return t.compareTo(e) >= 0 ? t : e
                }, de.serialVersionUID.get = function() {
                    return 0x6bee6404e9a25c00
                }, de.maximumPreciseValue.get = function() {
                    return 9007199254740992
                }, Object.defineProperties(fe, de);
                var _e = function t(e) {
                        this._name = e || null, t.nameToTypeMap.put(e, this)
                    },
                    ge = {
                        serialVersionUID: {
                            configurable: !0
                        },
                        nameToTypeMap: {
                            configurable: !0
                        }
                    };
                _e.prototype.readResolve = function() {
                    return _e.nameToTypeMap.get(this._name)
                }, _e.prototype.toString = function() {
                    return this._name
                }, _e.prototype.interfaces_ = function() {
                    return [e]
                }, _e.prototype.getClass = function() {
                    return _e
                }, ge.serialVersionUID.get = function() {
                    return -552860263173159e4
                }, ge.nameToTypeMap.get = function() {
                    return new pe
                }, Object.defineProperties(_e, ge), fe.Type = _e, fe.FIXED = new _e("FIXED"), fe.FLOATING = new _e("FLOATING"), fe.FLOATING_SINGLE = new _e("FLOATING SINGLE");
                var me = function t() {
                        this._precisionModel = new fe, this._SRID = 0, this._coordinateSequenceFactory = t.getDefaultCoordinateSequenceFactory(), 0 === arguments.length || (1 === arguments.length ? N(arguments[0], M) ? this._coordinateSequenceFactory = arguments[0] : arguments[0] instanceof fe && (this._precisionModel = arguments[0]) : 2 === arguments.length ? (this._precisionModel = arguments[0], this._SRID = arguments[1]) : 3 === arguments.length && (this._precisionModel = arguments[0], this._SRID = arguments[1], this._coordinateSequenceFactory = arguments[2]))
                    },
                    ye = {
                        serialVersionUID: {
                            configurable: !0
                        }
                    };
                me.prototype.toGeometry = function(t) {
                    return t.isNull() ? this.createPoint(null) : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new C(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new C(t.getMinX(), t.getMinY()), new C(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new C(t.getMinX(), t.getMinY()), new C(t.getMinX(), t.getMaxY()), new C(t.getMaxX(), t.getMaxY()), new C(t.getMaxX(), t.getMinY()), new C(t.getMinX(), t.getMinY())]), null)
                }, me.prototype.createLineString = function(t) {
                    return t ? t instanceof Array ? new Xt(this.getCoordinateSequenceFactory().create(t), this) : N(t, G) ? new Xt(t, this) : void 0 : new Xt(this.getCoordinateSequenceFactory().create([]), this)
                }, me.prototype.createMultiLineString = function() {
                    if (0 === arguments.length) return new qt(null, this);
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return new qt(t, this)
                    }
                }, me.prototype.buildGeometry = function(t) {
                    for (var e = null, n = !1, i = !1, o = t.iterator(); o.hasNext();) {
                        var r = o.next(),
                            s = r.getClass();
                        null === e && (e = s), s !== e && (n = !0), r.isGeometryCollectionOrDerived() && (i = !0)
                    }
                    if (null === e) return this.createGeometryCollection();
                    if (n || i) return this.createGeometryCollection(me.toGeometryArray(t));
                    var a = t.iterator().next();
                    if (t.size() > 1) {
                        if (a instanceof $t) return this.createMultiPolygon(me.toPolygonArray(t));
                        if (a instanceof Xt) return this.createMultiLineString(me.toLineStringArray(t));
                        if (a instanceof Kt) return this.createMultiPoint(me.toPointArray(t));
                        et.shouldNeverReachHere("Unhandled class: " + a.getClass().getName())
                    }
                    return a
                }, me.prototype.createMultiPointFromCoords = function(t) {
                    return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
                }, me.prototype.createPoint = function() {
                    if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
                    if (1 === arguments.length) {
                        if (arguments[0] instanceof C) {
                            var t = arguments[0];
                            return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null)
                        }
                        if (N(arguments[0], G)) {
                            var e = arguments[0];
                            return new Kt(e, this)
                        }
                    }
                }, me.prototype.getCoordinateSequenceFactory = function() {
                    return this._coordinateSequenceFactory
                }, me.prototype.createPolygon = function() {
                    if (0 === arguments.length) return new $t(null, null, this);
                    if (1 === arguments.length) {
                        if (N(arguments[0], G)) {
                            var t = arguments[0];
                            return this.createPolygon(this.createLinearRing(t))
                        }
                        if (arguments[0] instanceof Array) {
                            var e = arguments[0];
                            return this.createPolygon(this.createLinearRing(e))
                        }
                        if (arguments[0] instanceof ee) {
                            var n = arguments[0];
                            return this.createPolygon(n, null)
                        }
                    } else if (2 === arguments.length) {
                        var i = arguments[0],
                            o = arguments[1];
                        return new $t(i, o, this)
                    }
                }, me.prototype.getSRID = function() {
                    return this._SRID
                }, me.prototype.createGeometryCollection = function() {
                    if (0 === arguments.length) return new jt(null, this);
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return new jt(t, this)
                    }
                }, me.prototype.createGeometry = function(t) {
                    return new ie(this).edit(t, {
                        edit: function() {
                            if (2 === arguments.length) {
                                var t = arguments[0];
                                return this._coordinateSequenceFactory.create(t)
                            }
                        }
                    })
                }, me.prototype.getPrecisionModel = function() {
                    return this._precisionModel
                }, me.prototype.createLinearRing = function() {
                    if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
                    if (1 === arguments.length) {
                        if (arguments[0] instanceof Array) {
                            var t = arguments[0];
                            return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
                        }
                        if (N(arguments[0], G)) {
                            var e = arguments[0];
                            return new ee(e, this)
                        }
                    }
                }, me.prototype.createMultiPolygon = function() {
                    if (0 === arguments.length) return new ne(null, this);
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return new ne(t, this)
                    }
                }, me.prototype.createMultiPoint = function() {
                    if (0 === arguments.length) return new te(null, this);
                    if (1 === arguments.length) {
                        if (arguments[0] instanceof Array) {
                            var t = arguments[0];
                            return new te(t, this)
                        }
                        if (arguments[0] instanceof Array) {
                            var e = arguments[0];
                            return this.createMultiPoint(null !== e ? this.getCoordinateSequenceFactory().create(e) : null)
                        }
                        if (N(arguments[0], G)) {
                            var n = arguments[0];
                            if (null === n) return this.createMultiPoint(new Array(0).fill(null));
                            for (var i = new Array(n.size()).fill(null), o = 0; o < n.size(); o++) {
                                var r = this.getCoordinateSequenceFactory().create(1, n.getDimension());
                                Wt.copy(n, o, r, 0, 1), i[o] = this.createPoint(r)
                            }
                            return this.createMultiPoint(i)
                        }
                    }
                }, me.prototype.interfaces_ = function() {
                    return [e]
                }, me.prototype.getClass = function() {
                    return me
                }, me.toMultiPolygonArray = function(t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e)
                }, me.toGeometryArray = function(t) {
                    if (null === t) return null;
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e)
                }, me.getDefaultCoordinateSequenceFactory = function() {
                    return le.instance()
                }, me.toMultiLineStringArray = function(t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e)
                }, me.toLineStringArray = function(t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e)
                }, me.toMultiPointArray = function(t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e)
                }, me.toLinearRingArray = function(t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e)
                }, me.toPointArray = function(t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e)
                }, me.toPolygonArray = function(t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e)
                }, me.createPointFromInternalCoord = function(t, e) {
                    return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t)
                }, ye.serialVersionUID.get = function() {
                    return -0x5ea75f2051eeb400
                }, Object.defineProperties(me, ye);
                var ve = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"],
                    Le = function(t) {
                        this.geometryFactory = t || new me
                    };
                Le.prototype.read = function(t) {
                    var e, n = (e = "string" == typeof t ? JSON.parse(t) : t).type;
                    if (!xe[n]) throw new Error("Unknown GeoJSON type: " + e.type);
                    return -1 !== ve.indexOf(n) ? xe[n].apply(this, [e.coordinates]) : "GeometryCollection" === n ? xe[n].apply(this, [e.geometries]) : xe[n].apply(this, [e])
                }, Le.prototype.write = function(t) {
                    var e = t.getGeometryType();
                    if (!be[e]) throw new Error("Geometry is not supported");
                    return be[e].apply(this, [t])
                };
                var xe = {
                        Feature: function(t) {
                            var e = {};
                            for (var n in t) e[n] = t[n];
                            if (t.geometry) {
                                var i = t.geometry.type;
                                if (!xe[i]) throw new Error("Unknown GeoJSON type: " + t.type);
                                e.geometry = this.read(t.geometry)
                            }
                            return t.bbox && (e.bbox = xe.bbox.apply(this, [t.bbox])), e
                        },
                        FeatureCollection: function(t) {
                            var e = {};
                            if (t.features) {
                                e.features = [];
                                for (var n = 0; n < t.features.length; ++n) e.features.push(this.read(t.features[n]))
                            }
                            return t.bbox && (e.bbox = this.parse.bbox.apply(this, [t.bbox])), e
                        },
                        coordinates: function(t) {
                            for (var e = [], n = 0; n < t.length; ++n) {
                                var i = t[n];
                                e.push(new C(i[0], i[1]))
                            }
                            return e
                        },
                        bbox: function(t) {
                            return this.geometryFactory.createLinearRing([new C(t[0], t[1]), new C(t[2], t[1]), new C(t[2], t[3]), new C(t[0], t[3]), new C(t[0], t[1])])
                        },
                        Point: function(t) {
                            var e = new C(t[0], t[1]);
                            return this.geometryFactory.createPoint(e)
                        },
                        MultiPoint: function(t) {
                            for (var e = [], n = 0; n < t.length; ++n) e.push(xe.Point.apply(this, [t[n]]));
                            return this.geometryFactory.createMultiPoint(e)
                        },
                        LineString: function(t) {
                            var e = xe.coordinates.apply(this, [t]);
                            return this.geometryFactory.createLineString(e)
                        },
                        MultiLineString: function(t) {
                            for (var e = [], n = 0; n < t.length; ++n) e.push(xe.LineString.apply(this, [t[n]]));
                            return this.geometryFactory.createMultiLineString(e)
                        },
                        Polygon: function(t) {
                            for (var e = xe.coordinates.apply(this, [t[0]]), n = this.geometryFactory.createLinearRing(e), i = [], o = 1; o < t.length; ++o) {
                                var r = t[o],
                                    s = xe.coordinates.apply(this, [r]),
                                    a = this.geometryFactory.createLinearRing(s);
                                i.push(a)
                            }
                            return this.geometryFactory.createPolygon(n, i)
                        },
                        MultiPolygon: function(t) {
                            for (var e = [], n = 0; n < t.length; ++n) {
                                var i = t[n];
                                e.push(xe.Polygon.apply(this, [i]))
                            }
                            return this.geometryFactory.createMultiPolygon(e)
                        },
                        GeometryCollection: function(t) {
                            for (var e = [], n = 0; n < t.length; ++n) {
                                var i = t[n];
                                e.push(this.read(i))
                            }
                            return this.geometryFactory.createGeometryCollection(e)
                        }
                    },
                    be = {
                        coordinate: function(t) {
                            return [t.x, t.y]
                        },
                        Point: function(t) {
                            return {
                                type: "Point",
                                coordinates: be.coordinate.apply(this, [t.getCoordinate()])
                            }
                        },
                        MultiPoint: function(t) {
                            for (var e = [], n = 0; n < t._geometries.length; ++n) {
                                var i = t._geometries[n],
                                    o = be.Point.apply(this, [i]);
                                e.push(o.coordinates)
                            }
                            return {
                                type: "MultiPoint",
                                coordinates: e
                            }
                        },
                        LineString: function(t) {
                            for (var e = [], n = t.getCoordinates(), i = 0; i < n.length; ++i) {
                                var o = n[i];
                                e.push(be.coordinate.apply(this, [o]))
                            }
                            return {
                                type: "LineString",
                                coordinates: e
                            }
                        },
                        MultiLineString: function(t) {
                            for (var e = [], n = 0; n < t._geometries.length; ++n) {
                                var i = t._geometries[n],
                                    o = be.LineString.apply(this, [i]);
                                e.push(o.coordinates)
                            }
                            return {
                                type: "MultiLineString",
                                coordinates: e
                            }
                        },
                        Polygon: function(t) {
                            var e = [],
                                n = be.LineString.apply(this, [t._shell]);
                            e.push(n.coordinates);
                            for (var i = 0; i < t._holes.length; ++i) {
                                var o = t._holes[i],
                                    r = be.LineString.apply(this, [o]);
                                e.push(r.coordinates)
                            }
                            return {
                                type: "Polygon",
                                coordinates: e
                            }
                        },
                        MultiPolygon: function(t) {
                            for (var e = [], n = 0; n < t._geometries.length; ++n) {
                                var i = t._geometries[n],
                                    o = be.Polygon.apply(this, [i]);
                                e.push(o.coordinates)
                            }
                            return {
                                type: "MultiPolygon",
                                coordinates: e
                            }
                        },
                        GeometryCollection: function(t) {
                            for (var e = [], n = 0; n < t._geometries.length; ++n) {
                                var i = t._geometries[n],
                                    o = i.getGeometryType();
                                e.push(be[o].apply(this, [i]))
                            }
                            return {
                                type: "GeometryCollection",
                                geometries: e
                            }
                        }
                    },
                    Ee = function(t) {
                        this.geometryFactory = t || new me, this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new Le(this.geometryFactory)
                    };
                Ee.prototype.read = function(t) {
                    var e = this.parser.read(t);
                    return this.precisionModel.getType() === fe.FIXED && this.reducePrecision(e), e
                }, Ee.prototype.reducePrecision = function(t) {
                    var e, n;
                    if (t.coordinate) this.precisionModel.makePrecise(t.coordinate);
                    else if (t.points)
                        for (e = 0, n = t.points.length; e < n; e++) this.precisionModel.makePrecise(t.points[e]);
                    else if (t.geometries)
                        for (e = 0, n = t.geometries.length; e < n; e++) this.reducePrecision(t.geometries[e])
                };
                var Ce = function() {
                    this.parser = new Le(this.geometryFactory)
                };
                Ce.prototype.write = function(t) {
                    return this.parser.write(t)
                };
                var Ie = function() {},
                    we = {
                        ON: {
                            configurable: !0
                        },
                        LEFT: {
                            configurable: !0
                        },
                        RIGHT: {
                            configurable: !0
                        }
                    };
                Ie.prototype.interfaces_ = function() {
                    return []
                }, Ie.prototype.getClass = function() {
                    return Ie
                }, Ie.opposite = function(t) {
                    return t === Ie.LEFT ? Ie.RIGHT : t === Ie.RIGHT ? Ie.LEFT : t
                }, we.ON.get = function() {
                    return 0
                }, we.LEFT.get = function() {
                    return 1
                }, we.RIGHT.get = function() {
                    return 2
                }, Object.defineProperties(Ie, we), (_.prototype = new Error).name = "EmptyStackException", (g.prototype = new bt).add = function(t) {
                    return this.array_.push(t), !0
                }, g.prototype.get = function(t) {
                    if (t < 0 || t >= this.size()) throw new Error;
                    return this.array_[t]
                }, g.prototype.push = function(t) {
                    return this.array_.push(t), t
                }, g.prototype.pop = function(t) {
                    if (0 === this.array_.length) throw new _;
                    return this.array_.pop()
                }, g.prototype.peek = function() {
                    if (0 === this.array_.length) throw new _;
                    return this.array_[this.array_.length - 1]
                }, g.prototype.empty = function() {
                    return 0 === this.array_.length
                }, g.prototype.isEmpty = function() {
                    return this.empty()
                }, g.prototype.search = function(t) {
                    return this.array_.indexOf(t)
                }, g.prototype.size = function() {
                    return this.array_.length
                }, g.prototype.toArray = function() {
                    for (var t = [], e = 0, n = this.array_.length; e < n; e++) t.push(this.array_[e]);
                    return t
                };
                var Me = function() {
                    this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null
                };
                Me.prototype.getCoordinate = function() {
                    return this._minCoord
                }, Me.prototype.getRightmostSide = function(t, e) {
                    var n = this.getRightmostSideOfSegment(t, e);
                    return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t)), n
                }, Me.prototype.findRightmostEdgeAtVertex = function() {
                    var t = this._minDe.getEdge().getCoordinates();
                    et.isTrue(this._minIndex > 0 && this._minIndex < t.length, "rightmost point expected to be interior vertex of edge");
                    var e = t[this._minIndex - 1],
                        n = t[this._minIndex + 1],
                        i = at.computeOrientation(this._minCoord, n, e),
                        o = !1;
                    e.y < this._minCoord.y && n.y < this._minCoord.y && i === at.COUNTERCLOCKWISE ? o = !0 : e.y > this._minCoord.y && n.y > this._minCoord.y && i === at.CLOCKWISE && (o = !0), o && (this._minIndex = this._minIndex - 1)
                }, Me.prototype.getRightmostSideOfSegment = function(t, e) {
                    var n = t.getEdge().getCoordinates();
                    if (e < 0 || e + 1 >= n.length) return -1;
                    if (n[e].y === n[e + 1].y) return -1;
                    var i = Ie.LEFT;
                    return n[e].y < n[e + 1].y && (i = Ie.RIGHT), i
                }, Me.prototype.getEdge = function() {
                    return this._orientedDe
                }, Me.prototype.checkForRightmostCoordinate = function(t) {
                    for (var e = t.getEdge().getCoordinates(), n = 0; n < e.length - 1; n++)(null === this._minCoord || e[n].x > this._minCoord.x) && (this._minDe = t, this._minIndex = n, this._minCoord = e[n])
                }, Me.prototype.findRightmostEdgeAtNode = function() {
                    var t = this._minDe.getNode().getEdges();
                    this._minDe = t.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1)
                }, Me.prototype.findEdge = function(t) {
                    for (var e = t.iterator(); e.hasNext();) {
                        var n = e.next();
                        n.isForward() && this.checkForRightmostCoordinate(n)
                    }
                    et.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === Ie.LEFT && (this._orientedDe = this._minDe.getSym())
                }, Me.prototype.interfaces_ = function() {
                    return []
                }, Me.prototype.getClass = function() {
                    return Me
                };
                var Se = function(t) {
                        function e(n, i) {
                            t.call(this, e.msgWithCoord(n, i)), this.pt = i ? new C(i) : null, this.name = "TopologyException"
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getCoordinate = function() {
                            return this.pt
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e.msgWithCoord = function(t, e) {
                            return e ? t : t + " [ " + e + " ]"
                        }, e
                    }($),
                    Pe = function() {
                        this.array_ = []
                    };
                Pe.prototype.addLast = function(t) {
                    this.array_.push(t)
                }, Pe.prototype.removeFirst = function() {
                    return this.array_.shift()
                }, Pe.prototype.isEmpty = function() {
                    return 0 === this.array_.length
                };
                var Ne = function() {
                    this._finder = null, this._dirEdgeList = new Et, this._nodes = new Et, this._rightMostCoord = null, this._env = null, this._finder = new Me
                };
                Ne.prototype.clearVisitedEdges = function() {
                    for (var t = this._dirEdgeList.iterator(); t.hasNext();) t.next().setVisited(!1)
                }, Ne.prototype.getRightmostCoordinate = function() {
                    return this._rightMostCoord
                }, Ne.prototype.computeNodeDepth = function(t) {
                    for (var e = null, n = t.getEdges().iterator(); n.hasNext();) {
                        var i = n.next();
                        if (i.isVisited() || i.getSym().isVisited()) {
                            e = i;
                            break
                        }
                    }
                    if (null === e) throw new Se("unable to find edge to compute depths at " + t.getCoordinate());
                    t.getEdges().computeDepths(e);
                    for (var o = t.getEdges().iterator(); o.hasNext();) {
                        var r = o.next();
                        r.setVisited(!0), this.copySymDepths(r)
                    }
                }, Ne.prototype.computeDepth = function(t) {
                    this.clearVisitedEdges();
                    var e = this._finder.getEdge();
                    e.setEdgeDepths(Ie.RIGHT, t), this.copySymDepths(e), this.computeDepths(e)
                }, Ne.prototype.create = function(t) {
                    this.addReachable(t), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate()
                }, Ne.prototype.findResultEdges = function() {
                    for (var t = this._dirEdgeList.iterator(); t.hasNext();) {
                        var e = t.next();
                        e.getDepth(Ie.RIGHT) >= 1 && e.getDepth(Ie.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0)
                    }
                }, Ne.prototype.computeDepths = function(t) {
                    var e = new Ot,
                        n = new Pe,
                        i = t.getNode();
                    for (n.addLast(i), e.add(i), t.setVisited(!0); !n.isEmpty();) {
                        var o = n.removeFirst();
                        e.add(o), this.computeNodeDepth(o);
                        for (var r = o.getEdges().iterator(); r.hasNext();) {
                            var s = r.next().getSym();
                            if (!s.isVisited()) {
                                var a = s.getNode();
                                e.contains(a) || (n.addLast(a), e.add(a))
                            }
                        }
                    }
                }, Ne.prototype.compareTo = function(t) {
                    var e = t;
                    return this._rightMostCoord.x < e._rightMostCoord.x ? -1 : this._rightMostCoord.x > e._rightMostCoord.x ? 1 : 0
                }, Ne.prototype.getEnvelope = function() {
                    if (null === this._env) {
                        for (var t = new H, e = this._dirEdgeList.iterator(); e.hasNext();)
                            for (var n = e.next().getEdge().getCoordinates(), i = 0; i < n.length - 1; i++) t.expandToInclude(n[i]);
                        this._env = t
                    }
                    return this._env
                }, Ne.prototype.addReachable = function(t) {
                    var e = new g;
                    for (e.add(t); !e.empty();) {
                        var n = e.pop();
                        this.add(n, e)
                    }
                }, Ne.prototype.copySymDepths = function(t) {
                    var e = t.getSym();
                    e.setDepth(Ie.LEFT, t.getDepth(Ie.RIGHT)), e.setDepth(Ie.RIGHT, t.getDepth(Ie.LEFT))
                }, Ne.prototype.add = function(t, e) {
                    t.setVisited(!0), this._nodes.add(t);
                    for (var n = t.getEdges().iterator(); n.hasNext();) {
                        var i = n.next();
                        this._dirEdgeList.add(i);
                        var o = i.getSym().getNode();
                        o.isVisited() || e.push(o)
                    }
                }, Ne.prototype.getNodes = function() {
                    return this._nodes
                }, Ne.prototype.getDirectedEdges = function() {
                    return this._dirEdgeList
                }, Ne.prototype.interfaces_ = function() {
                    return [x]
                }, Ne.prototype.getClass = function() {
                    return Ne
                };
                var Te = function t() {
                    if (this.location = null, 1 === arguments.length) {
                        if (arguments[0] instanceof Array) {
                            var e = arguments[0];
                            this.init(e.length)
                        } else if (Number.isInteger(arguments[0])) {
                            var n = arguments[0];
                            this.init(1), this.location[Ie.ON] = n
                        } else if (arguments[0] instanceof t) {
                            var i = arguments[0];
                            if (this.init(i.location.length), null !== i)
                                for (var o = 0; o < this.location.length; o++) this.location[o] = i.location[o]
                        }
                    } else if (3 === arguments.length) {
                        var r = arguments[0],
                            s = arguments[1],
                            a = arguments[2];
                        this.init(3), this.location[Ie.ON] = r, this.location[Ie.LEFT] = s, this.location[Ie.RIGHT] = a
                    }
                };
                Te.prototype.setAllLocations = function(t) {
                    for (var e = 0; e < this.location.length; e++) this.location[e] = t
                }, Te.prototype.isNull = function() {
                    for (var t = 0; t < this.location.length; t++)
                        if (this.location[t] !== S.NONE) return !1;
                    return !0
                }, Te.prototype.setAllLocationsIfNull = function(t) {
                    for (var e = 0; e < this.location.length; e++) this.location[e] === S.NONE && (this.location[e] = t)
                }, Te.prototype.isLine = function() {
                    return 1 === this.location.length
                }, Te.prototype.merge = function(t) {
                    if (t.location.length > this.location.length) {
                        var e = new Array(3).fill(null);
                        e[Ie.ON] = this.location[Ie.ON], e[Ie.LEFT] = S.NONE, e[Ie.RIGHT] = S.NONE, this.location = e
                    }
                    for (var n = 0; n < this.location.length; n++) this.location[n] === S.NONE && n < t.location.length && (this.location[n] = t.location[n])
                }, Te.prototype.getLocations = function() {
                    return this.location
                }, Te.prototype.flip = function() {
                    if (this.location.length <= 1) return null;
                    var t = this.location[Ie.LEFT];
                    this.location[Ie.LEFT] = this.location[Ie.RIGHT], this.location[Ie.RIGHT] = t
                }, Te.prototype.toString = function() {
                    var t = new A;
                    return this.location.length > 1 && t.append(S.toLocationSymbol(this.location[Ie.LEFT])), t.append(S.toLocationSymbol(this.location[Ie.ON])), this.location.length > 1 && t.append(S.toLocationSymbol(this.location[Ie.RIGHT])), t.toString()
                }, Te.prototype.setLocations = function(t, e, n) {
                    this.location[Ie.ON] = t, this.location[Ie.LEFT] = e, this.location[Ie.RIGHT] = n
                }, Te.prototype.get = function(t) {
                    return t < this.location.length ? this.location[t] : S.NONE
                }, Te.prototype.isArea = function() {
                    return this.location.length > 1
                }, Te.prototype.isAnyNull = function() {
                    for (var t = 0; t < this.location.length; t++)
                        if (this.location[t] === S.NONE) return !0;
                    return !1
                }, Te.prototype.setLocation = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        this.setLocation(Ie.ON, t)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        this.location[e] = n
                    }
                }, Te.prototype.init = function(t) {
                    this.location = new Array(t).fill(null), this.setAllLocations(S.NONE)
                }, Te.prototype.isEqualOnSide = function(t, e) {
                    return this.location[e] === t.location[e]
                }, Te.prototype.allPositionsEqual = function(t) {
                    for (var e = 0; e < this.location.length; e++)
                        if (this.location[e] !== t) return !1;
                    return !0
                }, Te.prototype.interfaces_ = function() {
                    return []
                }, Te.prototype.getClass = function() {
                    return Te
                };
                var Oe = function t() {
                    if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
                        if (Number.isInteger(arguments[0])) {
                            var e = arguments[0];
                            this.elt[0] = new Te(e), this.elt[1] = new Te(e)
                        } else if (arguments[0] instanceof t) {
                            var n = arguments[0];
                            this.elt[0] = new Te(n.elt[0]), this.elt[1] = new Te(n.elt[1])
                        }
                    } else if (2 === arguments.length) {
                        var i = arguments[0],
                            o = arguments[1];
                        this.elt[0] = new Te(S.NONE), this.elt[1] = new Te(S.NONE), this.elt[i].setLocation(o)
                    } else if (3 === arguments.length) {
                        var r = arguments[0],
                            s = arguments[1],
                            a = arguments[2];
                        this.elt[0] = new Te(r, s, a), this.elt[1] = new Te(r, s, a)
                    } else if (4 === arguments.length) {
                        var h = arguments[0],
                            u = arguments[1],
                            l = arguments[2],
                            c = arguments[3];
                        this.elt[0] = new Te(S.NONE, S.NONE, S.NONE), this.elt[1] = new Te(S.NONE, S.NONE, S.NONE), this.elt[h].setLocations(u, l, c)
                    }
                };
                Oe.prototype.getGeometryCount = function() {
                    var t = 0;
                    return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t
                }, Oe.prototype.setAllLocations = function(t, e) {
                    this.elt[t].setAllLocations(e)
                }, Oe.prototype.isNull = function(t) {
                    return this.elt[t].isNull()
                }, Oe.prototype.setAllLocationsIfNull = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        this.elt[e].setAllLocationsIfNull(n)
                    }
                }, Oe.prototype.isLine = function(t) {
                    return this.elt[t].isLine()
                }, Oe.prototype.merge = function(t) {
                    for (var e = 0; e < 2; e++) null === this.elt[e] && null !== t.elt[e] ? this.elt[e] = new Te(t.elt[e]) : this.elt[e].merge(t.elt[e])
                }, Oe.prototype.flip = function() {
                    this.elt[0].flip(), this.elt[1].flip()
                }, Oe.prototype.getLocation = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return this.elt[t].get(Ie.ON)
                    }
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        return this.elt[e].get(n)
                    }
                }, Oe.prototype.toString = function() {
                    var t = new A;
                    return null !== this.elt[0] && (t.append("A:"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(" B:"), t.append(this.elt[1].toString())), t.toString()
                }, Oe.prototype.isArea = function() {
                    if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return this.elt[t].isArea()
                    }
                }, Oe.prototype.isAnyNull = function(t) {
                    return this.elt[t].isAnyNull()
                }, Oe.prototype.setLocation = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        this.elt[t].setLocation(Ie.ON, e)
                    } else if (3 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1],
                            o = arguments[2];
                        this.elt[n].setLocation(i, o)
                    }
                }, Oe.prototype.isEqualOnSide = function(t, e) {
                    return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e)
                }, Oe.prototype.allPositionsEqual = function(t, e) {
                    return this.elt[t].allPositionsEqual(e)
                }, Oe.prototype.toLine = function(t) {
                    this.elt[t].isArea() && (this.elt[t] = new Te(this.elt[t].location[0]))
                }, Oe.prototype.interfaces_ = function() {
                    return []
                }, Oe.prototype.getClass = function() {
                    return Oe
                }, Oe.toLineLabel = function(t) {
                    for (var e = new Oe(S.NONE), n = 0; n < 2; n++) e.setLocation(n, t.getLocation(n));
                    return e
                };
                var Ae = function() {
                    this._startDe = null, this._maxNodeDegree = -1, this._edges = new Et, this._pts = new Et, this._label = new Oe(S.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new Et, this._geometryFactory = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this._geometryFactory = e, this.computePoints(t), this.computeRing()
                };
                Ae.prototype.computeRing = function() {
                    if (null !== this._ring) return null;
                    for (var t = new Array(this._pts.size()).fill(null), e = 0; e < this._pts.size(); e++) t[e] = this._pts.get(e);
                    this._ring = this._geometryFactory.createLinearRing(t), this._isHole = at.isCCW(this._ring.getCoordinates())
                }, Ae.prototype.isIsolated = function() {
                    return 1 === this._label.getGeometryCount()
                }, Ae.prototype.computePoints = function(t) {
                    this._startDe = t;
                    var e = t,
                        n = !0;
                    do {
                        if (null === e) throw new Se("Found null DirectedEdge");
                        if (e.getEdgeRing() === this) throw new Se("Directed Edge visited twice during ring-building at " + e.getCoordinate());
                        this._edges.add(e);
                        var i = e.getLabel();
                        et.isTrue(i.isArea()), this.mergeLabel(i), this.addPoints(e.getEdge(), e.isForward(), n), n = !1, this.setEdgeRing(e, this), e = this.getNext(e)
                    } while (e !== this._startDe)
                }, Ae.prototype.getLinearRing = function() {
                    return this._ring
                }, Ae.prototype.getCoordinate = function(t) {
                    return this._pts.get(t)
                }, Ae.prototype.computeMaxNodeDegree = function() {
                    this._maxNodeDegree = 0;
                    var t = this._startDe;
                    do {
                        var e = t.getNode().getEdges().getOutgoingDegree(this);
                        e > this._maxNodeDegree && (this._maxNodeDegree = e), t = this.getNext(t)
                    } while (t !== this._startDe);
                    this._maxNodeDegree *= 2
                }, Ae.prototype.addPoints = function(t, e, n) {
                    var i = t.getCoordinates();
                    if (e) {
                        var o = 1;
                        n && (o = 0);
                        for (var r = o; r < i.length; r++) this._pts.add(i[r])
                    } else {
                        var s = i.length - 2;
                        n && (s = i.length - 1);
                        for (var a = s; a >= 0; a--) this._pts.add(i[a])
                    }
                }, Ae.prototype.isHole = function() {
                    return this._isHole
                }, Ae.prototype.setInResult = function() {
                    var t = this._startDe;
                    do {
                        t.getEdge().setInResult(!0), t = t.getNext()
                    } while (t !== this._startDe)
                }, Ae.prototype.containsPoint = function(t) {
                    var e = this.getLinearRing();
                    if (!e.getEnvelopeInternal().contains(t)) return !1;
                    if (!at.isPointInRing(t, e.getCoordinates())) return !1;
                    for (var n = this._holes.iterator(); n.hasNext();)
                        if (n.next().containsPoint(t)) return !1;
                    return !0
                }, Ae.prototype.addHole = function(t) {
                    this._holes.add(t)
                }, Ae.prototype.isShell = function() {
                    return null === this._shell
                }, Ae.prototype.getLabel = function() {
                    return this._label
                }, Ae.prototype.getEdges = function() {
                    return this._edges
                }, Ae.prototype.getMaxNodeDegree = function() {
                    return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree
                }, Ae.prototype.getShell = function() {
                    return this._shell
                }, Ae.prototype.mergeLabel = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        this.mergeLabel(t, 0), this.mergeLabel(t, 1)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1],
                            i = e.getLocation(n, Ie.RIGHT);
                        if (i === S.NONE) return null;
                        if (this._label.getLocation(n) === S.NONE) return this._label.setLocation(n, i), null
                    }
                }, Ae.prototype.setShell = function(t) {
                    this._shell = t, null !== t && t.addHole(this)
                }, Ae.prototype.toPolygon = function(t) {
                    for (var e = new Array(this._holes.size()).fill(null), n = 0; n < this._holes.size(); n++) e[n] = this._holes.get(n).getLinearRing();
                    return t.createPolygon(this.getLinearRing(), e)
                }, Ae.prototype.interfaces_ = function() {
                    return []
                }, Ae.prototype.getClass = function() {
                    return Ae
                };
                var Re = function(t) {
                        function e() {
                            var e = arguments[0],
                                n = arguments[1];
                            t.call(this, e, n)
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.setEdgeRing = function(t, e) {
                            t.setMinEdgeRing(e)
                        }, e.prototype.getNext = function(t) {
                            return t.getNextMin()
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e
                    }(Ae),
                    De = function(t) {
                        function e() {
                            var e = arguments[0],
                                n = arguments[1];
                            t.call(this, e, n)
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.buildMinimalRings = function() {
                            var t = new Et,
                                e = this._startDe;
                            do {
                                if (null === e.getMinEdgeRing()) {
                                    var n = new Re(e, this._geometryFactory);
                                    t.add(n)
                                }
                                e = e.getNext()
                            } while (e !== this._startDe);
                            return t
                        }, e.prototype.setEdgeRing = function(t, e) {
                            t.setEdgeRing(e)
                        }, e.prototype.linkDirectedEdgesForMinimalEdgeRings = function() {
                            var t = this._startDe;
                            do {
                                t.getNode().getEdges().linkMinimalDirectedEdges(this), t = t.getNext()
                            } while (t !== this._startDe)
                        }, e.prototype.getNext = function(t) {
                            return t.getNext()
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e
                    }(Ae),
                    ke = function() {
                        if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length);
                        else if (1 === arguments.length) {
                            var t = arguments[0];
                            this._label = t
                        }
                    };
                ke.prototype.setVisited = function(t) {
                    this._isVisited = t
                }, ke.prototype.setInResult = function(t) {
                    this._isInResult = t
                }, ke.prototype.isCovered = function() {
                    return this._isCovered
                }, ke.prototype.isCoveredSet = function() {
                    return this._isCoveredSet
                }, ke.prototype.setLabel = function(t) {
                    this._label = t
                }, ke.prototype.getLabel = function() {
                    return this._label
                }, ke.prototype.setCovered = function(t) {
                    this._isCovered = t, this._isCoveredSet = !0
                }, ke.prototype.updateIM = function(t) {
                    et.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t)
                }, ke.prototype.isInResult = function() {
                    return this._isInResult
                }, ke.prototype.isVisited = function() {
                    return this._isVisited
                }, ke.prototype.interfaces_ = function() {
                    return []
                }, ke.prototype.getClass = function() {
                    return ke
                };
                var Fe = function(t) {
                        function e() {
                            t.call(this), this._coord = null, this._edges = null;
                            var e = arguments[0],
                                n = arguments[1];
                            this._coord = e, this._edges = n, this._label = new Oe(0, S.NONE)
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isIncidentEdgeInResult = function() {
                            for (var t = this.getEdges().getEdges().iterator(); t.hasNext();)
                                if (t.next().getEdge().isInResult()) return !0;
                            return !1
                        }, e.prototype.isIsolated = function() {
                            return 1 === this._label.getGeometryCount()
                        }, e.prototype.getCoordinate = function() {
                            return this._coord
                        }, e.prototype.print = function(t) {
                            t.println("node " + this._coord + " lbl: " + this._label)
                        }, e.prototype.computeIM = function(t) {}, e.prototype.computeMergedLocation = function(t, e) {
                            var n = S.NONE;
                            if (n = this._label.getLocation(e), !t.isNull(e)) {
                                var i = t.getLocation(e);
                                n !== S.BOUNDARY && (n = i)
                            }
                            return n
                        }, e.prototype.setLabel = function() {
                            if (2 !== arguments.length) return t.prototype.setLabel.apply(this, arguments);
                            var e = arguments[0],
                                n = arguments[1];
                            null === this._label ? this._label = new Oe(e, n) : this._label.setLocation(e, n)
                        }, e.prototype.getEdges = function() {
                            return this._edges
                        }, e.prototype.mergeLabel = function() {
                            if (arguments[0] instanceof e) {
                                var t = arguments[0];
                                this.mergeLabel(t._label)
                            } else if (arguments[0] instanceof Oe)
                                for (var n = arguments[0], i = 0; i < 2; i++) {
                                    var o = this.computeMergedLocation(n, i);
                                    this._label.getLocation(i) === S.NONE && this._label.setLocation(i, o)
                                }
                        }, e.prototype.add = function(t) {
                            this._edges.insert(t), t.setNode(this)
                        }, e.prototype.setLabelBoundary = function(t) {
                            if (null === this._label) return null;
                            var e = S.NONE;
                            null !== this._label && (e = this._label.getLocation(t));
                            var n = null;
                            switch (e) {
                                case S.BOUNDARY:
                                    n = S.INTERIOR;
                                    break;
                                case S.INTERIOR:
                                default:
                                    n = S.BOUNDARY
                            }
                            this._label.setLocation(t, n)
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e
                    }(ke),
                    ze = function() {
                        this.nodeMap = new c, this.nodeFact = null;
                        var t = arguments[0];
                        this.nodeFact = t
                    };
                ze.prototype.find = function(t) {
                    return this.nodeMap.get(t)
                }, ze.prototype.addNode = function() {
                    if (arguments[0] instanceof C) {
                        var t = arguments[0],
                            e = this.nodeMap.get(t);
                        return null === e && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e
                    }
                    if (arguments[0] instanceof Fe) {
                        var n = arguments[0],
                            i = this.nodeMap.get(n.getCoordinate());
                        return null === i ? (this.nodeMap.put(n.getCoordinate(), n), n) : (i.mergeLabel(n), i)
                    }
                }, ze.prototype.print = function(t) {
                    for (var e = this.iterator(); e.hasNext();) e.next().print(t)
                }, ze.prototype.iterator = function() {
                    return this.nodeMap.values().iterator()
                }, ze.prototype.values = function() {
                    return this.nodeMap.values()
                }, ze.prototype.getBoundaryNodes = function(t) {
                    for (var e = new Et, n = this.iterator(); n.hasNext();) {
                        var i = n.next();
                        i.getLabel().getLocation(t) === S.BOUNDARY && e.add(i)
                    }
                    return e
                }, ze.prototype.add = function(t) {
                    var e = t.getCoordinate();
                    this.addNode(e).add(t)
                }, ze.prototype.interfaces_ = function() {
                    return []
                }, ze.prototype.getClass = function() {
                    return ze
                };
                var Be = function() {},
                    Ge = {
                        NE: {
                            configurable: !0
                        },
                        NW: {
                            configurable: !0
                        },
                        SW: {
                            configurable: !0
                        },
                        SE: {
                            configurable: !0
                        }
                    };
                Be.prototype.interfaces_ = function() {
                    return []
                }, Be.prototype.getClass = function() {
                    return Be
                }, Be.isNorthern = function(t) {
                    return t === Be.NE || t === Be.NW
                }, Be.isOpposite = function(t, e) {
                    return t !== e && 2 == (t - e + 4) % 4
                }, Be.commonHalfPlane = function(t, e) {
                    if (t === e) return t;
                    if (2 == (t - e + 4) % 4) return -1;
                    var n = t < e ? t : e;
                    return 0 === n && 3 === (t > e ? t : e) ? 3 : n
                }, Be.isInHalfPlane = function(t, e) {
                    return e === Be.SE ? t === Be.SE || t === Be.SW : t === e || t === e + 1
                }, Be.quadrant = function() {
                    if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                        var t = arguments[0],
                            e = arguments[1];
                        if (0 === t && 0 === e) throw new y("Cannot compute the quadrant for point ( " + t + ", " + e + " )");
                        return t >= 0 ? e >= 0 ? Be.NE : Be.SE : e >= 0 ? Be.NW : Be.SW
                    }
                    if (arguments[0] instanceof C && arguments[1] instanceof C) {
                        var n = arguments[0],
                            i = arguments[1];
                        if (i.x === n.x && i.y === n.y) throw new y("Cannot compute the quadrant for two identical points " + n);
                        return i.x >= n.x ? i.y >= n.y ? Be.NE : Be.SE : i.y >= n.y ? Be.NW : Be.SW
                    }
                }, Ge.NE.get = function() {
                    return 0
                }, Ge.NW.get = function() {
                    return 1
                }, Ge.SW.get = function() {
                    return 2
                }, Ge.SE.get = function() {
                    return 3
                }, Object.defineProperties(Be, Ge);
                var Ue = function() {
                    if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {
                        var t = arguments[0];
                        this._edge = t
                    } else if (3 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1],
                            i = arguments[2];
                        this._edge = e, this.init(n, i), this._label = null
                    } else if (4 === arguments.length) {
                        var o = arguments[0],
                            r = arguments[1],
                            s = arguments[2],
                            a = arguments[3];
                        this._edge = o, this.init(r, s), this._label = a
                    }
                };
                Ue.prototype.compareDirection = function(t) {
                    return this._dx === t._dx && this._dy === t._dy ? 0 : this._quadrant > t._quadrant ? 1 : this._quadrant < t._quadrant ? -1 : at.computeOrientation(t._p0, t._p1, this._p1)
                }, Ue.prototype.getDy = function() {
                    return this._dy
                }, Ue.prototype.getCoordinate = function() {
                    return this._p0
                }, Ue.prototype.setNode = function(t) {
                    this._node = t
                }, Ue.prototype.print = function(t) {
                    var e = Math.atan2(this._dy, this._dx),
                        n = this.getClass().getName(),
                        i = n.lastIndexOf("."),
                        o = n.substring(i + 1);
                    t.print("  " + o + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e + "   " + this._label)
                }, Ue.prototype.compareTo = function(t) {
                    var e = t;
                    return this.compareDirection(e)
                }, Ue.prototype.getDirectedCoordinate = function() {
                    return this._p1
                }, Ue.prototype.getDx = function() {
                    return this._dx
                }, Ue.prototype.getLabel = function() {
                    return this._label
                }, Ue.prototype.getEdge = function() {
                    return this._edge
                }, Ue.prototype.getQuadrant = function() {
                    return this._quadrant
                }, Ue.prototype.getNode = function() {
                    return this._node
                }, Ue.prototype.toString = function() {
                    var t = Math.atan2(this._dy, this._dx),
                        e = this.getClass().getName(),
                        n = e.lastIndexOf(".");
                    return "  " + e.substring(n + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t + "   " + this._label
                }, Ue.prototype.computeLabel = function(t) {}, Ue.prototype.init = function(t, e) {
                    this._p0 = t, this._p1 = e, this._dx = e.x - t.x, this._dy = e.y - t.y, this._quadrant = Be.quadrant(this._dx, this._dy), et.isTrue(!(0 === this._dx && 0 === this._dy), "EdgeEnd with identical endpoints found")
                }, Ue.prototype.interfaces_ = function() {
                    return [x]
                }, Ue.prototype.getClass = function() {
                    return Ue
                };
                var je = function(t) {
                        function e() {
                            var e = arguments[0],
                                n = arguments[1];
                            if (t.call(this, e), this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999], this._isForward = n, n) this.init(e.getCoordinate(0), e.getCoordinate(1));
                            else {
                                var i = e.getNumPoints() - 1;
                                this.init(e.getCoordinate(i), e.getCoordinate(i - 1))
                            }
                            this.computeDirectedLabel()
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getNextMin = function() {
                            return this._nextMin
                        }, e.prototype.getDepth = function(t) {
                            return this._depth[t]
                        }, e.prototype.setVisited = function(t) {
                            this._isVisited = t
                        }, e.prototype.computeDirectedLabel = function() {
                            this._label = new Oe(this._edge.getLabel()), this._isForward || this._label.flip()
                        }, e.prototype.getNext = function() {
                            return this._next
                        }, e.prototype.setDepth = function(t, e) {
                            if (-999 !== this._depth[t] && this._depth[t] !== e) throw new Se("assigned depths do not match", this.getCoordinate());
                            this._depth[t] = e
                        }, e.prototype.isInteriorAreaEdge = function() {
                            for (var t = !0, e = 0; e < 2; e++) this._label.isArea(e) && this._label.getLocation(e, Ie.LEFT) === S.INTERIOR && this._label.getLocation(e, Ie.RIGHT) === S.INTERIOR || (t = !1);
                            return t
                        }, e.prototype.setNextMin = function(t) {
                            this._nextMin = t
                        }, e.prototype.print = function(e) {
                            t.prototype.print.call(this, e), e.print(" " + this._depth[Ie.LEFT] + "/" + this._depth[Ie.RIGHT]), e.print(" (" + this.getDepthDelta() + ")"), this._isInResult && e.print(" inResult")
                        }, e.prototype.setMinEdgeRing = function(t) {
                            this._minEdgeRing = t
                        }, e.prototype.isLineEdge = function() {
                            var t = this._label.isLine(0) || this._label.isLine(1),
                                e = !this._label.isArea(0) || this._label.allPositionsEqual(0, S.EXTERIOR),
                                n = !this._label.isArea(1) || this._label.allPositionsEqual(1, S.EXTERIOR);
                            return t && e && n
                        }, e.prototype.setEdgeRing = function(t) {
                            this._edgeRing = t
                        }, e.prototype.getMinEdgeRing = function() {
                            return this._minEdgeRing
                        }, e.prototype.getDepthDelta = function() {
                            var t = this._edge.getDepthDelta();
                            return this._isForward || (t = -t), t
                        }, e.prototype.setInResult = function(t) {
                            this._isInResult = t
                        }, e.prototype.getSym = function() {
                            return this._sym
                        }, e.prototype.isForward = function() {
                            return this._isForward
                        }, e.prototype.getEdge = function() {
                            return this._edge
                        }, e.prototype.printEdge = function(t) {
                            this.print(t), t.print(" "), this._isForward ? this._edge.print(t) : this._edge.printReverse(t)
                        }, e.prototype.setSym = function(t) {
                            this._sym = t
                        }, e.prototype.setVisitedEdge = function(t) {
                            this.setVisited(t), this._sym.setVisited(t)
                        }, e.prototype.setEdgeDepths = function(t, e) {
                            var n = this.getEdge().getDepthDelta();
                            this._isForward || (n = -n);
                            var i = 1;
                            t === Ie.LEFT && (i = -1);
                            var o = Ie.opposite(t),
                                r = e + n * i;
                            this.setDepth(t, e), this.setDepth(o, r)
                        }, e.prototype.getEdgeRing = function() {
                            return this._edgeRing
                        }, e.prototype.isInResult = function() {
                            return this._isInResult
                        }, e.prototype.setNext = function(t) {
                            this._next = t
                        }, e.prototype.isVisited = function() {
                            return this._isVisited
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e.depthFactor = function(t, e) {
                            return t === S.EXTERIOR && e === S.INTERIOR ? 1 : t === S.INTERIOR && e === S.EXTERIOR ? -1 : 0
                        }, e
                    }(Ue),
                    qe = function() {};
                qe.prototype.createNode = function(t) {
                    return new Fe(t, null)
                }, qe.prototype.interfaces_ = function() {
                    return []
                }, qe.prototype.getClass = function() {
                    return qe
                };
                var Ze = function() {
                    if (this._edges = new Et, this._nodes = null, this._edgeEndList = new Et, 0 === arguments.length) this._nodes = new ze(new qe);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this._nodes = new ze(t)
                    }
                };
                Ze.prototype.printEdges = function(t) {
                    t.println("Edges:");
                    for (var e = 0; e < this._edges.size(); e++) {
                        t.println("edge " + e + ":");
                        var n = this._edges.get(e);
                        n.print(t), n.eiList.print(t)
                    }
                }, Ze.prototype.find = function(t) {
                    return this._nodes.find(t)
                }, Ze.prototype.addNode = function() {
                    if (arguments[0] instanceof Fe) {
                        var t = arguments[0];
                        return this._nodes.addNode(t)
                    }
                    if (arguments[0] instanceof C) {
                        var e = arguments[0];
                        return this._nodes.addNode(e)
                    }
                }, Ze.prototype.getNodeIterator = function() {
                    return this._nodes.iterator()
                }, Ze.prototype.linkResultDirectedEdges = function() {
                    for (var t = this._nodes.iterator(); t.hasNext();) t.next().getEdges().linkResultDirectedEdges()
                }, Ze.prototype.debugPrintln = function(t) {
                    Z.out.println(t)
                }, Ze.prototype.isBoundaryNode = function(t, e) {
                    var n = this._nodes.find(e);
                    if (null === n) return !1;
                    var i = n.getLabel();
                    return null !== i && i.getLocation(t) === S.BOUNDARY
                }, Ze.prototype.linkAllDirectedEdges = function() {
                    for (var t = this._nodes.iterator(); t.hasNext();) t.next().getEdges().linkAllDirectedEdges()
                }, Ze.prototype.matchInSameDirection = function(t, e, n, i) {
                    return !!t.equals(n) && at.computeOrientation(t, e, i) === at.COLLINEAR && Be.quadrant(t, e) === Be.quadrant(n, i)
                }, Ze.prototype.getEdgeEnds = function() {
                    return this._edgeEndList
                }, Ze.prototype.debugPrint = function(t) {
                    Z.out.print(t)
                }, Ze.prototype.getEdgeIterator = function() {
                    return this._edges.iterator()
                }, Ze.prototype.findEdgeInSameDirection = function(t, e) {
                    for (var n = 0; n < this._edges.size(); n++) {
                        var i = this._edges.get(n),
                            o = i.getCoordinates();
                        if (this.matchInSameDirection(t, e, o[0], o[1])) return i;
                        if (this.matchInSameDirection(t, e, o[o.length - 1], o[o.length - 2])) return i
                    }
                    return null
                }, Ze.prototype.insertEdge = function(t) {
                    this._edges.add(t)
                }, Ze.prototype.findEdgeEnd = function(t) {
                    for (var e = this.getEdgeEnds().iterator(); e.hasNext();) {
                        var n = e.next();
                        if (n.getEdge() === t) return n
                    }
                    return null
                }, Ze.prototype.addEdges = function(t) {
                    for (var e = t.iterator(); e.hasNext();) {
                        var n = e.next();
                        this._edges.add(n);
                        var i = new je(n, !0),
                            o = new je(n, !1);
                        i.setSym(o), o.setSym(i), this.add(i), this.add(o)
                    }
                }, Ze.prototype.add = function(t) {
                    this._nodes.add(t), this._edgeEndList.add(t)
                }, Ze.prototype.getNodes = function() {
                    return this._nodes.values()
                }, Ze.prototype.findEdge = function(t, e) {
                    for (var n = 0; n < this._edges.size(); n++) {
                        var i = this._edges.get(n),
                            o = i.getCoordinates();
                        if (t.equals(o[0]) && e.equals(o[1])) return i
                    }
                    return null
                }, Ze.prototype.interfaces_ = function() {
                    return []
                }, Ze.prototype.getClass = function() {
                    return Ze
                }, Ze.linkResultDirectedEdges = function(t) {
                    for (var e = t.iterator(); e.hasNext();) e.next().getEdges().linkResultDirectedEdges()
                };
                var Ve = function() {
                    this._geometryFactory = null, this._shellList = new Et;
                    var t = arguments[0];
                    this._geometryFactory = t
                };
                Ve.prototype.sortShellsAndHoles = function(t, e, n) {
                    for (var i = t.iterator(); i.hasNext();) {
                        var o = i.next();
                        o.isHole() ? n.add(o) : e.add(o)
                    }
                }, Ve.prototype.computePolygons = function(t) {
                    for (var e = new Et, n = t.iterator(); n.hasNext();) {
                        var i = n.next().toPolygon(this._geometryFactory);
                        e.add(i)
                    }
                    return e
                }, Ve.prototype.placeFreeHoles = function(t, e) {
                    for (var n = e.iterator(); n.hasNext();) {
                        var i = n.next();
                        if (null === i.getShell()) {
                            var o = this.findEdgeRingContaining(i, t);
                            if (null === o) throw new Se("unable to assign hole to a shell", i.getCoordinate(0));
                            i.setShell(o)
                        }
                    }
                }, Ve.prototype.buildMinimalEdgeRings = function(t, e, n) {
                    for (var i = new Et, o = t.iterator(); o.hasNext();) {
                        var r = o.next();
                        if (r.getMaxNodeDegree() > 2) {
                            r.linkDirectedEdgesForMinimalEdgeRings();
                            var s = r.buildMinimalRings(),
                                a = this.findShell(s);
                            null !== a ? (this.placePolygonHoles(a, s), e.add(a)) : n.addAll(s)
                        } else i.add(r)
                    }
                    return i
                }, Ve.prototype.containsPoint = function(t) {
                    for (var e = this._shellList.iterator(); e.hasNext();)
                        if (e.next().containsPoint(t)) return !0;
                    return !1
                }, Ve.prototype.buildMaximalEdgeRings = function(t) {
                    for (var e = new Et, n = t.iterator(); n.hasNext();) {
                        var i = n.next();
                        if (i.isInResult() && i.getLabel().isArea() && null === i.getEdgeRing()) {
                            var o = new De(i, this._geometryFactory);
                            e.add(o), o.setInResult()
                        }
                    }
                    return e
                }, Ve.prototype.placePolygonHoles = function(t, e) {
                    for (var n = e.iterator(); n.hasNext();) {
                        var i = n.next();
                        i.isHole() && i.setShell(t)
                    }
                }, Ve.prototype.getPolygons = function() {
                    return this.computePolygons(this._shellList)
                }, Ve.prototype.findEdgeRingContaining = function(t, e) {
                    for (var n = t.getLinearRing(), i = n.getEnvelopeInternal(), o = n.getCoordinateN(0), r = null, s = null, a = e.iterator(); a.hasNext();) {
                        var h = a.next(),
                            u = h.getLinearRing(),
                            l = u.getEnvelopeInternal();
                        null !== r && (s = r.getLinearRing().getEnvelopeInternal());
                        var c = !1;
                        l.contains(i) && at.isPointInRing(o, u.getCoordinates()) && (c = !0), c && (null === r || s.contains(l)) && (r = h)
                    }
                    return r
                }, Ve.prototype.findShell = function(t) {
                    for (var e = 0, n = null, i = t.iterator(); i.hasNext();) {
                        var o = i.next();
                        o.isHole() || (n = o, e++)
                    }
                    return et.isTrue(e <= 1, "found two shells in MinimalEdgeRing list"), n
                }, Ve.prototype.add = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        this.add(t.getEdgeEnds(), t.getNodes())
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        Ze.linkResultDirectedEdges(n);
                        var i = this.buildMaximalEdgeRings(e),
                            o = new Et,
                            r = this.buildMinimalEdgeRings(i, this._shellList, o);
                        this.sortShellsAndHoles(r, this._shellList, o), this.placeFreeHoles(this._shellList, o)
                    }
                }, Ve.prototype.interfaces_ = function() {
                    return []
                }, Ve.prototype.getClass = function() {
                    return Ve
                };
                var He = function() {};
                He.prototype.getBounds = function() {}, He.prototype.interfaces_ = function() {
                    return []
                }, He.prototype.getClass = function() {
                    return He
                };
                var Ye = function() {
                    this._bounds = null, this._item = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this._bounds = t, this._item = e
                };
                Ye.prototype.getItem = function() {
                    return this._item
                }, Ye.prototype.getBounds = function() {
                    return this._bounds
                }, Ye.prototype.interfaces_ = function() {
                    return [He, e]
                }, Ye.prototype.getClass = function() {
                    return Ye
                };
                var We = function() {
                    this._size = null, this._items = null, this._size = 0, this._items = new Et, this._items.add(null)
                };
                We.prototype.poll = function() {
                    if (this.isEmpty()) return null;
                    var t = this._items.get(1);
                    return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t
                }, We.prototype.size = function() {
                    return this._size
                }, We.prototype.reorder = function(t) {
                    for (var e = null, n = this._items.get(t); 2 * t <= this._size && ((e = 2 * t) !== this._size && this._items.get(e + 1).compareTo(this._items.get(e)) < 0 && e++, this._items.get(e).compareTo(n) < 0); t = e) this._items.set(t, this._items.get(e));
                    this._items.set(t, n)
                }, We.prototype.clear = function() {
                    this._size = 0, this._items.clear()
                }, We.prototype.isEmpty = function() {
                    return 0 === this._size
                }, We.prototype.add = function(t) {
                    this._items.add(null), this._size += 1;
                    var e = this._size;
                    for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(e / 2))) < 0; e /= 2) this._items.set(e, this._items.get(Math.trunc(e / 2)));
                    this._items.set(e, t)
                }, We.prototype.interfaces_ = function() {
                    return []
                }, We.prototype.getClass = function() {
                    return We
                };
                var Xe = function() {};
                Xe.prototype.visitItem = function(t) {}, Xe.prototype.interfaces_ = function() {
                    return []
                }, Xe.prototype.getClass = function() {
                    return Xe
                };
                var Je = function() {};
                Je.prototype.insert = function(t, e) {}, Je.prototype.remove = function(t, e) {}, Je.prototype.query = function() {}, Je.prototype.interfaces_ = function() {
                    return []
                }, Je.prototype.getClass = function() {
                    return Je
                };
                var Ke = function() {
                        if (this._childBoundables = new Et, this._bounds = null, this._level = null, 0 === arguments.length);
                        else if (1 === arguments.length) {
                            var t = arguments[0];
                            this._level = t
                        }
                    },
                    Qe = {
                        serialVersionUID: {
                            configurable: !0
                        }
                    };
                Ke.prototype.getLevel = function() {
                    return this._level
                }, Ke.prototype.size = function() {
                    return this._childBoundables.size()
                }, Ke.prototype.getChildBoundables = function() {
                    return this._childBoundables
                }, Ke.prototype.addChildBoundable = function(t) {
                    et.isTrue(null === this._bounds), this._childBoundables.add(t)
                }, Ke.prototype.isEmpty = function() {
                    return this._childBoundables.isEmpty()
                }, Ke.prototype.getBounds = function() {
                    return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds
                }, Ke.prototype.interfaces_ = function() {
                    return [He, e]
                }, Ke.prototype.getClass = function() {
                    return Ke
                }, Qe.serialVersionUID.get = function() {
                    return 0x5a1e55ec41369800
                }, Object.defineProperties(Ke, Qe);
                var $e = function() {};
                $e.reverseOrder = function() {
                    return {
                        compare: function(t, e) {
                            return e.compareTo(t)
                        }
                    }
                }, $e.min = function(t) {
                    return $e.sort(t), t.get(0)
                }, $e.sort = function(t, e) {
                    var n = t.toArray();
                    e ? Ft.sort(n, e) : Ft.sort(n);
                    for (var i = t.iterator(), o = 0, r = n.length; o < r; o++) i.next(), i.set(n[o])
                }, $e.singletonList = function(t) {
                    var e = new Et;
                    return e.add(t), e
                };
                var tn = function() {
                    this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
                    var t = arguments[0],
                        e = arguments[1],
                        n = arguments[2];
                    this._boundable1 = t, this._boundable2 = e, this._itemDistance = n, this._distance = this.distance()
                };
                tn.prototype.expandToQueue = function(t, e) {
                    var n = tn.isComposite(this._boundable1),
                        i = tn.isComposite(this._boundable2);
                    if (n && i) return tn.area(this._boundable1) > tn.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, t, e), null) : (this.expand(this._boundable2, this._boundable1, t, e), null);
                    if (n) return this.expand(this._boundable1, this._boundable2, t, e), null;
                    if (i) return this.expand(this._boundable2, this._boundable1, t, e), null;
                    throw new y("neither boundable is composite")
                }, tn.prototype.isLeaves = function() {
                    return !(tn.isComposite(this._boundable1) || tn.isComposite(this._boundable2))
                }, tn.prototype.compareTo = function(t) {
                    var e = t;
                    return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0
                }, tn.prototype.expand = function(t, e, n, i) {
                    for (var o = t.getChildBoundables().iterator(); o.hasNext();) {
                        var r = o.next(),
                            s = new tn(r, e, this._itemDistance);
                        s.getDistance() < i && n.add(s)
                    }
                }, tn.prototype.getBoundable = function(t) {
                    return 0 === t ? this._boundable1 : this._boundable2
                }, tn.prototype.getDistance = function() {
                    return this._distance
                }, tn.prototype.distance = function() {
                    return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds())
                }, tn.prototype.interfaces_ = function() {
                    return [x]
                }, tn.prototype.getClass = function() {
                    return tn
                }, tn.area = function(t) {
                    return t.getBounds().getArea()
                }, tn.isComposite = function(t) {
                    return t instanceof Ke
                };
                var en = function t() {
                        if (this._root = null, this._built = !1, this._itemBoundables = new Et, this._nodeCapacity = null, 0 === arguments.length) {
                            var e = t.DEFAULT_NODE_CAPACITY;
                            this._nodeCapacity = e
                        } else if (1 === arguments.length) {
                            var n = arguments[0];
                            et.isTrue(n > 1, "Node capacity must be greater than 1"), this._nodeCapacity = n
                        }
                    },
                    nn = {
                        IntersectsOp: {
                            configurable: !0
                        },
                        serialVersionUID: {
                            configurable: !0
                        },
                        DEFAULT_NODE_CAPACITY: {
                            configurable: !0
                        }
                    };
                en.prototype.getNodeCapacity = function() {
                    return this._nodeCapacity
                }, en.prototype.lastNode = function(t) {
                    return t.get(t.size() - 1)
                }, en.prototype.size = function() {
                    if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
                    if (1 === arguments.length) {
                        for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) {
                            var n = e.next();
                            n instanceof Ke ? t += this.size(n) : n instanceof Ye && (t += 1)
                        }
                        return t
                    }
                }, en.prototype.removeItem = function(t, e) {
                    for (var n = null, i = t.getChildBoundables().iterator(); i.hasNext();) {
                        var o = i.next();
                        o instanceof Ye && o.getItem() === e && (n = o)
                    }
                    return null !== n && (t.getChildBoundables().remove(n), !0)
                }, en.prototype.itemsTree = function() {
                    if (0 === arguments.length) {
                        this.build();
                        var t = this.itemsTree(this._root);
                        return null === t ? new Et : t
                    }
                    if (1 === arguments.length) {
                        for (var e = arguments[0], n = new Et, i = e.getChildBoundables().iterator(); i.hasNext();) {
                            var o = i.next();
                            if (o instanceof Ke) {
                                var r = this.itemsTree(o);
                                null !== r && n.add(r)
                            } else o instanceof Ye ? n.add(o.getItem()) : et.shouldNeverReachHere()
                        }
                        return n.size() <= 0 ? null : n
                    }
                }, en.prototype.insert = function(t, e) {
                    et.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new Ye(t, e))
                }, en.prototype.boundablesAtLevel = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0],
                            e = new Et;
                        return this.boundablesAtLevel(t, this._root, e), e
                    }
                    if (3 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1],
                            o = arguments[2];
                        if (et.isTrue(n > -2), i.getLevel() === n) return o.add(i), null;
                        for (var r = i.getChildBoundables().iterator(); r.hasNext();) {
                            var s = r.next();
                            s instanceof Ke ? this.boundablesAtLevel(n, s, o) : (et.isTrue(s instanceof Ye), -1 === n && o.add(s))
                        }
                        return null
                    }
                }, en.prototype.query = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        this.build();
                        var e = new Et;
                        return this.isEmpty() ? e : (this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.query(t, this._root, e), e)
                    }
                    if (2 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1];
                        if (this.build(), this.isEmpty()) return null;
                        this.getIntersectsOp().intersects(this._root.getBounds(), n) && this.query(n, this._root, i)
                    } else if (3 === arguments.length)
                        if (N(arguments[2], Xe) && arguments[0] instanceof Object && arguments[1] instanceof Ke)
                            for (var o = arguments[0], r = arguments[1], s = arguments[2], a = r.getChildBoundables(), h = 0; h < a.size(); h++) {
                                var u = a.get(h);
                                this.getIntersectsOp().intersects(u.getBounds(), o) && (u instanceof Ke ? this.query(o, u, s) : u instanceof Ye ? s.visitItem(u.getItem()) : et.shouldNeverReachHere())
                            } else if (N(arguments[2], bt) && arguments[0] instanceof Object && arguments[1] instanceof Ke)
                                for (var l = arguments[0], c = arguments[1], p = arguments[2], f = c.getChildBoundables(), d = 0; d < f.size(); d++) {
                                    var _ = f.get(d);
                                    this.getIntersectsOp().intersects(_.getBounds(), l) && (_ instanceof Ke ? this.query(l, _, p) : _ instanceof Ye ? p.add(_.getItem()) : et.shouldNeverReachHere())
                                }
                }, en.prototype.build = function() {
                    if (this._built) return null;
                    this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0
                }, en.prototype.getRoot = function() {
                    return this.build(), this._root
                }, en.prototype.remove = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.remove(t, this._root, e)
                    }
                    if (3 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1],
                            o = arguments[2],
                            r = this.removeItem(i, o);
                        if (r) return !0;
                        for (var s = null, a = i.getChildBoundables().iterator(); a.hasNext();) {
                            var h = a.next();
                            if (this.getIntersectsOp().intersects(h.getBounds(), n) && h instanceof Ke && (r = this.remove(n, h, o))) {
                                s = h;
                                break
                            }
                        }
                        return null !== s && s.getChildBoundables().isEmpty() && i.getChildBoundables().remove(s), r
                    }
                }, en.prototype.createHigherLevels = function(t, e) {
                    et.isTrue(!t.isEmpty());
                    var n = this.createParentBoundables(t, e + 1);
                    return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1)
                }, en.prototype.depth = function() {
                    if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
                    if (1 === arguments.length) {
                        for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) {
                            var n = e.next();
                            if (n instanceof Ke) {
                                var i = this.depth(n);
                                i > t && (t = i)
                            }
                        }
                        return t + 1
                    }
                }, en.prototype.createParentBoundables = function(t, e) {
                    et.isTrue(!t.isEmpty());
                    var n = new Et;
                    n.add(this.createNode(e));
                    var i = new Et(t);
                    $e.sort(i, this.getComparator());
                    for (var o = i.iterator(); o.hasNext();) {
                        var r = o.next();
                        this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() && n.add(this.createNode(e)), this.lastNode(n).addChildBoundable(r)
                    }
                    return n
                }, en.prototype.isEmpty = function() {
                    return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty()
                }, en.prototype.interfaces_ = function() {
                    return [e]
                }, en.prototype.getClass = function() {
                    return en
                }, en.compareDoubles = function(t, e) {
                    return t > e ? 1 : t < e ? -1 : 0
                }, nn.IntersectsOp.get = function() {
                    return on
                }, nn.serialVersionUID.get = function() {
                    return -0x35ef64c82d4c5400
                }, nn.DEFAULT_NODE_CAPACITY.get = function() {
                    return 10
                }, Object.defineProperties(en, nn);
                var on = function() {},
                    rn = function() {};
                rn.prototype.distance = function(t, e) {}, rn.prototype.interfaces_ = function() {
                    return []
                }, rn.prototype.getClass = function() {
                    return rn
                };
                var sn = function(t) {
                        function n(e) {
                            e = e || n.DEFAULT_NODE_CAPACITY, t.call(this, e)
                        }
                        t && (n.__proto__ = t), (n.prototype = Object.create(t && t.prototype)).constructor = n;
                        var i = {
                            STRtreeNode: {
                                configurable: !0
                            },
                            serialVersionUID: {
                                configurable: !0
                            },
                            xComparator: {
                                configurable: !0
                            },
                            yComparator: {
                                configurable: !0
                            },
                            intersectsOp: {
                                configurable: !0
                            },
                            DEFAULT_NODE_CAPACITY: {
                                configurable: !0
                            }
                        };
                        return n.prototype.createParentBoundablesFromVerticalSlices = function(t, e) {
                            et.isTrue(t.length > 0);
                            for (var n = new Et, i = 0; i < t.length; i++) n.addAll(this.createParentBoundablesFromVerticalSlice(t[i], e));
                            return n
                        }, n.prototype.createNode = function(t) {
                            return new an(t)
                        }, n.prototype.size = function() {
                            return 0 === arguments.length ? t.prototype.size.call(this) : t.prototype.size.apply(this, arguments)
                        }, n.prototype.insert = function() {
                            if (2 !== arguments.length) return t.prototype.insert.apply(this, arguments);
                            var e = arguments[0],
                                n = arguments[1];
                            if (e.isNull()) return null;
                            t.prototype.insert.call(this, e, n)
                        }, n.prototype.getIntersectsOp = function() {
                            return n.intersectsOp
                        }, n.prototype.verticalSlices = function(t, e) {
                            for (var n = Math.trunc(Math.ceil(t.size() / e)), i = new Array(e).fill(null), o = t.iterator(), r = 0; r < e; r++) {
                                i[r] = new Et;
                                for (var s = 0; o.hasNext() && s < n;) {
                                    var a = o.next();
                                    i[r].add(a), s++
                                }
                            }
                            return i
                        }, n.prototype.query = function() {
                            if (1 === arguments.length) {
                                var e = arguments[0];
                                return t.prototype.query.call(this, e)
                            }
                            if (2 === arguments.length) {
                                var n = arguments[0],
                                    i = arguments[1];
                                t.prototype.query.call(this, n, i)
                            } else if (3 === arguments.length)
                                if (N(arguments[2], Xe) && arguments[0] instanceof Object && arguments[1] instanceof Ke) {
                                    var o = arguments[0],
                                        r = arguments[1],
                                        s = arguments[2];
                                    t.prototype.query.call(this, o, r, s)
                                } else if (N(arguments[2], bt) && arguments[0] instanceof Object && arguments[1] instanceof Ke) {
                                var a = arguments[0],
                                    h = arguments[1],
                                    u = arguments[2];
                                t.prototype.query.call(this, a, h, u)
                            }
                        }, n.prototype.getComparator = function() {
                            return n.yComparator
                        }, n.prototype.createParentBoundablesFromVerticalSlice = function(e, n) {
                            return t.prototype.createParentBoundables.call(this, e, n)
                        }, n.prototype.remove = function() {
                            if (2 === arguments.length) {
                                var e = arguments[0],
                                    n = arguments[1];
                                return t.prototype.remove.call(this, e, n)
                            }
                            return t.prototype.remove.apply(this, arguments)
                        }, n.prototype.depth = function() {
                            return 0 === arguments.length ? t.prototype.depth.call(this) : t.prototype.depth.apply(this, arguments)
                        }, n.prototype.createParentBoundables = function(t, e) {
                            et.isTrue(!t.isEmpty());
                            var i = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())),
                                o = new Et(t);
                            $e.sort(o, n.xComparator);
                            var r = this.verticalSlices(o, Math.trunc(Math.ceil(Math.sqrt(i))));
                            return this.createParentBoundablesFromVerticalSlices(r, e)
                        }, n.prototype.nearestNeighbour = function() {
                            if (1 === arguments.length) {
                                if (N(arguments[0], rn)) {
                                    var t = arguments[0],
                                        e = new tn(this.getRoot(), this.getRoot(), t);
                                    return this.nearestNeighbour(e)
                                }
                                if (arguments[0] instanceof tn) {
                                    var i = arguments[0];
                                    return this.nearestNeighbour(i, v.POSITIVE_INFINITY)
                                }
                            } else if (2 === arguments.length) {
                                if (arguments[0] instanceof n && N(arguments[1], rn)) {
                                    var o = arguments[0],
                                        r = arguments[1],
                                        s = new tn(this.getRoot(), o.getRoot(), r);
                                    return this.nearestNeighbour(s)
                                }
                                if (arguments[0] instanceof tn && "number" == typeof arguments[1]) {
                                    var a = arguments[0],
                                        h = arguments[1],
                                        u = null,
                                        l = new We;
                                    for (l.add(a); !l.isEmpty() && h > 0;) {
                                        var c = l.poll(),
                                            p = c.getDistance();
                                        if (p >= h) break;
                                        c.isLeaves() ? (h = p, u = c) : c.expandToQueue(l, h)
                                    }
                                    return [u.getBoundable(0).getItem(), u.getBoundable(1).getItem()]
                                }
                            } else if (3 === arguments.length) {
                                var f = arguments[0],
                                    d = arguments[1],
                                    _ = arguments[2],
                                    g = new Ye(f, d),
                                    m = new tn(this.getRoot(), g, _);
                                return this.nearestNeighbour(m)[0]
                            }
                        }, n.prototype.interfaces_ = function() {
                            return [Je, e]
                        }, n.prototype.getClass = function() {
                            return n
                        }, n.centreX = function(t) {
                            return n.avg(t.getMinX(), t.getMaxX())
                        }, n.avg = function(t, e) {
                            return (t + e) / 2
                        }, n.centreY = function(t) {
                            return n.avg(t.getMinY(), t.getMaxY())
                        }, i.STRtreeNode.get = function() {
                            return an
                        }, i.serialVersionUID.get = function() {
                            return 0x39920f7d5f261e0
                        }, i.xComparator.get = function() {
                            return {
                                interfaces_: function() {
                                    return [E]
                                },
                                compare: function(e, i) {
                                    return t.compareDoubles(n.centreX(e.getBounds()), n.centreX(i.getBounds()))
                                }
                            }
                        }, i.yComparator.get = function() {
                            return {
                                interfaces_: function() {
                                    return [E]
                                },
                                compare: function(e, i) {
                                    return t.compareDoubles(n.centreY(e.getBounds()), n.centreY(i.getBounds()))
                                }
                            }
                        }, i.intersectsOp.get = function() {
                            return {
                                interfaces_: function() {
                                    return [t.IntersectsOp]
                                },
                                intersects: function(t, e) {
                                    return t.intersects(e)
                                }
                            }
                        }, i.DEFAULT_NODE_CAPACITY.get = function() {
                            return 10
                        }, Object.defineProperties(n, i), n
                    }(en),
                    an = function(t) {
                        function e() {
                            var e = arguments[0];
                            t.call(this, e)
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.computeBounds = function() {
                            for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext();) {
                                var n = e.next();
                                null === t ? t = new H(n.getBounds()) : t.expandToInclude(n.getBounds())
                            }
                            return t
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e
                    }(Ke),
                    hn = function() {};
                hn.prototype.interfaces_ = function() {
                    return []
                }, hn.prototype.getClass = function() {
                    return hn
                }, hn.relativeSign = function(t, e) {
                    return t < e ? -1 : t > e ? 1 : 0
                }, hn.compare = function(t, e, n) {
                    if (e.equals2D(n)) return 0;
                    var i = hn.relativeSign(e.x, n.x),
                        o = hn.relativeSign(e.y, n.y);
                    switch (t) {
                        case 0:
                            return hn.compareValue(i, o);
                        case 1:
                            return hn.compareValue(o, i);
                        case 2:
                            return hn.compareValue(o, -i);
                        case 3:
                            return hn.compareValue(-i, o);
                        case 4:
                            return hn.compareValue(-i, -o);
                        case 5:
                            return hn.compareValue(-o, -i);
                        case 6:
                            return hn.compareValue(-o, i);
                        case 7:
                            return hn.compareValue(i, -o)
                    }
                    return et.shouldNeverReachHere("invalid octant value"), 0
                }, hn.compareValue = function(t, e) {
                    return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0
                };
                var un = function() {
                    this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
                    var t = arguments[0],
                        e = arguments[1],
                        n = arguments[2],
                        i = arguments[3];
                    this._segString = t, this.coord = new C(e), this.segmentIndex = n, this._segmentOctant = i, this._isInterior = !e.equals2D(t.getCoordinate(n))
                };
                un.prototype.getCoordinate = function() {
                    return this.coord
                }, un.prototype.print = function(t) {
                    t.print(this.coord), t.print(" seg # = " + this.segmentIndex)
                }, un.prototype.compareTo = function(t) {
                    var e = t;
                    return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : hn.compare(this._segmentOctant, this.coord, e.coord)
                }, un.prototype.isEndPoint = function(t) {
                    return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t
                }, un.prototype.isInterior = function() {
                    return this._isInterior
                }, un.prototype.interfaces_ = function() {
                    return [x]
                }, un.prototype.getClass = function() {
                    return un
                };
                var ln = function() {
                    this._nodeMap = new c, this._edge = null;
                    var t = arguments[0];
                    this._edge = t
                };
                ln.prototype.getSplitCoordinates = function() {
                    var t = new It;
                    this.addEndpoints();
                    for (var e = this.iterator(), n = e.next(); e.hasNext();) {
                        var i = e.next();
                        this.addEdgeCoordinates(n, i, t), n = i
                    }
                    return t.toCoordinateArray()
                }, ln.prototype.addCollapsedNodes = function() {
                    var t = new Et;
                    this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);
                    for (var e = t.iterator(); e.hasNext();) {
                        var n = e.next().intValue();
                        this.add(this._edge.getCoordinate(n), n)
                    }
                }, ln.prototype.print = function(t) {
                    t.println("Intersections:");
                    for (var e = this.iterator(); e.hasNext();) e.next().print(t)
                }, ln.prototype.findCollapsesFromExistingVertices = function(t) {
                    for (var e = 0; e < this._edge.size() - 2; e++) {
                        var n = this._edge.getCoordinate(e),
                            i = this._edge.getCoordinate(e + 2);
                        n.equals2D(i) && t.add(new R(e + 1))
                    }
                }, ln.prototype.addEdgeCoordinates = function(t, e, n) {
                    var i = this._edge.getCoordinate(e.segmentIndex),
                        o = e.isInterior() || !e.coord.equals2D(i);
                    n.add(new C(t.coord), !1);
                    for (var r = t.segmentIndex + 1; r <= e.segmentIndex; r++) n.add(this._edge.getCoordinate(r));
                    o && n.add(new C(e.coord))
                }, ln.prototype.iterator = function() {
                    return this._nodeMap.values().iterator()
                }, ln.prototype.addSplitEdges = function(t) {
                    this.addEndpoints(), this.addCollapsedNodes();
                    for (var e = this.iterator(), n = e.next(); e.hasNext();) {
                        var i = e.next(),
                            o = this.createSplitEdge(n, i);
                        t.add(o), n = i
                    }
                }, ln.prototype.findCollapseIndex = function(t, e, n) {
                    if (!t.coord.equals2D(e.coord)) return !1;
                    var i = e.segmentIndex - t.segmentIndex;
                    return e.isInterior() || i--, 1 === i && (n[0] = t.segmentIndex + 1, !0)
                }, ln.prototype.findCollapsesFromInsertedNodes = function(t) {
                    for (var e = new Array(1).fill(null), n = this.iterator(), i = n.next(); n.hasNext();) {
                        var o = n.next();
                        this.findCollapseIndex(i, o, e) && t.add(new R(e[0])), i = o
                    }
                }, ln.prototype.getEdge = function() {
                    return this._edge
                }, ln.prototype.addEndpoints = function() {
                    var t = this._edge.size() - 1;
                    this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t), t)
                }, ln.prototype.createSplitEdge = function(t, e) {
                    var n = e.segmentIndex - t.segmentIndex + 2,
                        i = this._edge.getCoordinate(e.segmentIndex),
                        o = e.isInterior() || !e.coord.equals2D(i);
                    o || n--;
                    var r = new Array(n).fill(null),
                        s = 0;
                    r[s++] = new C(t.coord);
                    for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) r[s++] = this._edge.getCoordinate(a);
                    return o && (r[s] = new C(e.coord)), new dn(r, this._edge.getData())
                }, ln.prototype.add = function(t, e) {
                    var n = new un(this._edge, t, e, this._edge.getSegmentOctant(e)),
                        i = this._nodeMap.get(n);
                    return null !== i ? (et.isTrue(i.coord.equals2D(t), "Found equal nodes with different coordinates"), i) : (this._nodeMap.put(n, n), n)
                }, ln.prototype.checkSplitEdgesCorrectness = function(t) {
                    var e = this._edge.getCoordinates(),
                        n = t.get(0).getCoordinate(0);
                    if (!n.equals2D(e[0])) throw new $("bad split edge start point at " + n);
                    var i = t.get(t.size() - 1).getCoordinates(),
                        o = i[i.length - 1];
                    if (!o.equals2D(e[e.length - 1])) throw new $("bad split edge end point at " + o)
                }, ln.prototype.interfaces_ = function() {
                    return []
                }, ln.prototype.getClass = function() {
                    return ln
                };
                var cn = function() {};
                cn.prototype.interfaces_ = function() {
                    return []
                }, cn.prototype.getClass = function() {
                    return cn
                }, cn.octant = function() {
                    if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                        var t = arguments[0],
                            e = arguments[1];
                        if (0 === t && 0 === e) throw new y("Cannot compute the octant for point ( " + t + ", " + e + " )");
                        var n = Math.abs(t),
                            i = Math.abs(e);
                        return t >= 0 ? e >= 0 ? n >= i ? 0 : 1 : n >= i ? 7 : 6 : e >= 0 ? n >= i ? 3 : 2 : n >= i ? 4 : 5
                    }
                    if (arguments[0] instanceof C && arguments[1] instanceof C) {
                        var o = arguments[0],
                            r = arguments[1],
                            s = r.x - o.x,
                            a = r.y - o.y;
                        if (0 === s && 0 === a) throw new y("Cannot compute the octant for two identical points " + o);
                        return cn.octant(s, a)
                    }
                };
                var pn = function() {};
                pn.prototype.getCoordinates = function() {}, pn.prototype.size = function() {}, pn.prototype.getCoordinate = function(t) {}, pn.prototype.isClosed = function() {}, pn.prototype.setData = function(t) {}, pn.prototype.getData = function() {}, pn.prototype.interfaces_ = function() {
                    return []
                }, pn.prototype.getClass = function() {
                    return pn
                };
                var fn = function() {};
                fn.prototype.addIntersection = function(t, e) {}, fn.prototype.interfaces_ = function() {
                    return [pn]
                }, fn.prototype.getClass = function() {
                    return fn
                };
                var dn = function() {
                    this._nodeList = new ln(this), this._pts = null, this._data = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this._pts = t, this._data = e
                };
                dn.prototype.getCoordinates = function() {
                    return this._pts
                }, dn.prototype.size = function() {
                    return this._pts.length
                }, dn.prototype.getCoordinate = function(t) {
                    return this._pts[t]
                }, dn.prototype.isClosed = function() {
                    return this._pts[0].equals(this._pts[this._pts.length - 1])
                }, dn.prototype.getSegmentOctant = function(t) {
                    return t === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1))
                }, dn.prototype.setData = function(t) {
                    this._data = t
                }, dn.prototype.safeOctant = function(t, e) {
                    return t.equals2D(e) ? 0 : cn.octant(t, e)
                }, dn.prototype.getData = function() {
                    return this._data
                }, dn.prototype.addIntersection = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        this.addIntersectionNode(t, e)
                    } else if (4 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1],
                            o = arguments[3],
                            r = new C(n.getIntersection(o));
                        this.addIntersection(r, i)
                    }
                }, dn.prototype.toString = function() {
                    return Q.toLineString(new he(this._pts))
                }, dn.prototype.getNodeList = function() {
                    return this._nodeList
                }, dn.prototype.addIntersectionNode = function(t, e) {
                    var n = e,
                        i = n + 1;
                    if (i < this._pts.length) {
                        var o = this._pts[i];
                        t.equals2D(o) && (n = i)
                    }
                    return this._nodeList.add(t, n)
                }, dn.prototype.addIntersections = function(t, e, n) {
                    for (var i = 0; i < t.getIntersectionNum(); i++) this.addIntersection(t, e, n, i)
                }, dn.prototype.interfaces_ = function() {
                    return [fn]
                }, dn.prototype.getClass = function() {
                    return dn
                }, dn.getNodedSubstrings = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0],
                            e = new Et;
                        return dn.getNodedSubstrings(t, e), e
                    }
                    if (2 === arguments.length)
                        for (var n = arguments[0], i = arguments[1], o = n.iterator(); o.hasNext();) o.next().getNodeList().addSplitEdges(i)
                };
                var _n = function() {
                        if (this.p0 = null, this.p1 = null, 0 === arguments.length) this.p0 = new C, this.p1 = new C;
                        else if (1 === arguments.length) {
                            var t = arguments[0];
                            this.p0 = new C(t.p0), this.p1 = new C(t.p1)
                        } else if (2 === arguments.length) this.p0 = arguments[0], this.p1 = arguments[1];
                        else if (4 === arguments.length) {
                            var e = arguments[0],
                                n = arguments[1],
                                i = arguments[2],
                                o = arguments[3];
                            this.p0 = new C(e, n), this.p1 = new C(i, o)
                        }
                    },
                    gn = {
                        serialVersionUID: {
                            configurable: !0
                        }
                    };
                _n.prototype.minX = function() {
                        return Math.min(this.p0.x, this.p1.x)
                    }, _n.prototype.orientationIndex = function() {
                        if (arguments[0] instanceof _n) {
                            var t = arguments[0],
                                e = at.orientationIndex(this.p0, this.p1, t.p0),
                                n = at.orientationIndex(this.p0, this.p1, t.p1);
                            return e >= 0 && n >= 0 ? Math.max(e, n) : e <= 0 && n <= 0 ? Math.max(e, n) : 0
                        }
                        if (arguments[0] instanceof C) {
                            var i = arguments[0];
                            return at.orientationIndex(this.p0, this.p1, i)
                        }
                    }, _n.prototype.toGeometry = function(t) {
                        return t.createLineString([this.p0, this.p1])
                    }, _n.prototype.isVertical = function() {
                        return this.p0.x === this.p1.x
                    }, _n.prototype.equals = function(t) {
                        if (!(t instanceof _n)) return !1;
                        var e = t;
                        return this.p0.equals(e.p0) && this.p1.equals(e.p1)
                    }, _n.prototype.intersection = function(t) {
                        var e = new ot;
                        return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null
                    }, _n.prototype.project = function() {
                        if (arguments[0] instanceof C) {
                            var t = arguments[0];
                            if (t.equals(this.p0) || t.equals(this.p1)) return new C(t);
                            var e = this.projectionFactor(t),
                                n = new C;
                            return n.x = this.p0.x + e * (this.p1.x - this.p0.x), n.y = this.p0.y + e * (this.p1.y - this.p0.y), n
                        }
                        if (arguments[0] instanceof _n) {
                            var i = arguments[0],
                                o = this.projectionFactor(i.p0),
                                r = this.projectionFactor(i.p1);
                            if (o >= 1 && r >= 1) return null;
                            if (o <= 0 && r <= 0) return null;
                            var s = this.project(i.p0);
                            o < 0 && (s = this.p0), o > 1 && (s = this.p1);
                            var a = this.project(i.p1);
                            return r < 0 && (a = this.p0), r > 1 && (a = this.p1), new _n(s, a)
                        }
                    }, _n.prototype.normalize = function() {
                        this.p1.compareTo(this.p0) < 0 && this.reverse()
                    }, _n.prototype.angle = function() {
                        return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)
                    }, _n.prototype.getCoordinate = function(t) {
                        return 0 === t ? this.p0 : this.p1
                    }, _n.prototype.distancePerpendicular = function(t) {
                        return at.distancePointLinePerpendicular(t, this.p0, this.p1)
                    }, _n.prototype.minY = function() {
                        return Math.min(this.p0.y, this.p1.y)
                    }, _n.prototype.midPoint = function() {
                        return _n.midPoint(this.p0, this.p1)
                    }, _n.prototype.projectionFactor = function(t) {
                        if (t.equals(this.p0)) return 0;
                        if (t.equals(this.p1)) return 1;
                        var e = this.p1.x - this.p0.x,
                            n = this.p1.y - this.p0.y,
                            i = e * e + n * n;
                        return i <= 0 ? v.NaN : ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / i
                    }, _n.prototype.closestPoints = function(t) {
                        var e = this.intersection(t);
                        if (null !== e) return [e, e];
                        var n = new Array(2).fill(null),
                            i = v.MAX_VALUE,
                            o = null,
                            r = this.closestPoint(t.p0);
                        i = r.distance(t.p0), n[0] = r, n[1] = t.p0;
                        var s = this.closestPoint(t.p1);
                        (o = s.distance(t.p1)) < i && (i = o, n[0] = s, n[1] = t.p1);
                        var a = t.closestPoint(this.p0);
                        (o = a.distance(this.p0)) < i && (i = o, n[0] = this.p0, n[1] = a);
                        var h = t.closestPoint(this.p1);
                        return (o = h.distance(this.p1)) < i && (i = o, n[0] = this.p1, n[1] = h), n
                    }, _n.prototype.closestPoint = function(t) {
                        var e = this.projectionFactor(t);
                        return e > 0 && e < 1 ? this.project(t) : this.p0.distance(t) < this.p1.distance(t) ? this.p0 : this.p1
                    }, _n.prototype.maxX = function() {
                        return Math.max(this.p0.x, this.p1.x)
                    },
                    _n.prototype.getLength = function() {
                        return this.p0.distance(this.p1)
                    }, _n.prototype.compareTo = function(t) {
                        var e = t,
                            n = this.p0.compareTo(e.p0);
                        return 0 !== n ? n : this.p1.compareTo(e.p1)
                    }, _n.prototype.reverse = function() {
                        var t = this.p0;
                        this.p0 = this.p1, this.p1 = t
                    }, _n.prototype.equalsTopo = function(t) {
                        return this.p0.equals(t.p0) && (this.p1.equals(t.p1) || this.p0.equals(t.p1)) && this.p1.equals(t.p0)
                    }, _n.prototype.lineIntersection = function(t) {
                        try {
                            return V.intersection(this.p0, this.p1, t.p0, t.p1)
                        } catch (t) {
                            if (!(t instanceof q)) throw t
                        }
                        return null
                    }, _n.prototype.maxY = function() {
                        return Math.max(this.p0.y, this.p1.y)
                    }, _n.prototype.pointAlongOffset = function(t, e) {
                        var n = this.p0.x + t * (this.p1.x - this.p0.x),
                            i = this.p0.y + t * (this.p1.y - this.p0.y),
                            o = this.p1.x - this.p0.x,
                            r = this.p1.y - this.p0.y,
                            s = Math.sqrt(o * o + r * r),
                            a = 0,
                            h = 0;
                        if (0 !== e) {
                            if (s <= 0) throw new Error("Cannot compute offset from zero-length line segment");
                            a = e * o / s, h = e * r / s
                        }
                        return new C(n - h, i + a)
                    }, _n.prototype.setCoordinates = function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.setCoordinates(t.p0, t.p1)
                        } else if (2 === arguments.length) {
                            var e = arguments[0],
                                n = arguments[1];
                            this.p0.x = e.x, this.p0.y = e.y, this.p1.x = n.x, this.p1.y = n.y
                        }
                    }, _n.prototype.segmentFraction = function(t) {
                        var e = this.projectionFactor(t);
                        return e < 0 ? e = 0 : (e > 1 || v.isNaN(e)) && (e = 1), e
                    }, _n.prototype.toString = function() {
                        return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")"
                    }, _n.prototype.isHorizontal = function() {
                        return this.p0.y === this.p1.y
                    }, _n.prototype.distance = function() {
                        if (arguments[0] instanceof _n) {
                            var t = arguments[0];
                            return at.distanceLineLine(this.p0, this.p1, t.p0, t.p1)
                        }
                        if (arguments[0] instanceof C) {
                            var e = arguments[0];
                            return at.distancePointLine(e, this.p0, this.p1)
                        }
                    }, _n.prototype.pointAlong = function(t) {
                        var e = new C;
                        return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e
                    }, _n.prototype.hashCode = function() {
                        var t = v.doubleToLongBits(this.p0.x);
                        t ^= 31 * v.doubleToLongBits(this.p0.y);
                        var e = Math.trunc(t) ^ Math.trunc(t >> 32),
                            n = v.doubleToLongBits(this.p1.x);
                        return n ^= 31 * v.doubleToLongBits(this.p1.y), e ^ Math.trunc(n) ^ Math.trunc(n >> 32)
                    }, _n.prototype.interfaces_ = function() {
                        return [x, e]
                    }, _n.prototype.getClass = function() {
                        return _n
                    }, _n.midPoint = function(t, e) {
                        return new C((t.x + e.x) / 2, (t.y + e.y) / 2)
                    }, gn.serialVersionUID.get = function() {
                        return 0x2d2172135f411c00
                    }, Object.defineProperties(_n, gn);
                var mn = function() {
                    this.tempEnv1 = new H, this.tempEnv2 = new H, this._overlapSeg1 = new _n, this._overlapSeg2 = new _n
                };
                mn.prototype.overlap = function() {
                    if (2 === arguments.length);
                    else if (4 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1],
                            n = arguments[2],
                            i = arguments[3];
                        t.getLineSegment(e, this._overlapSeg1), n.getLineSegment(i, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2)
                    }
                }, mn.prototype.interfaces_ = function() {
                    return []
                }, mn.prototype.getClass = function() {
                    return mn
                };
                var yn = function() {
                    this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
                    var t = arguments[0],
                        e = arguments[1],
                        n = arguments[2],
                        i = arguments[3];
                    this._pts = t, this._start = e, this._end = n, this._context = i
                };
                yn.prototype.getLineSegment = function(t, e) {
                    e.p0 = this._pts[t], e.p1 = this._pts[t + 1]
                }, yn.prototype.computeSelect = function(t, e, n, i) {
                    var o = this._pts[e],
                        r = this._pts[n];
                    if (i.tempEnv1.init(o, r), n - e == 1) return i.select(this, e), null;
                    if (!t.intersects(i.tempEnv1)) return null;
                    var s = Math.trunc((e + n) / 2);
                    e < s && this.computeSelect(t, e, s, i), s < n && this.computeSelect(t, s, n, i)
                }, yn.prototype.getCoordinates = function() {
                    for (var t = new Array(this._end - this._start + 1).fill(null), e = 0, n = this._start; n <= this._end; n++) t[e++] = this._pts[n];
                    return t
                }, yn.prototype.computeOverlaps = function(t, e) {
                    this.computeOverlapsInternal(this._start, this._end, t, t._start, t._end, e)
                }, yn.prototype.setId = function(t) {
                    this._id = t
                }, yn.prototype.select = function(t, e) {
                    this.computeSelect(t, this._start, this._end, e)
                }, yn.prototype.getEnvelope = function() {
                    if (null === this._env) {
                        var t = this._pts[this._start],
                            e = this._pts[this._end];
                        this._env = new H(t, e)
                    }
                    return this._env
                }, yn.prototype.getEndIndex = function() {
                    return this._end
                }, yn.prototype.getStartIndex = function() {
                    return this._start
                }, yn.prototype.getContext = function() {
                    return this._context
                }, yn.prototype.getId = function() {
                    return this._id
                }, yn.prototype.computeOverlapsInternal = function(t, e, n, i, o, r) {
                    var s = this._pts[t],
                        a = this._pts[e],
                        h = n._pts[i],
                        u = n._pts[o];
                    if (e - t == 1 && o - i == 1) return r.overlap(this, t, n, i), null;
                    if (r.tempEnv1.init(s, a), r.tempEnv2.init(h, u), !r.tempEnv1.intersects(r.tempEnv2)) return null;
                    var l = Math.trunc((t + e) / 2),
                        c = Math.trunc((i + o) / 2);
                    t < l && (i < c && this.computeOverlapsInternal(t, l, n, i, c, r), c < o && this.computeOverlapsInternal(t, l, n, c, o, r)), l < e && (i < c && this.computeOverlapsInternal(l, e, n, i, c, r), c < o && this.computeOverlapsInternal(l, e, n, c, o, r))
                }, yn.prototype.interfaces_ = function() {
                    return []
                }, yn.prototype.getClass = function() {
                    return yn
                };
                var vn = function() {};
                vn.prototype.interfaces_ = function() {
                    return []
                }, vn.prototype.getClass = function() {
                    return vn
                }, vn.getChainStartIndices = function(t) {
                    var e = 0,
                        n = new Et;
                    n.add(new R(e));
                    do {
                        var i = vn.findChainEnd(t, e);
                        n.add(new R(i)), e = i
                    } while (e < t.length - 1);
                    return vn.toIntArray(n)
                }, vn.findChainEnd = function(t, e) {
                    for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]);) n++;
                    if (n >= t.length - 1) return t.length - 1;
                    for (var i = Be.quadrant(t[n], t[n + 1]), o = e + 1; o < t.length && (t[o - 1].equals2D(t[o]) || Be.quadrant(t[o - 1], t[o]) === i);) o++;
                    return o - 1
                }, vn.getChains = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return vn.getChains(t, null)
                    }
                    if (2 === arguments.length) {
                        for (var e = arguments[0], n = arguments[1], i = new Et, o = vn.getChainStartIndices(e), r = 0; r < o.length - 1; r++) {
                            var s = new yn(e, o[r], o[r + 1], n);
                            i.add(s)
                        }
                        return i
                    }
                }, vn.toIntArray = function(t) {
                    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) e[n] = t.get(n).intValue();
                    return e
                };
                var Ln = function() {};
                Ln.prototype.computeNodes = function(t) {}, Ln.prototype.getNodedSubstrings = function() {}, Ln.prototype.interfaces_ = function() {
                    return []
                }, Ln.prototype.getClass = function() {
                    return Ln
                };
                var xn = function() {
                    if (this._segInt = null, 0 === arguments.length);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.setSegmentIntersector(t)
                    }
                };
                xn.prototype.setSegmentIntersector = function(t) {
                    this._segInt = t
                }, xn.prototype.interfaces_ = function() {
                    return [Ln]
                }, xn.prototype.getClass = function() {
                    return xn
                };
                var bn = function(t) {
                        function e(e) {
                            e ? t.call(this, e) : t.call(this), this._monoChains = new Et, this._index = new sn, this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0
                        }
                        t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e;
                        var n = {
                            SegmentOverlapAction: {
                                configurable: !0
                            }
                        };
                        return e.prototype.getMonotoneChains = function() {
                            return this._monoChains
                        }, e.prototype.getNodedSubstrings = function() {
                            return dn.getNodedSubstrings(this._nodedSegStrings)
                        }, e.prototype.getIndex = function() {
                            return this._index
                        }, e.prototype.add = function(t) {
                            for (var e = vn.getChains(t.getCoordinates(), t).iterator(); e.hasNext();) {
                                var n = e.next();
                                n.setId(this._idCounter++), this._index.insert(n.getEnvelope(), n), this._monoChains.add(n)
                            }
                        }, e.prototype.computeNodes = function(t) {
                            this._nodedSegStrings = t;
                            for (var e = t.iterator(); e.hasNext();) this.add(e.next());
                            this.intersectChains()
                        }, e.prototype.intersectChains = function() {
                            for (var t = new En(this._segInt), e = this._monoChains.iterator(); e.hasNext();)
                                for (var n = e.next(), i = this._index.query(n.getEnvelope()).iterator(); i.hasNext();) {
                                    var o = i.next();
                                    if (o.getId() > n.getId() && (n.computeOverlaps(o, t), this._nOverlaps++), this._segInt.isDone()) return null
                                }
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, n.SegmentOverlapAction.get = function() {
                            return En
                        }, Object.defineProperties(e, n), e
                    }(xn),
                    En = function(t) {
                        function e() {
                            t.call(this), this._si = null;
                            var e = arguments[0];
                            this._si = e
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.overlap = function() {
                            if (4 !== arguments.length) return t.prototype.overlap.apply(this, arguments);
                            var e = arguments[0],
                                n = arguments[1],
                                i = arguments[2],
                                o = arguments[3],
                                r = e.getContext(),
                                s = i.getContext();
                            this._si.processIntersections(r, n, s, o)
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e
                    }(mn),
                    Cn = function t() {
                        if (this._quadrantSegments = t.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = t.CAP_ROUND, this._joinStyle = t.JOIN_ROUND, this._mitreLimit = t.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = t.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length);
                        else if (1 === arguments.length) {
                            var e = arguments[0];
                            this.setQuadrantSegments(e)
                        } else if (2 === arguments.length) {
                            var n = arguments[0],
                                i = arguments[1];
                            this.setQuadrantSegments(n), this.setEndCapStyle(i)
                        } else if (4 === arguments.length) {
                            var o = arguments[0],
                                r = arguments[1],
                                s = arguments[2],
                                a = arguments[3];
                            this.setQuadrantSegments(o), this.setEndCapStyle(r), this.setJoinStyle(s), this.setMitreLimit(a)
                        }
                    },
                    In = {
                        CAP_ROUND: {
                            configurable: !0
                        },
                        CAP_FLAT: {
                            configurable: !0
                        },
                        CAP_SQUARE: {
                            configurable: !0
                        },
                        JOIN_ROUND: {
                            configurable: !0
                        },
                        JOIN_MITRE: {
                            configurable: !0
                        },
                        JOIN_BEVEL: {
                            configurable: !0
                        },
                        DEFAULT_QUADRANT_SEGMENTS: {
                            configurable: !0
                        },
                        DEFAULT_MITRE_LIMIT: {
                            configurable: !0
                        },
                        DEFAULT_SIMPLIFY_FACTOR: {
                            configurable: !0
                        }
                    };
                Cn.prototype.getEndCapStyle = function() {
                    return this._endCapStyle
                }, Cn.prototype.isSingleSided = function() {
                    return this._isSingleSided
                }, Cn.prototype.setQuadrantSegments = function(t) {
                    this._quadrantSegments = t, 0 === this._quadrantSegments && (this._joinStyle = Cn.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = Cn.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t <= 0 && (this._quadrantSegments = 1), this._joinStyle !== Cn.JOIN_ROUND && (this._quadrantSegments = Cn.DEFAULT_QUADRANT_SEGMENTS)
                }, Cn.prototype.getJoinStyle = function() {
                    return this._joinStyle
                }, Cn.prototype.setJoinStyle = function(t) {
                    this._joinStyle = t
                }, Cn.prototype.setSimplifyFactor = function(t) {
                    this._simplifyFactor = t < 0 ? 0 : t
                }, Cn.prototype.getSimplifyFactor = function() {
                    return this._simplifyFactor
                }, Cn.prototype.getQuadrantSegments = function() {
                    return this._quadrantSegments
                }, Cn.prototype.setEndCapStyle = function(t) {
                    this._endCapStyle = t
                }, Cn.prototype.getMitreLimit = function() {
                    return this._mitreLimit
                }, Cn.prototype.setMitreLimit = function(t) {
                    this._mitreLimit = t
                }, Cn.prototype.setSingleSided = function(t) {
                    this._isSingleSided = t
                }, Cn.prototype.interfaces_ = function() {
                    return []
                }, Cn.prototype.getClass = function() {
                    return Cn
                }, Cn.bufferDistanceError = function(t) {
                    var e = Math.PI / 2 / t;
                    return 1 - Math.cos(e / 2)
                }, In.CAP_ROUND.get = function() {
                    return 1
                }, In.CAP_FLAT.get = function() {
                    return 2
                }, In.CAP_SQUARE.get = function() {
                    return 3
                }, In.JOIN_ROUND.get = function() {
                    return 1
                }, In.JOIN_MITRE.get = function() {
                    return 2
                }, In.JOIN_BEVEL.get = function() {
                    return 3
                }, In.DEFAULT_QUADRANT_SEGMENTS.get = function() {
                    return 8
                }, In.DEFAULT_MITRE_LIMIT.get = function() {
                    return 5
                }, In.DEFAULT_SIMPLIFY_FACTOR.get = function() {
                    return .01
                }, Object.defineProperties(Cn, In);
                var wn = function(t) {
                        this._distanceTol = null, this._isDeleted = null, this._angleOrientation = at.COUNTERCLOCKWISE, this._inputLine = t || null
                    },
                    Mn = {
                        INIT: {
                            configurable: !0
                        },
                        DELETE: {
                            configurable: !0
                        },
                        KEEP: {
                            configurable: !0
                        },
                        NUM_PTS_TO_CHECK: {
                            configurable: !0
                        }
                    };
                wn.prototype.isDeletable = function(t, e, n, i) {
                    var o = this._inputLine[t],
                        r = this._inputLine[e],
                        s = this._inputLine[n];
                    return !!this.isConcave(o, r, s) && !!this.isShallow(o, r, s, i) && this.isShallowSampled(o, r, t, n, i)
                }, wn.prototype.deleteShallowConcavities = function() {
                    for (var t = 1, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e), i = !1; n < this._inputLine.length;) {
                        var o = !1;
                        this.isDeletable(t, e, n, this._distanceTol) && (this._isDeleted[e] = wn.DELETE, o = !0, i = !0), t = o ? n : e, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e)
                    }
                    return i
                }, wn.prototype.isShallowConcavity = function(t, e, n, i) {
                    return at.computeOrientation(t, e, n) === this._angleOrientation && at.distancePointLine(e, t, n) < i
                }, wn.prototype.isShallowSampled = function(t, e, n, i, o) {
                    var r = Math.trunc((i - n) / wn.NUM_PTS_TO_CHECK);
                    r <= 0 && (r = 1);
                    for (var s = n; s < i; s += r)
                        if (!this.isShallow(t, e, this._inputLine[s], o)) return !1;
                    return !0
                }, wn.prototype.isConcave = function(t, e, n) {
                    return at.computeOrientation(t, e, n) === this._angleOrientation
                }, wn.prototype.simplify = function(t) {
                    this._distanceTol = Math.abs(t), t < 0 && (this._angleOrientation = at.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
                    var e = !1;
                    do {
                        e = this.deleteShallowConcavities()
                    } while (e);
                    return this.collapseLine()
                }, wn.prototype.findNextNonDeletedIndex = function(t) {
                    for (var e = t + 1; e < this._inputLine.length && this._isDeleted[e] === wn.DELETE;) e++;
                    return e
                }, wn.prototype.isShallow = function(t, e, n, i) {
                    return at.distancePointLine(e, t, n) < i
                }, wn.prototype.collapseLine = function() {
                    for (var t = new It, e = 0; e < this._inputLine.length; e++) this._isDeleted[e] !== wn.DELETE && t.add(this._inputLine[e]);
                    return t.toCoordinateArray()
                }, wn.prototype.interfaces_ = function() {
                    return []
                }, wn.prototype.getClass = function() {
                    return wn
                }, wn.simplify = function(t, e) {
                    return new wn(t).simplify(e)
                }, Mn.INIT.get = function() {
                    return 0
                }, Mn.DELETE.get = function() {
                    return 1
                }, Mn.KEEP.get = function() {
                    return 1
                }, Mn.NUM_PTS_TO_CHECK.get = function() {
                    return 10
                }, Object.defineProperties(wn, Mn);
                var Sn = function() {
                        this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new Et
                    },
                    Pn = {
                        COORDINATE_ARRAY_TYPE: {
                            configurable: !0
                        }
                    };
                Sn.prototype.getCoordinates = function() {
                    return this._ptList.toArray(Sn.COORDINATE_ARRAY_TYPE)
                }, Sn.prototype.setPrecisionModel = function(t) {
                    this._precisionModel = t
                }, Sn.prototype.addPt = function(t) {
                    var e = new C(t);
                    if (this._precisionModel.makePrecise(e), this.isRedundant(e)) return null;
                    this._ptList.add(e)
                }, Sn.prototype.revere = function() {}, Sn.prototype.addPts = function(t, e) {
                    if (e)
                        for (var n = 0; n < t.length; n++) this.addPt(t[n]);
                    else
                        for (var i = t.length - 1; i >= 0; i--) this.addPt(t[i])
                }, Sn.prototype.isRedundant = function(t) {
                    if (this._ptList.size() < 1) return !1;
                    var e = this._ptList.get(this._ptList.size() - 1);
                    return t.distance(e) < this._minimimVertexDistance
                }, Sn.prototype.toString = function() {
                    return (new me).createLineString(this.getCoordinates()).toString()
                }, Sn.prototype.closeRing = function() {
                    if (this._ptList.size() < 1) return null;
                    var t = new C(this._ptList.get(0)),
                        e = this._ptList.get(this._ptList.size() - 1);
                    if (t.equals(e)) return null;
                    this._ptList.add(t)
                }, Sn.prototype.setMinimumVertexDistance = function(t) {
                    this._minimimVertexDistance = t
                }, Sn.prototype.interfaces_ = function() {
                    return []
                }, Sn.prototype.getClass = function() {
                    return Sn
                }, Pn.COORDINATE_ARRAY_TYPE.get = function() {
                    return new Array(0).fill(null)
                }, Object.defineProperties(Sn, Pn);
                var Nn = function() {},
                    Tn = {
                        PI_TIMES_2: {
                            configurable: !0
                        },
                        PI_OVER_2: {
                            configurable: !0
                        },
                        PI_OVER_4: {
                            configurable: !0
                        },
                        COUNTERCLOCKWISE: {
                            configurable: !0
                        },
                        CLOCKWISE: {
                            configurable: !0
                        },
                        NONE: {
                            configurable: !0
                        }
                    };
                Nn.prototype.interfaces_ = function() {
                    return []
                }, Nn.prototype.getClass = function() {
                    return Nn
                }, Nn.toDegrees = function(t) {
                    return 180 * t / Math.PI
                }, Nn.normalize = function(t) {
                    for (; t > Math.PI;) t -= Nn.PI_TIMES_2;
                    for (; t <= -Math.PI;) t += Nn.PI_TIMES_2;
                    return t
                }, Nn.angle = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return Math.atan2(t.y, t.x)
                    }
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1],
                            i = n.x - e.x,
                            o = n.y - e.y;
                        return Math.atan2(o, i)
                    }
                }, Nn.isAcute = function(t, e, n) {
                    var i = t.x - e.x,
                        o = t.y - e.y;
                    return i * (n.x - e.x) + o * (n.y - e.y) > 0
                }, Nn.isObtuse = function(t, e, n) {
                    var i = t.x - e.x,
                        o = t.y - e.y;
                    return i * (n.x - e.x) + o * (n.y - e.y) < 0
                }, Nn.interiorAngle = function(t, e, n) {
                    var i = Nn.angle(e, t),
                        o = Nn.angle(e, n);
                    return Math.abs(o - i)
                }, Nn.normalizePositive = function(t) {
                    if (t < 0) {
                        for (; t < 0;) t += Nn.PI_TIMES_2;
                        t >= Nn.PI_TIMES_2 && (t = 0)
                    } else {
                        for (; t >= Nn.PI_TIMES_2;) t -= Nn.PI_TIMES_2;
                        t < 0 && (t = 0)
                    }
                    return t
                }, Nn.angleBetween = function(t, e, n) {
                    var i = Nn.angle(e, t),
                        o = Nn.angle(e, n);
                    return Nn.diff(i, o)
                }, Nn.diff = function(t, e) {
                    var n = null;
                    return (n = t < e ? e - t : t - e) > Math.PI && (n = 2 * Math.PI - n), n
                }, Nn.toRadians = function(t) {
                    return t * Math.PI / 180
                }, Nn.getTurn = function(t, e) {
                    var n = Math.sin(e - t);
                    return n > 0 ? Nn.COUNTERCLOCKWISE : n < 0 ? Nn.CLOCKWISE : Nn.NONE
                }, Nn.angleBetweenOriented = function(t, e, n) {
                    var i = Nn.angle(e, t),
                        o = Nn.angle(e, n) - i;
                    return o <= -Math.PI ? o + Nn.PI_TIMES_2 : o > Math.PI ? o - Nn.PI_TIMES_2 : o
                }, Tn.PI_TIMES_2.get = function() {
                    return 2 * Math.PI
                }, Tn.PI_OVER_2.get = function() {
                    return Math.PI / 2
                }, Tn.PI_OVER_4.get = function() {
                    return Math.PI / 4
                }, Tn.COUNTERCLOCKWISE.get = function() {
                    return at.COUNTERCLOCKWISE
                }, Tn.CLOCKWISE.get = function() {
                    return at.CLOCKWISE
                }, Tn.NONE.get = function() {
                    return at.COLLINEAR
                }, Object.defineProperties(Nn, Tn);
                var On = function t() {
                        this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new _n, this._seg1 = new _n, this._offset0 = new _n, this._offset1 = new _n, this._side = 0, this._hasNarrowConcaveAngle = !1;
                        var e = arguments[0],
                            n = arguments[1],
                            i = arguments[2];
                        this._precisionModel = e, this._bufParams = n, this._li = new ot, this._filletAngleQuantum = Math.PI / 2 / n.getQuadrantSegments(), n.getQuadrantSegments() >= 8 && n.getJoinStyle() === Cn.JOIN_ROUND && (this._closingSegLengthFactor = t.MAX_CLOSING_SEG_LEN_FACTOR), this.init(i)
                    },
                    An = {
                        OFFSET_SEGMENT_SEPARATION_FACTOR: {
                            configurable: !0
                        },
                        INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: {
                            configurable: !0
                        },
                        CURVE_VERTEX_SNAP_DISTANCE_FACTOR: {
                            configurable: !0
                        },
                        MAX_CLOSING_SEG_LEN_FACTOR: {
                            configurable: !0
                        }
                    };
                On.prototype.addNextSegment = function(t, e) {
                    if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;
                    var n = at.computeOrientation(this._s0, this._s1, this._s2),
                        i = n === at.CLOCKWISE && this._side === Ie.LEFT || n === at.COUNTERCLOCKWISE && this._side === Ie.RIGHT;
                    0 === n ? this.addCollinear(e) : i ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e)
                }, On.prototype.addLineEndCap = function(t, e) {
                    var n = new _n(t, e),
                        i = new _n;
                    this.computeOffsetSegment(n, Ie.LEFT, this._distance, i);
                    var o = new _n;
                    this.computeOffsetSegment(n, Ie.RIGHT, this._distance, o);
                    var r = e.x - t.x,
                        s = e.y - t.y,
                        a = Math.atan2(s, r);
                    switch (this._bufParams.getEndCapStyle()) {
                        case Cn.CAP_ROUND:
                            this._segList.addPt(i.p1), this.addFilletArc(e, a + Math.PI / 2, a - Math.PI / 2, at.CLOCKWISE, this._distance), this._segList.addPt(o.p1);
                            break;
                        case Cn.CAP_FLAT:
                            this._segList.addPt(i.p1), this._segList.addPt(o.p1);
                            break;
                        case Cn.CAP_SQUARE:
                            var h = new C;
                            h.x = Math.abs(this._distance) * Math.cos(a), h.y = Math.abs(this._distance) * Math.sin(a);
                            var u = new C(i.p1.x + h.x, i.p1.y + h.y),
                                l = new C(o.p1.x + h.x, o.p1.y + h.y);
                            this._segList.addPt(u), this._segList.addPt(l)
                    }
                }, On.prototype.getCoordinates = function() {
                    return this._segList.getCoordinates()
                }, On.prototype.addMitreJoin = function(t, e, n, i) {
                    var o = !0,
                        r = null;
                    try {
                        r = V.intersection(e.p0, e.p1, n.p0, n.p1), (i <= 0 ? 1 : r.distance(t) / Math.abs(i)) > this._bufParams.getMitreLimit() && (o = !1)
                    } catch (t) {
                        if (!(t instanceof q)) throw t;
                        r = new C(0, 0), o = !1
                    }
                    o ? this._segList.addPt(r) : this.addLimitedMitreJoin(e, n, i, this._bufParams.getMitreLimit())
                }, On.prototype.addFilletCorner = function(t, e, n, i, o) {
                    var r = e.x - t.x,
                        s = e.y - t.y,
                        a = Math.atan2(s, r),
                        h = n.x - t.x,
                        u = n.y - t.y,
                        l = Math.atan2(u, h);
                    i === at.CLOCKWISE ? a <= l && (a += 2 * Math.PI) : a >= l && (a -= 2 * Math.PI), this._segList.addPt(e), this.addFilletArc(t, a, l, i, o), this._segList.addPt(n)
                }, On.prototype.addOutsideTurn = function(t, e) {
                    if (this._offset0.p1.distance(this._offset1.p0) < this._distance * On.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;
                    this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e && this._segList.addPt(this._offset0.p1), this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, t, this._distance), this._segList.addPt(this._offset1.p0))
                }, On.prototype.createSquare = function(t) {
                    this._segList.addPt(new C(t.x + this._distance, t.y + this._distance)), this._segList.addPt(new C(t.x + this._distance, t.y - this._distance)), this._segList.addPt(new C(t.x - this._distance, t.y - this._distance)), this._segList.addPt(new C(t.x - this._distance, t.y + this._distance)), this._segList.closeRing()
                }, On.prototype.addSegments = function(t, e) {
                    this._segList.addPts(t, e)
                }, On.prototype.addFirstSegment = function() {
                    this._segList.addPt(this._offset1.p0)
                }, On.prototype.addLastSegment = function() {
                    this._segList.addPt(this._offset1.p1)
                }, On.prototype.initSideSegments = function(t, e, n) {
                    this._s1 = t, this._s2 = e, this._side = n, this._seg1.setCoordinates(t, e), this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1)
                }, On.prototype.addLimitedMitreJoin = function(t, e, n, i) {
                    var o = this._seg0.p1,
                        r = Nn.angle(o, this._seg0.p0),
                        s = Nn.angleBetweenOriented(this._seg0.p0, o, this._seg1.p1) / 2,
                        a = Nn.normalize(r + s),
                        h = Nn.normalize(a + Math.PI),
                        u = i * n,
                        l = n - u * Math.abs(Math.sin(s)),
                        c = o.x + u * Math.cos(h),
                        p = o.y + u * Math.sin(h),
                        f = new C(c, p),
                        d = new _n(o, f),
                        _ = d.pointAlongOffset(1, l),
                        g = d.pointAlongOffset(1, -l);
                    this._side === Ie.LEFT ? (this._segList.addPt(_), this._segList.addPt(g)) : (this._segList.addPt(g), this._segList.addPt(_))
                }, On.prototype.computeOffsetSegment = function(t, e, n, i) {
                    var o = e === Ie.LEFT ? 1 : -1,
                        r = t.p1.x - t.p0.x,
                        s = t.p1.y - t.p0.y,
                        a = Math.sqrt(r * r + s * s),
                        h = o * n * r / a,
                        u = o * n * s / a;
                    i.p0.x = t.p0.x - u, i.p0.y = t.p0.y + h, i.p1.x = t.p1.x - u, i.p1.y = t.p1.y + h
                }, On.prototype.addFilletArc = function(t, e, n, i, o) {
                    var r = i === at.CLOCKWISE ? -1 : 1,
                        s = Math.abs(e - n),
                        a = Math.trunc(s / this._filletAngleQuantum + .5);
                    if (a < 1) return null;
                    for (var h = s / a, u = 0, l = new C; u < s;) {
                        var c = e + r * u;
                        l.x = t.x + o * Math.cos(c), l.y = t.y + o * Math.sin(c), this._segList.addPt(l), u += h
                    }
                }, On.prototype.addInsideTurn = function(t, e) {
                    if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));
                    else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * On.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);
                    else {
                        if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
                            var n = new C((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
                            this._segList.addPt(n);
                            var i = new C((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
                            this._segList.addPt(i)
                        } else this._segList.addPt(this._s1);
                        this._segList.addPt(this._offset1.p0)
                    }
                }, On.prototype.createCircle = function(t) {
                    var e = new C(t.x + this._distance, t.y);
                    this._segList.addPt(e), this.addFilletArc(t, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing()
                }, On.prototype.addBevelJoin = function(t, e) {
                    this._segList.addPt(t.p1), this._segList.addPt(e.p0)
                }, On.prototype.init = function(t) {
                    this._distance = t, this._maxCurveSegmentError = t * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new Sn, this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t * On.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)
                }, On.prototype.addCollinear = function(t) {
                    this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL || this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, at.CLOCKWISE, this._distance))
                }, On.prototype.closeRing = function() {
                    this._segList.closeRing()
                }, On.prototype.hasNarrowConcaveAngle = function() {
                    return this._hasNarrowConcaveAngle
                }, On.prototype.interfaces_ = function() {
                    return []
                }, On.prototype.getClass = function() {
                    return On
                }, An.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function() {
                    return .001
                }, An.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
                    return .001
                }, An.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
                    return 1e-6
                }, An.MAX_CLOSING_SEG_LEN_FACTOR.get = function() {
                    return 80
                }, Object.defineProperties(On, An);
                var Rn = function() {
                    this._distance = 0, this._precisionModel = null, this._bufParams = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this._precisionModel = t, this._bufParams = e
                };
                Rn.prototype.getOffsetCurve = function(t, e) {
                    if (this._distance = e, 0 === e) return null;
                    var n = e < 0,
                        i = Math.abs(e),
                        o = this.getSegGen(i);
                    t.length <= 1 ? this.computePointCurve(t[0], o) : this.computeOffsetCurve(t, n, o);
                    var r = o.getCoordinates();
                    return n && wt.reverse(r), r
                }, Rn.prototype.computeSingleSidedBufferCurve = function(t, e, n) {
                    var i = this.simplifyTolerance(this._distance);
                    if (e) {
                        n.addSegments(t, !0);
                        var o = wn.simplify(t, -i),
                            r = o.length - 1;
                        n.initSideSegments(o[r], o[r - 1], Ie.LEFT), n.addFirstSegment();
                        for (var s = r - 2; s >= 0; s--) n.addNextSegment(o[s], !0)
                    } else {
                        n.addSegments(t, !1);
                        var a = wn.simplify(t, i),
                            h = a.length - 1;
                        n.initSideSegments(a[0], a[1], Ie.LEFT), n.addFirstSegment();
                        for (var u = 2; u <= h; u++) n.addNextSegment(a[u], !0)
                    }
                    n.addLastSegment(), n.closeRing()
                }, Rn.prototype.computeRingBufferCurve = function(t, e, n) {
                    var i = this.simplifyTolerance(this._distance);
                    e === Ie.RIGHT && (i = -i);
                    var o = wn.simplify(t, i),
                        r = o.length - 1;
                    n.initSideSegments(o[r - 1], o[0], e);
                    for (var s = 1; s <= r; s++) {
                        var a = 1 !== s;
                        n.addNextSegment(o[s], a)
                    }
                    n.closeRing()
                }, Rn.prototype.computeLineBufferCurve = function(t, e) {
                    var n = this.simplifyTolerance(this._distance),
                        i = wn.simplify(t, n),
                        o = i.length - 1;
                    e.initSideSegments(i[0], i[1], Ie.LEFT);
                    for (var r = 2; r <= o; r++) e.addNextSegment(i[r], !0);
                    e.addLastSegment(), e.addLineEndCap(i[o - 1], i[o]);
                    var s = wn.simplify(t, -n),
                        a = s.length - 1;
                    e.initSideSegments(s[a], s[a - 1], Ie.LEFT);
                    for (var h = a - 2; h >= 0; h--) e.addNextSegment(s[h], !0);
                    e.addLastSegment(), e.addLineEndCap(s[1], s[0]), e.closeRing()
                }, Rn.prototype.computePointCurve = function(t, e) {
                    switch (this._bufParams.getEndCapStyle()) {
                        case Cn.CAP_ROUND:
                            e.createCircle(t);
                            break;
                        case Cn.CAP_SQUARE:
                            e.createSquare(t)
                    }
                }, Rn.prototype.getLineCurve = function(t, e) {
                    if (this._distance = e, e < 0 && !this._bufParams.isSingleSided()) return null;
                    if (0 === e) return null;
                    var n = Math.abs(e),
                        i = this.getSegGen(n);
                    if (t.length <= 1) this.computePointCurve(t[0], i);
                    else if (this._bufParams.isSingleSided()) {
                        var o = e < 0;
                        this.computeSingleSidedBufferCurve(t, o, i)
                    } else this.computeLineBufferCurve(t, i);
                    return i.getCoordinates()
                }, Rn.prototype.getBufferParameters = function() {
                    return this._bufParams
                }, Rn.prototype.simplifyTolerance = function(t) {
                    return t * this._bufParams.getSimplifyFactor()
                }, Rn.prototype.getRingCurve = function(t, e, n) {
                    if (this._distance = n, t.length <= 2) return this.getLineCurve(t, n);
                    if (0 === n) return Rn.copyCoordinates(t);
                    var i = this.getSegGen(n);
                    return this.computeRingBufferCurve(t, e, i), i.getCoordinates()
                }, Rn.prototype.computeOffsetCurve = function(t, e, n) {
                    var i = this.simplifyTolerance(this._distance);
                    if (e) {
                        var o = wn.simplify(t, -i),
                            r = o.length - 1;
                        n.initSideSegments(o[r], o[r - 1], Ie.LEFT), n.addFirstSegment();
                        for (var s = r - 2; s >= 0; s--) n.addNextSegment(o[s], !0)
                    } else {
                        var a = wn.simplify(t, i),
                            h = a.length - 1;
                        n.initSideSegments(a[0], a[1], Ie.LEFT), n.addFirstSegment();
                        for (var u = 2; u <= h; u++) n.addNextSegment(a[u], !0)
                    }
                    n.addLastSegment()
                }, Rn.prototype.getSegGen = function(t) {
                    return new On(this._precisionModel, this._bufParams, t)
                }, Rn.prototype.interfaces_ = function() {
                    return []
                }, Rn.prototype.getClass = function() {
                    return Rn
                }, Rn.copyCoordinates = function(t) {
                    for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++) e[n] = new C(t[n]);
                    return e
                };
                var Dn = function() {
                        this._subgraphs = null, this._seg = new _n, this._cga = new at;
                        var t = arguments[0];
                        this._subgraphs = t
                    },
                    kn = {
                        DepthSegment: {
                            configurable: !0
                        }
                    };
                Dn.prototype.findStabbedSegments = function() {
                    if (1 === arguments.length) {
                        for (var t = arguments[0], e = new Et, n = this._subgraphs.iterator(); n.hasNext();) {
                            var i = n.next(),
                                o = i.getEnvelope();
                            t.y < o.getMinY() || t.y > o.getMaxY() || this.findStabbedSegments(t, i.getDirectedEdges(), e)
                        }
                        return e
                    }
                    if (3 === arguments.length)
                        if (N(arguments[2], bt) && arguments[0] instanceof C && arguments[1] instanceof je) {
                            for (var r = arguments[0], s = arguments[1], a = arguments[2], h = s.getEdge().getCoordinates(), u = 0; u < h.length - 1; u++)
                                if (this._seg.p0 = h[u], this._seg.p1 = h[u + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse(), !(Math.max(this._seg.p0.x, this._seg.p1.x) < r.x || this._seg.isHorizontal() || r.y < this._seg.p0.y || r.y > this._seg.p1.y || at.computeOrientation(this._seg.p0, this._seg.p1, r) === at.RIGHT)) {
                                    var l = s.getDepth(Ie.LEFT);
                                    this._seg.p0.equals(h[u]) || (l = s.getDepth(Ie.RIGHT));
                                    var c = new Fn(this._seg, l);
                                    a.add(c)
                                }
                        } else if (N(arguments[2], bt) && arguments[0] instanceof C && N(arguments[1], bt))
                        for (var p = arguments[0], f = arguments[1], d = arguments[2], _ = f.iterator(); _.hasNext();) {
                            var g = _.next();
                            g.isForward() && this.findStabbedSegments(p, g, d)
                        }
                }, Dn.prototype.getDepth = function(t) {
                    var e = this.findStabbedSegments(t);
                    return 0 === e.size() ? 0 : $e.min(e)._leftDepth
                }, Dn.prototype.interfaces_ = function() {
                    return []
                }, Dn.prototype.getClass = function() {
                    return Dn
                }, kn.DepthSegment.get = function() {
                    return Fn
                }, Object.defineProperties(Dn, kn);
                var Fn = function() {
                    this._upwardSeg = null, this._leftDepth = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this._upwardSeg = new _n(t), this._leftDepth = e
                };
                Fn.prototype.compareTo = function(t) {
                    var e = t;
                    if (this._upwardSeg.minX() >= e._upwardSeg.maxX()) return 1;
                    if (this._upwardSeg.maxX() <= e._upwardSeg.minX()) return -1;
                    var n = this._upwardSeg.orientationIndex(e._upwardSeg);
                    return 0 !== n ? n : 0 != (n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg)) ? n : this._upwardSeg.compareTo(e._upwardSeg)
                }, Fn.prototype.compareX = function(t, e) {
                    var n = t.p0.compareTo(e.p0);
                    return 0 !== n ? n : t.p1.compareTo(e.p1)
                }, Fn.prototype.toString = function() {
                    return this._upwardSeg.toString()
                }, Fn.prototype.interfaces_ = function() {
                    return [x]
                }, Fn.prototype.getClass = function() {
                    return Fn
                };
                var zn = function(t, e, n) {
                    this.p0 = t || null, this.p1 = e || null, this.p2 = n || null
                };
                zn.prototype.area = function() {
                    return zn.area(this.p0, this.p1, this.p2)
                }, zn.prototype.signedArea = function() {
                    return zn.signedArea(this.p0, this.p1, this.p2)
                }, zn.prototype.interpolateZ = function(t) {
                    if (null === t) throw new y("Supplied point is null.");
                    return zn.interpolateZ(t, this.p0, this.p1, this.p2)
                }, zn.prototype.longestSideLength = function() {
                    return zn.longestSideLength(this.p0, this.p1, this.p2)
                }, zn.prototype.isAcute = function() {
                    return zn.isAcute(this.p0, this.p1, this.p2)
                }, zn.prototype.circumcentre = function() {
                    return zn.circumcentre(this.p0, this.p1, this.p2)
                }, zn.prototype.area3D = function() {
                    return zn.area3D(this.p0, this.p1, this.p2)
                }, zn.prototype.centroid = function() {
                    return zn.centroid(this.p0, this.p1, this.p2)
                }, zn.prototype.inCentre = function() {
                    return zn.inCentre(this.p0, this.p1, this.p2)
                }, zn.prototype.interfaces_ = function() {
                    return []
                }, zn.prototype.getClass = function() {
                    return zn
                }, zn.area = function(t, e, n) {
                    return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2)
                }, zn.signedArea = function(t, e, n) {
                    return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2
                }, zn.det = function(t, e, n, i) {
                    return t * i - e * n
                }, zn.interpolateZ = function(t, e, n, i) {
                    var o = e.x,
                        r = e.y,
                        s = n.x - o,
                        a = i.x - o,
                        h = n.y - r,
                        u = i.y - r,
                        l = s * u - a * h,
                        c = t.x - o,
                        p = t.y - r,
                        f = (u * c - a * p) / l,
                        d = (-h * c + s * p) / l;
                    return e.z + f * (n.z - e.z) + d * (i.z - e.z)
                }, zn.longestSideLength = function(t, e, n) {
                    var i = t.distance(e),
                        o = e.distance(n),
                        r = n.distance(t),
                        s = i;
                    return o > s && (s = o), r > s && (s = r), s
                }, zn.isAcute = function(t, e, n) {
                    return !!Nn.isAcute(t, e, n) && !!Nn.isAcute(e, n, t) && !!Nn.isAcute(n, t, e)
                }, zn.circumcentre = function(t, e, n) {
                    var i = n.x,
                        o = n.y,
                        r = t.x - i,
                        s = t.y - o,
                        a = e.x - i,
                        h = e.y - o,
                        u = 2 * zn.det(r, s, a, h),
                        l = zn.det(s, r * r + s * s, h, a * a + h * h),
                        c = zn.det(r, r * r + s * s, a, a * a + h * h);
                    return new C(i - l / u, o + c / u)
                }, zn.perpendicularBisector = function(t, e) {
                    var n = e.x - t.x,
                        i = e.y - t.y,
                        o = new V(t.x + n / 2, t.y + i / 2, 1),
                        r = new V(t.x - i + n / 2, t.y + n + i / 2, 1);
                    return new V(o, r)
                }, zn.angleBisector = function(t, e, n) {
                    var i = e.distance(t),
                        o = i / (i + e.distance(n)),
                        r = n.x - t.x,
                        s = n.y - t.y;
                    return new C(t.x + o * r, t.y + o * s)
                }, zn.area3D = function(t, e, n) {
                    var i = e.x - t.x,
                        o = e.y - t.y,
                        r = e.z - t.z,
                        s = n.x - t.x,
                        a = n.y - t.y,
                        h = n.z - t.z,
                        u = o * h - r * a,
                        l = r * s - i * h,
                        c = i * a - o * s,
                        p = u * u + l * l + c * c;
                    return Math.sqrt(p) / 2
                }, zn.centroid = function(t, e, n) {
                    var i = (t.x + e.x + n.x) / 3,
                        o = (t.y + e.y + n.y) / 3;
                    return new C(i, o)
                }, zn.inCentre = function(t, e, n) {
                    var i = e.distance(n),
                        o = t.distance(n),
                        r = t.distance(e),
                        s = i + o + r,
                        a = (i * t.x + o * e.x + r * n.x) / s,
                        h = (i * t.y + o * e.y + r * n.y) / s;
                    return new C(a, h)
                };
                var Bn = function() {
                    this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new Et;
                    var t = arguments[0],
                        e = arguments[1],
                        n = arguments[2];
                    this._inputGeom = t, this._distance = e, this._curveBuilder = n
                };
                Bn.prototype.addPoint = function(t) {
                    if (this._distance <= 0) return null;
                    var e = t.getCoordinates(),
                        n = this._curveBuilder.getLineCurve(e, this._distance);
                    this.addCurve(n, S.EXTERIOR, S.INTERIOR)
                }, Bn.prototype.addPolygon = function(t) {
                    var e = this._distance,
                        n = Ie.LEFT;
                    this._distance < 0 && (e = -this._distance, n = Ie.RIGHT);
                    var i = t.getExteriorRing(),
                        o = wt.removeRepeatedPoints(i.getCoordinates());
                    if (this._distance < 0 && this.isErodedCompletely(i, this._distance)) return null;
                    if (this._distance <= 0 && o.length < 3) return null;
                    this.addPolygonRing(o, e, n, S.EXTERIOR, S.INTERIOR);
                    for (var r = 0; r < t.getNumInteriorRing(); r++) {
                        var s = t.getInteriorRingN(r),
                            a = wt.removeRepeatedPoints(s.getCoordinates());
                        this._distance > 0 && this.isErodedCompletely(s, -this._distance) || this.addPolygonRing(a, e, Ie.opposite(n), S.INTERIOR, S.EXTERIOR)
                    }
                }, Bn.prototype.isTriangleErodedCompletely = function(t, e) {
                    var n = new zn(t[0], t[1], t[2]),
                        i = n.inCentre();
                    return at.distancePointLine(i, n.p0, n.p1) < Math.abs(e)
                }, Bn.prototype.addLineString = function(t) {
                    if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null;
                    var e = wt.removeRepeatedPoints(t.getCoordinates()),
                        n = this._curveBuilder.getLineCurve(e, this._distance);
                    this.addCurve(n, S.EXTERIOR, S.INTERIOR)
                }, Bn.prototype.addCurve = function(t, e, n) {
                    if (null === t || t.length < 2) return null;
                    var i = new dn(t, new Oe(0, S.BOUNDARY, e, n));
                    this._curveList.add(i)
                }, Bn.prototype.getCurves = function() {
                    return this.add(this._inputGeom), this._curveList
                }, Bn.prototype.addPolygonRing = function(t, e, n, i, o) {
                    if (0 === e && t.length < ee.MINIMUM_VALID_SIZE) return null;
                    var r = i,
                        s = o;
                    t.length >= ee.MINIMUM_VALID_SIZE && at.isCCW(t) && (r = o, s = i, n = Ie.opposite(n));
                    var a = this._curveBuilder.getRingCurve(t, n, e);
                    this.addCurve(a, r, s)
                }, Bn.prototype.add = function(t) {
                    if (t.isEmpty()) return null;
                    t instanceof $t ? this.addPolygon(t) : t instanceof Xt ? this.addLineString(t) : t instanceof Kt ? this.addPoint(t) : t instanceof te ? this.addCollection(t) : t instanceof qt ? this.addCollection(t) : t instanceof ne ? this.addCollection(t) : t instanceof jt && this.addCollection(t)
                }, Bn.prototype.isErodedCompletely = function(t, e) {
                    var n = t.getCoordinates();
                    if (n.length < 4) return e < 0;
                    if (4 === n.length) return this.isTriangleErodedCompletely(n, e);
                    var i = t.getEnvelopeInternal(),
                        o = Math.min(i.getHeight(), i.getWidth());
                    return e < 0 && 2 * Math.abs(e) > o
                }, Bn.prototype.addCollection = function(t) {
                    for (var e = 0; e < t.getNumGeometries(); e++) {
                        var n = t.getGeometryN(e);
                        this.add(n)
                    }
                }, Bn.prototype.interfaces_ = function() {
                    return []
                }, Bn.prototype.getClass = function() {
                    return Bn
                };
                var Gn = function() {};
                Gn.prototype.locate = function(t) {}, Gn.prototype.interfaces_ = function() {
                    return []
                }, Gn.prototype.getClass = function() {
                    return Gn
                };
                var Un = function() {
                    this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
                    var t = arguments[0];
                    this._parent = t, this._atStart = !0, this._index = 0, this._max = t.getNumGeometries()
                };
                Un.prototype.next = function() {
                    if (this._atStart) return this._atStart = !1, Un.isAtomic(this._parent) && this._index++, this._parent;
                    if (null !== this._subcollectionIterator) {
                        if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
                        this._subcollectionIterator = null
                    }
                    if (this._index >= this._max) throw new i;
                    var t = this._parent.getGeometryN(this._index++);
                    return t instanceof jt ? (this._subcollectionIterator = new Un(t), this._subcollectionIterator.next()) : t
                }, Un.prototype.remove = function() {
                    throw new Error(this.getClass().getName())
                }, Un.prototype.hasNext = function() {
                    if (this._atStart) return !0;
                    if (null !== this._subcollectionIterator) {
                        if (this._subcollectionIterator.hasNext()) return !0;
                        this._subcollectionIterator = null
                    }
                    return !(this._index >= this._max)
                }, Un.prototype.interfaces_ = function() {
                    return [xt]
                }, Un.prototype.getClass = function() {
                    return Un
                }, Un.isAtomic = function(t) {
                    return !(t instanceof jt)
                };
                var jn = function() {
                    this._geom = null;
                    var t = arguments[0];
                    this._geom = t
                };
                jn.prototype.locate = function(t) {
                    return jn.locate(t, this._geom)
                }, jn.prototype.interfaces_ = function() {
                    return [Gn]
                }, jn.prototype.getClass = function() {
                    return jn
                }, jn.isPointInRing = function(t, e) {
                    return !!e.getEnvelopeInternal().intersects(t) && at.isPointInRing(t, e.getCoordinates())
                }, jn.containsPointInPolygon = function(t, e) {
                    if (e.isEmpty()) return !1;
                    var n = e.getExteriorRing();
                    if (!jn.isPointInRing(t, n)) return !1;
                    for (var i = 0; i < e.getNumInteriorRing(); i++) {
                        var o = e.getInteriorRingN(i);
                        if (jn.isPointInRing(t, o)) return !1
                    }
                    return !0
                }, jn.containsPoint = function(t, e) {
                    if (e instanceof $t) return jn.containsPointInPolygon(t, e);
                    if (e instanceof jt)
                        for (var n = new Un(e); n.hasNext();) {
                            var i = n.next();
                            if (i !== e && jn.containsPoint(t, i)) return !0
                        }
                    return !1
                }, jn.locate = function(t, e) {
                    return e.isEmpty() ? S.EXTERIOR : jn.containsPoint(t, e) ? S.INTERIOR : S.EXTERIOR
                };
                var qn = function() {
                    this._edgeMap = new c, this._edgeList = null, this._ptInAreaLocation = [S.NONE, S.NONE]
                };
                qn.prototype.getNextCW = function(t) {
                    this.getEdges();
                    var e = this._edgeList.indexOf(t),
                        n = e - 1;
                    return 0 === e && (n = this._edgeList.size() - 1), this._edgeList.get(n)
                }, qn.prototype.propagateSideLabels = function(t) {
                    for (var e = S.NONE, n = this.iterator(); n.hasNext();) {
                        var i = n.next().getLabel();
                        i.isArea(t) && i.getLocation(t, Ie.LEFT) !== S.NONE && (e = i.getLocation(t, Ie.LEFT))
                    }
                    if (e === S.NONE) return null;
                    for (var o = e, r = this.iterator(); r.hasNext();) {
                        var s = r.next(),
                            a = s.getLabel();
                        if (a.getLocation(t, Ie.ON) === S.NONE && a.setLocation(t, Ie.ON, o), a.isArea(t)) {
                            var h = a.getLocation(t, Ie.LEFT),
                                u = a.getLocation(t, Ie.RIGHT);
                            if (u !== S.NONE) {
                                if (u !== o) throw new Se("side location conflict", s.getCoordinate());
                                h === S.NONE && et.shouldNeverReachHere("found single null side (at " + s.getCoordinate() + ")"), o = h
                            } else et.isTrue(a.getLocation(t, Ie.LEFT) === S.NONE, "found single null side"), a.setLocation(t, Ie.RIGHT, o), a.setLocation(t, Ie.LEFT, o)
                        }
                    }
                }, qn.prototype.getCoordinate = function() {
                    var t = this.iterator();
                    return t.hasNext() ? t.next().getCoordinate() : null
                }, qn.prototype.print = function(t) {
                    Z.out.println("EdgeEndStar:   " + this.getCoordinate());
                    for (var e = this.iterator(); e.hasNext();) e.next().print(t)
                }, qn.prototype.isAreaLabelsConsistent = function(t) {
                    return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0)
                }, qn.prototype.checkAreaLabelsConsistent = function(t) {
                    var e = this.getEdges();
                    if (e.size() <= 0) return !0;
                    var n = e.size() - 1,
                        i = e.get(n).getLabel().getLocation(t, Ie.LEFT);
                    et.isTrue(i !== S.NONE, "Found unlabelled area edge");
                    for (var o = i, r = this.iterator(); r.hasNext();) {
                        var s = r.next().getLabel();
                        et.isTrue(s.isArea(t), "Found non-area edge");
                        var a = s.getLocation(t, Ie.LEFT),
                            h = s.getLocation(t, Ie.RIGHT);
                        if (a === h) return !1;
                        if (h !== o) return !1;
                        o = a
                    }
                    return !0
                }, qn.prototype.findIndex = function(t) {
                    this.iterator();
                    for (var e = 0; e < this._edgeList.size(); e++)
                        if (this._edgeList.get(e) === t) return e;
                    return -1
                }, qn.prototype.iterator = function() {
                    return this.getEdges().iterator()
                }, qn.prototype.getEdges = function() {
                    return null === this._edgeList && (this._edgeList = new Et(this._edgeMap.values())), this._edgeList
                }, qn.prototype.getLocation = function(t, e, n) {
                    return this._ptInAreaLocation[t] === S.NONE && (this._ptInAreaLocation[t] = jn.locate(e, n[t].getGeometry())), this._ptInAreaLocation[t]
                }, qn.prototype.toString = function() {
                    var t = new A;
                    t.append("EdgeEndStar:   " + this.getCoordinate()), t.append("\n");
                    for (var e = this.iterator(); e.hasNext();) {
                        var n = e.next();
                        t.append(n), t.append("\n")
                    }
                    return t.toString()
                }, qn.prototype.computeEdgeEndLabels = function(t) {
                    for (var e = this.iterator(); e.hasNext();) e.next().computeLabel(t)
                }, qn.prototype.computeLabelling = function(t) {
                    this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
                    for (var e = [!1, !1], n = this.iterator(); n.hasNext();)
                        for (var i = n.next().getLabel(), o = 0; o < 2; o++) i.isLine(o) && i.getLocation(o) === S.BOUNDARY && (e[o] = !0);
                    for (var r = this.iterator(); r.hasNext();)
                        for (var s = r.next(), a = s.getLabel(), h = 0; h < 2; h++)
                            if (a.isAnyNull(h)) {
                                var u = S.NONE;
                                if (e[h]) u = S.EXTERIOR;
                                else {
                                    var l = s.getCoordinate();
                                    u = this.getLocation(h, l, t)
                                }
                                a.setAllLocationsIfNull(h, u)
                            }
                }, qn.prototype.getDegree = function() {
                    return this._edgeMap.size()
                }, qn.prototype.insertEdgeEnd = function(t, e) {
                    this._edgeMap.put(t, e), this._edgeList = null
                }, qn.prototype.interfaces_ = function() {
                    return []
                }, qn.prototype.getClass = function() {
                    return qn
                };
                var Zn = function(t) {
                        function e() {
                            t.call(this), this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.linkResultDirectedEdges = function() {
                            this.getResultAreaEdges();
                            for (var t = null, e = null, n = this._SCANNING_FOR_INCOMING, i = 0; i < this._resultAreaEdgeList.size(); i++) {
                                var o = this._resultAreaEdgeList.get(i),
                                    r = o.getSym();
                                if (o.getLabel().isArea()) switch (null === t && o.isInResult() && (t = o), n) {
                                    case this._SCANNING_FOR_INCOMING:
                                        if (!r.isInResult()) continue;
                                        e = r, n = this._LINKING_TO_OUTGOING;
                                        break;
                                    case this._LINKING_TO_OUTGOING:
                                        if (!o.isInResult()) continue;
                                        e.setNext(o), n = this._SCANNING_FOR_INCOMING
                                }
                            }
                            if (n === this._LINKING_TO_OUTGOING) {
                                if (null === t) throw new Se("no outgoing dirEdge found", this.getCoordinate());
                                et.isTrue(t.isInResult(), "unable to link last incoming dirEdge"), e.setNext(t)
                            }
                        }, e.prototype.insert = function(t) {
                            var e = t;
                            this.insertEdgeEnd(e, e)
                        }, e.prototype.getRightmostEdge = function() {
                            var t = this.getEdges(),
                                e = t.size();
                            if (e < 1) return null;
                            var n = t.get(0);
                            if (1 === e) return n;
                            var i = t.get(e - 1),
                                o = n.getQuadrant(),
                                r = i.getQuadrant();
                            return Be.isNorthern(o) && Be.isNorthern(r) ? n : Be.isNorthern(o) || Be.isNorthern(r) ? 0 !== n.getDy() ? n : 0 !== i.getDy() ? i : (et.shouldNeverReachHere("found two horizontal edges incident on node"), null) : i
                        }, e.prototype.print = function(t) {
                            Z.out.println("DirectedEdgeStar: " + this.getCoordinate());
                            for (var e = this.iterator(); e.hasNext();) {
                                var n = e.next();
                                t.print("out "), n.print(t), t.println(), t.print("in "), n.getSym().print(t), t.println()
                            }
                        }, e.prototype.getResultAreaEdges = function() {
                            if (null !== this._resultAreaEdgeList) return this._resultAreaEdgeList;
                            this._resultAreaEdgeList = new Et;
                            for (var t = this.iterator(); t.hasNext();) {
                                var e = t.next();
                                (e.isInResult() || e.getSym().isInResult()) && this._resultAreaEdgeList.add(e)
                            }
                            return this._resultAreaEdgeList
                        }, e.prototype.updateLabelling = function(t) {
                            for (var e = this.iterator(); e.hasNext();) {
                                var n = e.next().getLabel();
                                n.setAllLocationsIfNull(0, t.getLocation(0)), n.setAllLocationsIfNull(1, t.getLocation(1))
                            }
                        }, e.prototype.linkAllDirectedEdges = function() {
                            this.getEdges();
                            for (var t = null, e = null, n = this._edgeList.size() - 1; n >= 0; n--) {
                                var i = this._edgeList.get(n),
                                    o = i.getSym();
                                null === e && (e = o), null !== t && o.setNext(t), t = i
                            }
                            e.setNext(t)
                        }, e.prototype.computeDepths = function() {
                            if (1 === arguments.length) {
                                var t = arguments[0],
                                    e = this.findIndex(t),
                                    n = t.getDepth(Ie.LEFT),
                                    i = t.getDepth(Ie.RIGHT),
                                    o = this.computeDepths(e + 1, this._edgeList.size(), n);
                                if (this.computeDepths(0, e, o) !== i) throw new Se("depth mismatch at " + t.getCoordinate())
                            } else if (3 === arguments.length) {
                                for (var r = arguments[0], s = arguments[1], a = arguments[2], h = r; h < s; h++) {
                                    var u = this._edgeList.get(h);
                                    u.setEdgeDepths(Ie.RIGHT, a), a = u.getDepth(Ie.LEFT)
                                }
                                return a
                            }
                        }, e.prototype.mergeSymLabels = function() {
                            for (var t = this.iterator(); t.hasNext();) {
                                var e = t.next();
                                e.getLabel().merge(e.getSym().getLabel())
                            }
                        }, e.prototype.linkMinimalDirectedEdges = function(t) {
                            for (var e = null, n = null, i = this._SCANNING_FOR_INCOMING, o = this._resultAreaEdgeList.size() - 1; o >= 0; o--) {
                                var r = this._resultAreaEdgeList.get(o),
                                    s = r.getSym();
                                switch (null === e && r.getEdgeRing() === t && (e = r), i) {
                                    case this._SCANNING_FOR_INCOMING:
                                        if (s.getEdgeRing() !== t) continue;
                                        n = s, i = this._LINKING_TO_OUTGOING;
                                        break;
                                    case this._LINKING_TO_OUTGOING:
                                        if (r.getEdgeRing() !== t) continue;
                                        n.setNextMin(r), i = this._SCANNING_FOR_INCOMING
                                }
                            }
                            i === this._LINKING_TO_OUTGOING && (et.isTrue(null !== e, "found null for first outgoing dirEdge"), et.isTrue(e.getEdgeRing() === t, "unable to link last incoming dirEdge"), n.setNextMin(e))
                        }, e.prototype.getOutgoingDegree = function() {
                            if (0 === arguments.length) {
                                for (var t = 0, e = this.iterator(); e.hasNext();) e.next().isInResult() && t++;
                                return t
                            }
                            if (1 === arguments.length) {
                                for (var n = arguments[0], i = 0, o = this.iterator(); o.hasNext();) o.next().getEdgeRing() === n && i++;
                                return i
                            }
                        }, e.prototype.getLabel = function() {
                            return this._label
                        }, e.prototype.findCoveredLineEdges = function() {
                            for (var t = S.NONE, e = this.iterator(); e.hasNext();) {
                                var n = e.next(),
                                    i = n.getSym();
                                if (!n.isLineEdge()) {
                                    if (n.isInResult()) {
                                        t = S.INTERIOR;
                                        break
                                    }
                                    if (i.isInResult()) {
                                        t = S.EXTERIOR;
                                        break
                                    }
                                }
                            }
                            if (t === S.NONE) return null;
                            for (var o = t, r = this.iterator(); r.hasNext();) {
                                var s = r.next(),
                                    a = s.getSym();
                                s.isLineEdge() ? s.getEdge().setCovered(o === S.INTERIOR) : (s.isInResult() && (o = S.EXTERIOR), a.isInResult() && (o = S.INTERIOR))
                            }
                        }, e.prototype.computeLabelling = function(e) {
                            t.prototype.computeLabelling.call(this, e), this._label = new Oe(S.NONE);
                            for (var n = this.iterator(); n.hasNext();)
                                for (var i = n.next().getEdge().getLabel(), o = 0; o < 2; o++) {
                                    var r = i.getLocation(o);
                                    r !== S.INTERIOR && r !== S.BOUNDARY || this._label.setLocation(o, S.INTERIOR)
                                }
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e
                    }(qn),
                    Vn = function(t) {
                        function e() {
                            t.apply(this, arguments)
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.createNode = function(t) {
                            return new Fe(t, new Zn)
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e
                    }(qe),
                    Hn = function t() {
                        this._pts = null, this._orientation = null;
                        var e = arguments[0];
                        this._pts = e, this._orientation = t.orientation(e)
                    };
                Hn.prototype.compareTo = function(t) {
                    var e = t;
                    return Hn.compareOriented(this._pts, this._orientation, e._pts, e._orientation)
                }, Hn.prototype.interfaces_ = function() {
                    return [x]
                }, Hn.prototype.getClass = function() {
                    return Hn
                }, Hn.orientation = function(t) {
                    return 1 === wt.increasingDirection(t)
                }, Hn.compareOriented = function(t, e, n, i) {
                    for (var o = e ? 1 : -1, r = i ? 1 : -1, s = e ? t.length : -1, a = i ? n.length : -1, h = e ? 0 : t.length - 1, u = i ? 0 : n.length - 1;;) {
                        var l = t[h].compareTo(n[u]);
                        if (0 !== l) return l;
                        var c = (h += o) === s,
                            p = (u += r) === a;
                        if (c && !p) return -1;
                        if (!c && p) return 1;
                        if (c && p) return 0
                    }
                };
                var Yn = function() {
                    this._edges = new Et, this._ocaMap = new c
                };
                Yn.prototype.print = function(t) {
                    t.print("MULTILINESTRING ( ");
                    for (var e = 0; e < this._edges.size(); e++) {
                        var n = this._edges.get(e);
                        e > 0 && t.print(","), t.print("(");
                        for (var i = n.getCoordinates(), o = 0; o < i.length; o++) o > 0 && t.print(","), t.print(i[o].x + " " + i[o].y);
                        t.println(")")
                    }
                    t.print(")  ")
                }, Yn.prototype.addAll = function(t) {
                    for (var e = t.iterator(); e.hasNext();) this.add(e.next())
                }, Yn.prototype.findEdgeIndex = function(t) {
                    for (var e = 0; e < this._edges.size(); e++)
                        if (this._edges.get(e).equals(t)) return e;
                    return -1
                }, Yn.prototype.iterator = function() {
                    return this._edges.iterator()
                }, Yn.prototype.getEdges = function() {
                    return this._edges
                }, Yn.prototype.get = function(t) {
                    return this._edges.get(t)
                }, Yn.prototype.findEqualEdge = function(t) {
                    var e = new Hn(t.getCoordinates());
                    return this._ocaMap.get(e)
                }, Yn.prototype.add = function(t) {
                    this._edges.add(t);
                    var e = new Hn(t.getCoordinates());
                    this._ocaMap.put(e, t)
                }, Yn.prototype.interfaces_ = function() {
                    return []
                }, Yn.prototype.getClass = function() {
                    return Yn
                };
                var Wn = function() {};
                Wn.prototype.processIntersections = function(t, e, n, i) {}, Wn.prototype.isDone = function() {}, Wn.prototype.interfaces_ = function() {
                    return []
                }, Wn.prototype.getClass = function() {
                    return Wn
                };
                var Xn = function() {
                    this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
                    var t = arguments[0];
                    this._li = t
                };
                Xn.prototype.isTrivialIntersection = function(t, e, n, i) {
                    if (t === n && 1 === this._li.getIntersectionNum()) {
                        if (Xn.isAdjacentSegments(e, i)) return !0;
                        if (t.isClosed()) {
                            var o = t.size() - 1;
                            if (0 === e && i === o || 0 === i && e === o) return !0
                        }
                    }
                    return !1
                }, Xn.prototype.getProperIntersectionPoint = function() {
                    return this._properIntersectionPoint
                }, Xn.prototype.hasProperInteriorIntersection = function() {
                    return this._hasProperInterior
                }, Xn.prototype.getLineIntersector = function() {
                    return this._li
                }, Xn.prototype.hasProperIntersection = function() {
                    return this._hasProper
                }, Xn.prototype.processIntersections = function(t, e, n, i) {
                    if (t === n && e === i) return null;
                    this.numTests++;
                    var o = t.getCoordinates()[e],
                        r = t.getCoordinates()[e + 1],
                        s = n.getCoordinates()[i],
                        a = n.getCoordinates()[i + 1];
                    this._li.computeIntersection(o, r, s, a), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)))
                }, Xn.prototype.hasIntersection = function() {
                    return this._hasIntersection
                }, Xn.prototype.isDone = function() {
                    return !1
                }, Xn.prototype.hasInteriorIntersection = function() {
                    return this._hasInterior
                }, Xn.prototype.interfaces_ = function() {
                    return [Wn]
                }, Xn.prototype.getClass = function() {
                    return Xn
                }, Xn.isAdjacentSegments = function(t, e) {
                    return 1 === Math.abs(t - e)
                };
                var Jn = function() {
                    this.coord = null, this.segmentIndex = null, this.dist = null;
                    var t = arguments[0],
                        e = arguments[1],
                        n = arguments[2];
                    this.coord = new C(t), this.segmentIndex = e, this.dist = n
                };
                Jn.prototype.getSegmentIndex = function() {
                    return this.segmentIndex
                }, Jn.prototype.getCoordinate = function() {
                    return this.coord
                }, Jn.prototype.print = function(t) {
                    t.print(this.coord), t.print(" seg # = " + this.segmentIndex), t.println(" dist = " + this.dist)
                }, Jn.prototype.compareTo = function(t) {
                    var e = t;
                    return this.compare(e.segmentIndex, e.dist)
                }, Jn.prototype.isEndPoint = function(t) {
                    return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t
                }, Jn.prototype.toString = function() {
                    return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist
                }, Jn.prototype.getDistance = function() {
                    return this.dist
                }, Jn.prototype.compare = function(t, e) {
                    return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0
                }, Jn.prototype.interfaces_ = function() {
                    return [x]
                }, Jn.prototype.getClass = function() {
                    return Jn
                };
                var Kn = function() {
                    this._nodeMap = new c, this.edge = null;
                    var t = arguments[0];
                    this.edge = t
                };
                Kn.prototype.print = function(t) {
                    t.println("Intersections:");
                    for (var e = this.iterator(); e.hasNext();) e.next().print(t)
                }, Kn.prototype.iterator = function() {
                    return this._nodeMap.values().iterator()
                }, Kn.prototype.addSplitEdges = function(t) {
                    this.addEndpoints();
                    for (var e = this.iterator(), n = e.next(); e.hasNext();) {
                        var i = e.next(),
                            o = this.createSplitEdge(n, i);
                        t.add(o), n = i
                    }
                }, Kn.prototype.addEndpoints = function() {
                    var t = this.edge.pts.length - 1;
                    this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0)
                }, Kn.prototype.createSplitEdge = function(t, e) {
                    var n = e.segmentIndex - t.segmentIndex + 2,
                        i = this.edge.pts[e.segmentIndex],
                        o = e.dist > 0 || !e.coord.equals2D(i);
                    o || n--;
                    var r = new Array(n).fill(null),
                        s = 0;
                    r[s++] = new C(t.coord);
                    for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) r[s++] = this.edge.pts[a];
                    return o && (r[s] = e.coord), new ni(r, new Oe(this.edge._label))
                }, Kn.prototype.add = function(t, e, n) {
                    var i = new Jn(t, e, n),
                        o = this._nodeMap.get(i);
                    return null !== o ? o : (this._nodeMap.put(i, i), i)
                }, Kn.prototype.isIntersection = function(t) {
                    for (var e = this.iterator(); e.hasNext();)
                        if (e.next().coord.equals(t)) return !0;
                    return !1
                }, Kn.prototype.interfaces_ = function() {
                    return []
                }, Kn.prototype.getClass = function() {
                    return Kn
                };
                var Qn = function() {};
                Qn.prototype.getChainStartIndices = function(t) {
                    var e = 0,
                        n = new Et;
                    n.add(new R(e));
                    do {
                        var i = this.findChainEnd(t, e);
                        n.add(new R(i)), e = i
                    } while (e < t.length - 1);
                    return Qn.toIntArray(n)
                }, Qn.prototype.findChainEnd = function(t, e) {
                    for (var n = Be.quadrant(t[e], t[e + 1]), i = e + 1; i < t.length && Be.quadrant(t[i - 1], t[i]) === n;) i++;
                    return i - 1
                }, Qn.prototype.interfaces_ = function() {
                    return []
                }, Qn.prototype.getClass = function() {
                    return Qn
                }, Qn.toIntArray = function(t) {
                    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) e[n] = t.get(n).intValue();
                    return e
                };
                var $n = function() {
                    this.e = null, this.pts = null, this.startIndex = null, this.env1 = new H, this.env2 = new H;
                    var t = arguments[0];
                    this.e = t, this.pts = t.getCoordinates();
                    var e = new Qn;
                    this.startIndex = e.getChainStartIndices(this.pts)
                };
                $n.prototype.getCoordinates = function() {
                    return this.pts
                }, $n.prototype.getMaxX = function(t) {
                    var e = this.pts[this.startIndex[t]].x,
                        n = this.pts[this.startIndex[t + 1]].x;
                    return e > n ? e : n
                }, $n.prototype.getMinX = function(t) {
                    var e = this.pts[this.startIndex[t]].x,
                        n = this.pts[this.startIndex[t + 1]].x;
                    return e < n ? e : n
                }, $n.prototype.computeIntersectsForChain = function() {
                    if (4 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1],
                            n = arguments[2],
                            i = arguments[3];
                        this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], i)
                    } else if (6 === arguments.length) {
                        var o = arguments[0],
                            r = arguments[1],
                            s = arguments[2],
                            a = arguments[3],
                            h = arguments[4],
                            u = arguments[5],
                            l = this.pts[o],
                            c = this.pts[r],
                            p = s.pts[a],
                            f = s.pts[h];
                        if (r - o == 1 && h - a == 1) return u.addIntersections(this.e, o, s.e, a), null;
                        if (this.env1.init(l, c), this.env2.init(p, f), !this.env1.intersects(this.env2)) return null;
                        var d = Math.trunc((o + r) / 2),
                            _ = Math.trunc((a + h) / 2);
                        o < d && (a < _ && this.computeIntersectsForChain(o, d, s, a, _, u), _ < h && this.computeIntersectsForChain(o, d, s, _, h, u)), d < r && (a < _ && this.computeIntersectsForChain(d, r, s, a, _, u), _ < h && this.computeIntersectsForChain(d, r, s, _, h, u))
                    }
                }, $n.prototype.getStartIndexes = function() {
                    return this.startIndex
                }, $n.prototype.computeIntersects = function(t, e) {
                    for (var n = 0; n < this.startIndex.length - 1; n++)
                        for (var i = 0; i < t.startIndex.length - 1; i++) this.computeIntersectsForChain(n, t, i, e)
                }, $n.prototype.interfaces_ = function() {
                    return []
                }, $n.prototype.getClass = function() {
                    return $n
                };
                var ti = function t() {
                        this._depth = Array(2).fill().map(function() {
                            return Array(3)
                        });
                        for (var e = 0; e < 2; e++)
                            for (var n = 0; n < 3; n++) this._depth[e][n] = t.NULL_VALUE
                    },
                    ei = {
                        NULL_VALUE: {
                            configurable: !0
                        }
                    };
                ti.prototype.getDepth = function(t, e) {
                    return this._depth[t][e]
                }, ti.prototype.setDepth = function(t, e, n) {
                    this._depth[t][e] = n
                }, ti.prototype.isNull = function() {
                    if (0 === arguments.length) {
                        for (var t = 0; t < 2; t++)
                            for (var e = 0; e < 3; e++)
                                if (this._depth[t][e] !== ti.NULL_VALUE) return !1;
                        return !0
                    }
                    if (1 === arguments.length) {
                        var n = arguments[0];
                        return this._depth[n][1] === ti.NULL_VALUE
                    }
                    if (2 === arguments.length) {
                        var i = arguments[0],
                            o = arguments[1];
                        return this._depth[i][o] === ti.NULL_VALUE
                    }
                }, ti.prototype.normalize = function() {
                    for (var t = 0; t < 2; t++)
                        if (!this.isNull(t)) {
                            var e = this._depth[t][1];
                            this._depth[t][2] < e && (e = this._depth[t][2]), e < 0 && (e = 0);
                            for (var n = 1; n < 3; n++) {
                                var i = 0;
                                this._depth[t][n] > e && (i = 1), this._depth[t][n] = i
                            }
                        }
                }, ti.prototype.getDelta = function(t) {
                    return this._depth[t][Ie.RIGHT] - this._depth[t][Ie.LEFT]
                }, ti.prototype.getLocation = function(t, e) {
                    return this._depth[t][e] <= 0 ? S.EXTERIOR : S.INTERIOR
                }, ti.prototype.toString = function() {
                    return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2]
                }, ti.prototype.add = function() {
                    if (1 === arguments.length)
                        for (var t = arguments[0], e = 0; e < 2; e++)
                            for (var n = 1; n < 3; n++) {
                                var i = t.getLocation(e, n);
                                i !== S.EXTERIOR && i !== S.INTERIOR || (this.isNull(e, n) ? this._depth[e][n] = ti.depthAtLocation(i) : this._depth[e][n] += ti.depthAtLocation(i))
                            } else if (3 === arguments.length) {
                                var o = arguments[0],
                                    r = arguments[1];
                                arguments[2] === S.INTERIOR && this._depth[o][r]++
                            }
                }, ti.prototype.interfaces_ = function() {
                    return []
                }, ti.prototype.getClass = function() {
                    return ti
                }, ti.depthAtLocation = function(t) {
                    return t === S.EXTERIOR ? 0 : t === S.INTERIOR ? 1 : ti.NULL_VALUE
                }, ei.NULL_VALUE.get = function() {
                    return -1
                }, Object.defineProperties(ti, ei);
                var ni = function(t) {
                        function e() {
                            if (t.call(this), this.pts = null, this._env = null, this.eiList = new Kn(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new ti, this._depthDelta = 0, 1 === arguments.length) {
                                var n = arguments[0];
                                e.call(this, n, null)
                            } else if (2 === arguments.length) {
                                var i = arguments[0],
                                    o = arguments[1];
                                this.pts = i, this._label = o
                            }
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getDepth = function() {
                            return this._depth
                        }, e.prototype.getCollapsedEdge = function() {
                            var t = new Array(2).fill(null);
                            return t[0] = this.pts[0], t[1] = this.pts[1], new e(t, Oe.toLineLabel(this._label))
                        }, e.prototype.isIsolated = function() {
                            return this._isIsolated
                        }, e.prototype.getCoordinates = function() {
                            return this.pts
                        }, e.prototype.setIsolated = function(t) {
                            this._isIsolated = t
                        }, e.prototype.setName = function(t) {
                            this._name = t
                        }, e.prototype.equals = function(t) {
                            if (!(t instanceof e)) return !1;
                            var n = t;
                            if (this.pts.length !== n.pts.length) return !1;
                            for (var i = !0, o = !0, r = this.pts.length, s = 0; s < this.pts.length; s++)
                                if (this.pts[s].equals2D(n.pts[s]) || (i = !1), this.pts[s].equals2D(n.pts[--r]) || (o = !1), !i && !o) return !1;
                            return !0
                        }, e.prototype.getCoordinate = function() {
                            if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null;
                            if (1 === arguments.length) {
                                var t = arguments[0];
                                return this.pts[t]
                            }
                        }, e.prototype.print = function(t) {
                            t.print("edge " + this._name + ": "), t.print("LINESTRING (");
                            for (var e = 0; e < this.pts.length; e++) e > 0 && t.print(","), t.print(this.pts[e].x + " " + this.pts[e].y);
                            t.print(")  " + this._label + " " + this._depthDelta)
                        }, e.prototype.computeIM = function(t) {
                            e.updateIM(this._label, t)
                        }, e.prototype.isCollapsed = function() {
                            return !!this._label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2])
                        }, e.prototype.isClosed = function() {
                            return this.pts[0].equals(this.pts[this.pts.length - 1])
                        }, e.prototype.getMaximumSegmentIndex = function() {
                            return this.pts.length - 1
                        }, e.prototype.getDepthDelta = function() {
                            return this._depthDelta
                        }, e.prototype.getNumPoints = function() {
                            return this.pts.length
                        }, e.prototype.printReverse = function(t) {
                            t.print("edge " + this._name + ": ");
                            for (var e = this.pts.length - 1; e >= 0; e--) t.print(this.pts[e] + " ");
                            t.println("")
                        }, e.prototype.getMonotoneChainEdge = function() {
                            return null === this._mce && (this._mce = new $n(this)), this._mce
                        }, e.prototype.getEnvelope = function() {
                            if (null === this._env) {
                                this._env = new H;
                                for (var t = 0; t < this.pts.length; t++) this._env.expandToInclude(this.pts[t])
                            }
                            return this._env
                        }, e.prototype.addIntersection = function(t, e, n, i) {
                            var o = new C(t.getIntersection(i)),
                                r = e,
                                s = t.getEdgeDistance(n, i),
                                a = r + 1;
                            if (a < this.pts.length) {
                                var h = this.pts[a];
                                o.equals2D(h) && (r = a, s = 0)
                            }
                            this.eiList.add(o, r, s)
                        }, e.prototype.toString = function() {
                            var t = new A;
                            t.append("edge " + this._name + ": "), t.append("LINESTRING (");
                            for (var e = 0; e < this.pts.length; e++) e > 0 && t.append(","), t.append(this.pts[e].x + " " + this.pts[e].y);
                            return t.append(")  " + this._label + " " + this._depthDelta), t.toString()
                        }, e.prototype.isPointwiseEqual = function(t) {
                            if (this.pts.length !== t.pts.length) return !1;
                            for (var e = 0; e < this.pts.length; e++)
                                if (!this.pts[e].equals2D(t.pts[e])) return !1;
                            return !0
                        }, e.prototype.setDepthDelta = function(t) {
                            this._depthDelta = t
                        }, e.prototype.getEdgeIntersectionList = function() {
                            return this.eiList
                        }, e.prototype.addIntersections = function(t, e, n) {
                            for (var i = 0; i < t.getIntersectionNum(); i++) this.addIntersection(t, e, n, i)
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e.updateIM = function() {
                            if (2 !== arguments.length) return t.prototype.updateIM.apply(this, arguments);
                            var e = arguments[0],
                                n = arguments[1];
                            n.setAtLeastIfValid(e.getLocation(0, Ie.ON), e.getLocation(1, Ie.ON), 1), e.isArea() && (n.setAtLeastIfValid(e.getLocation(0, Ie.LEFT), e.getLocation(1, Ie.LEFT), 2), n.setAtLeastIfValid(e.getLocation(0, Ie.RIGHT), e.getLocation(1, Ie.RIGHT), 2))
                        }, e
                    }(ke),
                    ii = function(t) {
                        this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Yn, this._bufParams = t || null
                    };
                ii.prototype.setWorkingPrecisionModel = function(t) {
                    this._workingPrecisionModel = t
                }, ii.prototype.insertUniqueEdge = function(t) {
                    var e = this._edgeList.findEqualEdge(t);
                    if (null !== e) {
                        var n = e.getLabel(),
                            i = t.getLabel();
                        e.isPointwiseEqual(t) || (i = new Oe(t.getLabel())).flip(), n.merge(i);
                        var o = ii.depthDelta(i),
                            r = e.getDepthDelta() + o;
                        e.setDepthDelta(r)
                    } else this._edgeList.add(t), t.setDepthDelta(ii.depthDelta(t.getLabel()))
                }, ii.prototype.buildSubgraphs = function(t, e) {
                    for (var n = new Et, i = t.iterator(); i.hasNext();) {
                        var o = i.next(),
                            r = o.getRightmostCoordinate(),
                            s = new Dn(n).getDepth(r);
                        o.computeDepth(s), o.findResultEdges(), n.add(o), e.add(o.getDirectedEdges(), o.getNodes())
                    }
                }, ii.prototype.createSubgraphs = function(t) {
                    for (var e = new Et, n = t.getNodes().iterator(); n.hasNext();) {
                        var i = n.next();
                        if (!i.isVisited()) {
                            var o = new Ne;
                            o.create(i), e.add(o)
                        }
                    }
                    return $e.sort(e, $e.reverseOrder()), e
                }, ii.prototype.createEmptyResultGeometry = function() {
                    return this._geomFact.createPolygon()
                }, ii.prototype.getNoder = function(t) {
                    if (null !== this._workingNoder) return this._workingNoder;
                    var e = new bn,
                        n = new ot;
                    return n.setPrecisionModel(t), e.setSegmentIntersector(new Xn(n)), e
                }, ii.prototype.buffer = function(t, e) {
                    var n = this._workingPrecisionModel;
                    null === n && (n = t.getPrecisionModel()), this._geomFact = t.getFactory();
                    var i = new Rn(n, this._bufParams),
                        o = new Bn(t, e, i).getCurves();
                    if (o.size() <= 0) return this.createEmptyResultGeometry();
                    this.computeNodedEdges(o, n), this._graph = new Ze(new Vn), this._graph.addEdges(this._edgeList.getEdges());
                    var r = this.createSubgraphs(this._graph),
                        s = new Ve(this._geomFact);
                    this.buildSubgraphs(r, s);
                    var a = s.getPolygons();
                    return a.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(a)
                }, ii.prototype.computeNodedEdges = function(t, e) {
                    var n = this.getNoder(e);
                    n.computeNodes(t);
                    for (var i = n.getNodedSubstrings().iterator(); i.hasNext();) {
                        var o = i.next(),
                            r = o.getCoordinates();
                        if (2 !== r.length || !r[0].equals2D(r[1])) {
                            var s = o.getData(),
                                a = new ni(o.getCoordinates(), new Oe(s));
                            this.insertUniqueEdge(a)
                        }
                    }
                }, ii.prototype.setNoder = function(t) {
                    this._workingNoder = t
                }, ii.prototype.interfaces_ = function() {
                    return []
                }, ii.prototype.getClass = function() {
                    return ii
                }, ii.depthDelta = function(t) {
                    var e = t.getLocation(0, Ie.LEFT),
                        n = t.getLocation(0, Ie.RIGHT);
                    return e === S.INTERIOR && n === S.EXTERIOR ? 1 : e === S.EXTERIOR && n === S.INTERIOR ? -1 : 0
                }, ii.convertSegStrings = function(t) {
                    for (var e = new me, n = new Et; t.hasNext();) {
                        var i = t.next(),
                            o = e.createLineString(i.getCoordinates());
                        n.add(o)
                    }
                    return e.buildGeometry(n)
                };
                var oi = function() {
                    if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, 2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        this._noder = t, this._scaleFactor = e, this._offsetX = 0, this._offsetY = 0, this._isScaled = !this.isIntegerPrecision()
                    } else if (4 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1],
                            o = arguments[2],
                            r = arguments[3];
                        this._noder = n, this._scaleFactor = i, this._offsetX = o, this._offsetY = r, this._isScaled = !this.isIntegerPrecision()
                    }
                };
                oi.prototype.rescale = function() {
                    if (N(arguments[0], Lt))
                        for (var t = arguments[0].iterator(); t.hasNext();) {
                            var e = t.next();
                            this.rescale(e.getCoordinates())
                        } else if (arguments[0] instanceof Array) {
                            for (var n = arguments[0], i = 0; i < n.length; i++) n[i].x = n[i].x / this._scaleFactor + this._offsetX, n[i].y = n[i].y / this._scaleFactor + this._offsetY;
                            2 === n.length && n[0].equals2D(n[1]) && Z.out.println(n)
                        }
                }, oi.prototype.scale = function() {
                    if (N(arguments[0], Lt)) {
                        for (var t = arguments[0], e = new Et, n = t.iterator(); n.hasNext();) {
                            var i = n.next();
                            e.add(new dn(this.scale(i.getCoordinates()), i.getData()))
                        }
                        return e
                    }
                    if (arguments[0] instanceof Array) {
                        for (var o = arguments[0], r = new Array(o.length).fill(null), s = 0; s < o.length; s++) r[s] = new C(Math.round((o[s].x - this._offsetX) * this._scaleFactor), Math.round((o[s].y - this._offsetY) * this._scaleFactor), o[s].z);
                        return wt.removeRepeatedPoints(r)
                    }
                }, oi.prototype.isIntegerPrecision = function() {
                    return 1 === this._scaleFactor
                }, oi.prototype.getNodedSubstrings = function() {
                    var t = this._noder.getNodedSubstrings();
                    return this._isScaled && this.rescale(t), t
                }, oi.prototype.computeNodes = function(t) {
                    var e = t;
                    this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e)
                }, oi.prototype.interfaces_ = function() {
                    return [Ln]
                }, oi.prototype.getClass = function() {
                    return oi
                };
                var ri = function() {
                        this._li = new ot, this._segStrings = null;
                        var t = arguments[0];
                        this._segStrings = t
                    },
                    si = {
                        fact: {
                            configurable: !0
                        }
                    };
                ri.prototype.checkEndPtVertexIntersections = function() {
                    if (0 === arguments.length)
                        for (var t = this._segStrings.iterator(); t.hasNext();) {
                            var e = t.next().getCoordinates();
                            this.checkEndPtVertexIntersections(e[0], this._segStrings), this.checkEndPtVertexIntersections(e[e.length - 1], this._segStrings)
                        } else if (2 === arguments.length)
                            for (var n = arguments[0], i = arguments[1].iterator(); i.hasNext();)
                                for (var o = i.next().getCoordinates(), r = 1; r < o.length - 1; r++)
                                    if (o[r].equals(n)) throw new $("found endpt/interior pt intersection at index " + r + " :pt " + n)
                }, ri.prototype.checkInteriorIntersections = function() {
                    if (0 === arguments.length)
                        for (var t = this._segStrings.iterator(); t.hasNext();)
                            for (var e = t.next(), n = this._segStrings.iterator(); n.hasNext();) {
                                var i = n.next();
                                this.checkInteriorIntersections(e, i)
                            } else if (2 === arguments.length)
                                for (var o = arguments[0], r = arguments[1], s = o.getCoordinates(), a = r.getCoordinates(), h = 0; h < s.length - 1; h++)
                                    for (var u = 0; u < a.length - 1; u++) this.checkInteriorIntersections(o, h, r, u);
                            else if (4 === arguments.length) {
                        var l = arguments[0],
                            c = arguments[1],
                            p = arguments[2],
                            f = arguments[3];
                        if (l === p && c === f) return null;
                        var d = l.getCoordinates()[c],
                            _ = l.getCoordinates()[c + 1],
                            g = p.getCoordinates()[f],
                            m = p.getCoordinates()[f + 1];
                        if (this._li.computeIntersection(d, _, g, m), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, d, _) || this.hasInteriorIntersection(this._li, g, m))) throw new $("found non-noded intersection at " + d + "-" + _ + " and " + g + "-" + m)
                    }
                }, ri.prototype.checkValid = function() {
                    this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses()
                }, ri.prototype.checkCollapses = function() {
                    if (0 === arguments.length)
                        for (var t = this._segStrings.iterator(); t.hasNext();) {
                            var e = t.next();
                            this.checkCollapses(e)
                        } else if (1 === arguments.length)
                            for (var n = arguments[0].getCoordinates(), i = 0; i < n.length - 2; i++) this.checkCollapse(n[i], n[i + 1], n[i + 2])
                }, ri.prototype.hasInteriorIntersection = function(t, e, n) {
                    for (var i = 0; i < t.getIntersectionNum(); i++) {
                        var o = t.getIntersection(i);
                        if (!o.equals(e) && !o.equals(n)) return !0
                    }
                    return !1
                }, ri.prototype.checkCollapse = function(t, e, n) {
                    if (t.equals(n)) throw new $("found non-noded collapse at " + ri.fact.createLineString([t, e, n]))
                }, ri.prototype.interfaces_ = function() {
                    return []
                }, ri.prototype.getClass = function() {
                    return ri
                }, si.fact.get = function() {
                    return new me
                }, Object.defineProperties(ri, si);
                var ai = function() {
                        this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
                        var t = arguments[0],
                            e = arguments[1],
                            n = arguments[2];
                        if (this._originalPt = t, this._pt = t, this._scaleFactor = e, this._li = n, e <= 0) throw new y("Scale factor must be non-zero");
                        1 !== e && (this._pt = new C(this.scale(t.x), this.scale(t.y)), this._p0Scaled = new C, this._p1Scaled = new C), this.initCorners(this._pt)
                    },
                    hi = {
                        SAFE_ENV_EXPANSION_FACTOR: {
                            configurable: !0
                        }
                    };
                ai.prototype.intersectsScaled = function(t, e) {
                    var n = Math.min(t.x, e.x),
                        i = Math.max(t.x, e.x),
                        o = Math.min(t.y, e.y),
                        r = Math.max(t.y, e.y),
                        s = this._maxx < n || this._minx > i || this._maxy < o || this._miny > r;
                    if (s) return !1;
                    var a = this.intersectsToleranceSquare(t, e);
                    return et.isTrue(!(s && a), "Found bad envelope test"), a
                }, ai.prototype.initCorners = function(t) {
                    this._minx = t.x - .5, this._maxx = t.x + .5, this._miny = t.y - .5, this._maxy = t.y + .5, this._corner[0] = new C(this._maxx, this._maxy), this._corner[1] = new C(this._minx, this._maxy), this._corner[2] = new C(this._minx, this._miny), this._corner[3] = new C(this._maxx, this._miny)
                }, ai.prototype.intersects = function(t, e) {
                    return 1 === this._scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this._p0Scaled), this.copyScaled(e, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled))
                }, ai.prototype.scale = function(t) {
                    return Math.round(t * this._scaleFactor)
                }, ai.prototype.getCoordinate = function() {
                    return this._originalPt
                }, ai.prototype.copyScaled = function(t, e) {
                    e.x = this.scale(t.x), e.y = this.scale(t.y)
                }, ai.prototype.getSafeEnvelope = function() {
                    if (null === this._safeEnv) {
                        var t = ai.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
                        this._safeEnv = new H(this._originalPt.x - t, this._originalPt.x + t, this._originalPt.y - t, this._originalPt.y + t)
                    }
                    return this._safeEnv
                }, ai.prototype.intersectsPixelClosure = function(t, e) {
                    return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!(this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), this._li.hasIntersection()))))
                }, ai.prototype.intersectsToleranceSquare = function(t, e) {
                    var n = !1,
                        i = !1;
                    return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!(this._li.isProper() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), this._li.isProper() || (this._li.hasIntersection() && (n = !0), this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), this._li.isProper() || (this._li.hasIntersection() && (i = !0), this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), this._li.isProper() || n && i || t.equals(this._pt) || e.equals(this._pt)))))
                }, ai.prototype.addSnappedNode = function(t, e) {
                    var n = t.getCoordinate(e),
                        i = t.getCoordinate(e + 1);
                    return !!this.intersects(n, i) && (t.addIntersection(this.getCoordinate(), e), !0)
                }, ai.prototype.interfaces_ = function() {
                    return []
                }, ai.prototype.getClass = function() {
                    return ai
                }, hi.SAFE_ENV_EXPANSION_FACTOR.get = function() {
                    return .75
                }, Object.defineProperties(ai, hi);
                var ui = function() {
                    this.tempEnv1 = new H, this.selectedSegment = new _n
                };
                ui.prototype.select = function() {
                    if (1 === arguments.length);
                    else if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        t.getLineSegment(e, this.selectedSegment), this.select(this.selectedSegment)
                    }
                }, ui.prototype.interfaces_ = function() {
                    return []
                }, ui.prototype.getClass = function() {
                    return ui
                };
                var li = function() {
                        this._index = null;
                        var t = arguments[0];
                        this._index = t
                    },
                    ci = {
                        HotPixelSnapAction: {
                            configurable: !0
                        }
                    };
                li.prototype.snap = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return this.snap(t, null, -1)
                    }
                    if (3 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1],
                            i = arguments[2],
                            o = e.getSafeEnvelope(),
                            r = new pi(e, n, i);
                        return this._index.query(o, {
                            interfaces_: function() {
                                return [Xe]
                            },
                            visitItem: function(t) {
                                t.select(o, r)
                            }
                        }), r.isNodeAdded()
                    }
                }, li.prototype.interfaces_ = function() {
                    return []
                }, li.prototype.getClass = function() {
                    return li
                }, ci.HotPixelSnapAction.get = function() {
                    return pi
                }, Object.defineProperties(li, ci);
                var pi = function(t) {
                        function e() {
                            t.call(this), this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;
                            var e = arguments[0],
                                n = arguments[1],
                                i = arguments[2];
                            this._hotPixel = e, this._parentEdge = n, this._hotPixelVertexIndex = i
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isNodeAdded = function() {
                            return this._isNodeAdded
                        }, e.prototype.select = function() {
                            if (2 !== arguments.length) return t.prototype.select.apply(this, arguments);
                            var e = arguments[0],
                                n = arguments[1],
                                i = e.getContext();
                            if (null !== this._parentEdge && i === this._parentEdge && n === this._hotPixelVertexIndex) return null;
                            this._isNodeAdded = this._hotPixel.addSnappedNode(i, n)
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e
                    }(ui),
                    fi = function() {
                        this._li = null, this._interiorIntersections = null;
                        var t = arguments[0];
                        this._li = t, this._interiorIntersections = new Et
                    };
                fi.prototype.processIntersections = function(t, e, n, i) {
                    if (t === n && e === i) return null;
                    var o = t.getCoordinates()[e],
                        r = t.getCoordinates()[e + 1],
                        s = n.getCoordinates()[i],
                        a = n.getCoordinates()[i + 1];
                    if (this._li.computeIntersection(o, r, s, a), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
                        for (var h = 0; h < this._li.getIntersectionNum(); h++) this._interiorIntersections.add(this._li.getIntersection(h));
                        t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1)
                    }
                }, fi.prototype.isDone = function() {
                    return !1
                }, fi.prototype.getInteriorIntersections = function() {
                    return this._interiorIntersections
                }, fi.prototype.interfaces_ = function() {
                    return [Wn]
                }, fi.prototype.getClass = function() {
                    return fi
                };
                var di = function() {
                    this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
                    var t = arguments[0];
                    this._pm = t, this._li = new ot, this._li.setPrecisionModel(t), this._scaleFactor = t.getScale()
                };
                di.prototype.checkCorrectness = function(t) {
                    var e = dn.getNodedSubstrings(t),
                        n = new ri(e);
                    try {
                        n.checkValid()
                    } catch (t) {
                        if (!(t instanceof j)) throw t;
                        t.printStackTrace()
                    }
                }, di.prototype.getNodedSubstrings = function() {
                    return dn.getNodedSubstrings(this._nodedSegStrings)
                }, di.prototype.snapRound = function(t, e) {
                    var n = this.findInteriorIntersections(t, e);
                    this.computeIntersectionSnaps(n), this.computeVertexSnaps(t)
                }, di.prototype.findInteriorIntersections = function(t, e) {
                    var n = new fi(e);
                    return this._noder.setSegmentIntersector(n), this._noder.computeNodes(t), n.getInteriorIntersections()
                }, di.prototype.computeVertexSnaps = function() {
                    if (N(arguments[0], Lt))
                        for (var t = arguments[0].iterator(); t.hasNext();) {
                            var e = t.next();
                            this.computeVertexSnaps(e)
                        } else if (arguments[0] instanceof dn)
                            for (var n = arguments[0], i = n.getCoordinates(), o = 0; o < i.length; o++) {
                                var r = new ai(i[o], this._scaleFactor, this._li);
                                this._pointSnapper.snap(r, n, o) && n.addIntersection(i[o], o)
                            }
                }, di.prototype.computeNodes = function(t) {
                    this._nodedSegStrings = t, this._noder = new bn, this._pointSnapper = new li(this._noder.getIndex()), this.snapRound(t, this._li)
                }, di.prototype.computeIntersectionSnaps = function(t) {
                    for (var e = t.iterator(); e.hasNext();) {
                        var n = e.next(),
                            i = new ai(n, this._scaleFactor, this._li);
                        this._pointSnapper.snap(i)
                    }
                }, di.prototype.interfaces_ = function() {
                    return [Ln]
                }, di.prototype.getClass = function() {
                    return di
                };
                var _i = function() {
                        if (this._argGeom = null, this._distance = null, this._bufParams = new Cn, this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {
                            var t = arguments[0];
                            this._argGeom = t
                        } else if (2 === arguments.length) {
                            var e = arguments[0],
                                n = arguments[1];
                            this._argGeom = e, this._bufParams = n
                        }
                    },
                    gi = {
                        CAP_ROUND: {
                            configurable: !0
                        },
                        CAP_BUTT: {
                            configurable: !0
                        },
                        CAP_FLAT: {
                            configurable: !0
                        },
                        CAP_SQUARE: {
                            configurable: !0
                        },
                        MAX_PRECISION_DIGITS: {
                            configurable: !0
                        }
                    };
                _i.prototype.bufferFixedPrecision = function(t) {
                    var e = new oi(new di(new fe(1)), t.getScale()),
                        n = new ii(this._bufParams);
                    n.setWorkingPrecisionModel(t), n.setNoder(e), this._resultGeometry = n.buffer(this._argGeom, this._distance)
                }, _i.prototype.bufferReducedPrecision = function() {
                    var t = this;
                    if (0 === arguments.length) {
                        for (var e = _i.MAX_PRECISION_DIGITS; e >= 0; e--) {
                            try {
                                t.bufferReducedPrecision(e)
                            } catch (e) {
                                if (!(e instanceof Se)) throw e;
                                t._saveException = e
                            }
                            if (null !== t._resultGeometry) return null
                        }
                        throw this._saveException
                    }
                    if (1 === arguments.length) {
                        var n = arguments[0],
                            i = _i.precisionScaleFactor(this._argGeom, this._distance, n),
                            o = new fe(i);
                        this.bufferFixedPrecision(o)
                    }
                }, _i.prototype.computeGeometry = function() {
                    if (this.bufferOriginalPrecision(), null !== this._resultGeometry) return null;
                    var t = this._argGeom.getFactory().getPrecisionModel();
                    t.getType() === fe.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision()
                }, _i.prototype.setQuadrantSegments = function(t) {
                    this._bufParams.setQuadrantSegments(t)
                }, _i.prototype.bufferOriginalPrecision = function() {
                    try {
                        var t = new ii(this._bufParams);
                        this._resultGeometry = t.buffer(this._argGeom, this._distance)
                    } catch (t) {
                        if (!(t instanceof $)) throw t;
                        this._saveException = t
                    }
                }, _i.prototype.getResultGeometry = function(t) {
                    return this._distance = t, this.computeGeometry(), this._resultGeometry
                }, _i.prototype.setEndCapStyle = function(t) {
                    this._bufParams.setEndCapStyle(t)
                }, _i.prototype.interfaces_ = function() {
                    return []
                }, _i.prototype.getClass = function() {
                    return _i
                }, _i.bufferOp = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        return new _i(t).getResultGeometry(e)
                    }
                    if (3 === arguments.length) {
                        if (Number.isInteger(arguments[2]) && arguments[0] instanceof lt && "number" == typeof arguments[1]) {
                            var n = arguments[0],
                                i = arguments[1],
                                o = arguments[2],
                                r = new _i(n);
                            return r.setQuadrantSegments(o), r.getResultGeometry(i)
                        }
                        if (arguments[2] instanceof Cn && arguments[0] instanceof lt && "number" == typeof arguments[1]) {
                            var s = arguments[0],
                                a = arguments[1],
                                h = arguments[2];
                            return new _i(s, h).getResultGeometry(a)
                        }
                    } else if (4 === arguments.length) {
                        var u = arguments[0],
                            l = arguments[1],
                            c = arguments[2],
                            p = arguments[3],
                            f = new _i(u);
                        return f.setQuadrantSegments(c), f.setEndCapStyle(p), f.getResultGeometry(l)
                    }
                }, _i.precisionScaleFactor = function(t, e, n) {
                    var i = t.getEnvelopeInternal(),
                        o = T.max(Math.abs(i.getMaxX()), Math.abs(i.getMaxY()), Math.abs(i.getMinX()), Math.abs(i.getMinY())) + 2 * (e > 0 ? e : 0),
                        r = n - Math.trunc(Math.log(o) / Math.log(10) + 1);
                    return Math.pow(10, r)
                }, gi.CAP_ROUND.get = function() {
                    return Cn.CAP_ROUND
                }, gi.CAP_BUTT.get = function() {
                    return Cn.CAP_FLAT
                }, gi.CAP_FLAT.get = function() {
                    return Cn.CAP_FLAT
                }, gi.CAP_SQUARE.get = function() {
                    return Cn.CAP_SQUARE
                }, gi.MAX_PRECISION_DIGITS.get = function() {
                    return 12
                }, Object.defineProperties(_i, gi);
                var mi = function() {
                    this._pt = [new C, new C], this._distance = v.NaN, this._isNull = !0
                };
                mi.prototype.getCoordinates = function() {
                    return this._pt
                }, mi.prototype.getCoordinate = function(t) {
                    return this._pt[t]
                }, mi.prototype.setMinimum = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        this.setMinimum(t._pt[0], t._pt[1])
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        if (this._isNull) return this.initialize(e, n), null;
                        var i = e.distance(n);
                        i < this._distance && this.initialize(e, n, i)
                    }
                }, mi.prototype.initialize = function() {
                    if (0 === arguments.length) this._isNull = !0;
                    else if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        this._pt[0].setCoordinate(t), this._pt[1].setCoordinate(e), this._distance = t.distance(e), this._isNull = !1
                    } else if (3 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1],
                            o = arguments[2];
                        this._pt[0].setCoordinate(n), this._pt[1].setCoordinate(i), this._distance = o, this._isNull = !1
                    }
                }, mi.prototype.getDistance = function() {
                    return this._distance
                }, mi.prototype.setMaximum = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        this.setMaximum(t._pt[0], t._pt[1])
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        if (this._isNull) return this.initialize(e, n), null;
                        var i = e.distance(n);
                        i > this._distance && this.initialize(e, n, i)
                    }
                }, mi.prototype.interfaces_ = function() {
                    return []
                }, mi.prototype.getClass = function() {
                    return mi
                };
                var yi = function() {};
                yi.prototype.interfaces_ = function() {
                    return []
                }, yi.prototype.getClass = function() {
                    return yi
                }, yi.computeDistance = function() {
                    if (arguments[2] instanceof mi && arguments[0] instanceof Xt && arguments[1] instanceof C)
                        for (var t = arguments[0], e = arguments[1], n = arguments[2], i = t.getCoordinates(), o = new _n, r = 0; r < i.length - 1; r++) {
                            o.setCoordinates(i[r], i[r + 1]);
                            var s = o.closestPoint(e);
                            n.setMinimum(s, e)
                        } else if (arguments[2] instanceof mi && arguments[0] instanceof $t && arguments[1] instanceof C) {
                            var a = arguments[0],
                                h = arguments[1],
                                u = arguments[2];
                            yi.computeDistance(a.getExteriorRing(), h, u);
                            for (var l = 0; l < a.getNumInteriorRing(); l++) yi.computeDistance(a.getInteriorRingN(l), h, u)
                        } else if (arguments[2] instanceof mi && arguments[0] instanceof lt && arguments[1] instanceof C) {
                        var c = arguments[0],
                            p = arguments[1],
                            f = arguments[2];
                        if (c instanceof Xt) yi.computeDistance(c, p, f);
                        else if (c instanceof $t) yi.computeDistance(c, p, f);
                        else if (c instanceof jt)
                            for (var d = c, _ = 0; _ < d.getNumGeometries(); _++) {
                                var g = d.getGeometryN(_);
                                yi.computeDistance(g, p, f)
                            } else f.setMinimum(c.getCoordinate(), p)
                    } else if (arguments[2] instanceof mi && arguments[0] instanceof _n && arguments[1] instanceof C) {
                        var m = arguments[0],
                            y = arguments[1],
                            v = arguments[2],
                            L = m.closestPoint(y);
                        v.setMinimum(L, y)
                    }
                };
                var vi = function(t) {
                        this._maxPtDist = new mi, this._inputGeom = t || null
                    },
                    Li = {
                        MaxPointDistanceFilter: {
                            configurable: !0
                        },
                        MaxMidpointDistanceFilter: {
                            configurable: !0
                        }
                    };
                vi.prototype.computeMaxMidpointDistance = function(t) {
                    var e = new bi(this._inputGeom);
                    t.apply(e), this._maxPtDist.setMaximum(e.getMaxPointDistance())
                }, vi.prototype.computeMaxVertexDistance = function(t) {
                    var e = new xi(this._inputGeom);
                    t.apply(e), this._maxPtDist.setMaximum(e.getMaxPointDistance())
                }, vi.prototype.findDistance = function(t) {
                    return this.computeMaxVertexDistance(t), this.computeMaxMidpointDistance(t), this._maxPtDist.getDistance()
                }, vi.prototype.getDistancePoints = function() {
                    return this._maxPtDist
                }, vi.prototype.interfaces_ = function() {
                    return []
                }, vi.prototype.getClass = function() {
                    return vi
                }, Li.MaxPointDistanceFilter.get = function() {
                    return xi
                }, Li.MaxMidpointDistanceFilter.get = function() {
                    return bi
                }, Object.defineProperties(vi, Li);
                var xi = function(t) {
                    this._maxPtDist = new mi, this._minPtDist = new mi, this._geom = t || null
                };
                xi.prototype.filter = function(t) {
                    this._minPtDist.initialize(), yi.computeDistance(this._geom, t, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist)
                }, xi.prototype.getMaxPointDistance = function() {
                    return this._maxPtDist
                }, xi.prototype.interfaces_ = function() {
                    return [ft]
                }, xi.prototype.getClass = function() {
                    return xi
                };
                var bi = function(t) {
                    this._maxPtDist = new mi, this._minPtDist = new mi, this._geom = t || null
                };
                bi.prototype.filter = function(t, e) {
                    if (0 === e) return null;
                    var n = t.getCoordinate(e - 1),
                        i = t.getCoordinate(e),
                        o = new C((n.x + i.x) / 2, (n.y + i.y) / 2);
                    this._minPtDist.initialize(), yi.computeDistance(this._geom, o, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist)
                }, bi.prototype.isDone = function() {
                    return !1
                }, bi.prototype.isGeometryChanged = function() {
                    return !1
                }, bi.prototype.getMaxPointDistance = function() {
                    return this._maxPtDist
                }, bi.prototype.interfaces_ = function() {
                    return [Ut]
                }, bi.prototype.getClass = function() {
                    return bi
                };
                var Ei = function(t) {
                    this._comps = t || null
                };
                Ei.prototype.filter = function(t) {
                    t instanceof $t && this._comps.add(t)
                }, Ei.prototype.interfaces_ = function() {
                    return [Gt]
                }, Ei.prototype.getClass = function() {
                    return Ei
                }, Ei.getPolygons = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return Ei.getPolygons(t, new Et)
                    }
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        return e instanceof $t ? n.add(e) : e instanceof jt && e.apply(new Ei(n)), n
                    }
                };
                var Ci = function() {
                    if (this._lines = null, this._isForcedToLineString = !1, 1 === arguments.length) {
                        var t = arguments[0];
                        this._lines = t
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        this._lines = e, this._isForcedToLineString = n
                    }
                };
                Ci.prototype.filter = function(t) {
                    if (this._isForcedToLineString && t instanceof ee) {
                        var e = t.getFactory().createLineString(t.getCoordinateSequence());
                        return this._lines.add(e), null
                    }
                    t instanceof Xt && this._lines.add(t)
                }, Ci.prototype.setForceToLineString = function(t) {
                    this._isForcedToLineString = t
                }, Ci.prototype.interfaces_ = function() {
                    return [ut]
                }, Ci.prototype.getClass = function() {
                    return Ci
                }, Ci.getGeometry = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return t.getFactory().buildGeometry(Ci.getLines(t))
                    }
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        return e.getFactory().buildGeometry(Ci.getLines(e, n))
                    }
                }, Ci.getLines = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return Ci.getLines(t, !1)
                    }
                    if (2 === arguments.length) {
                        if (N(arguments[0], Lt) && N(arguments[1], Lt)) {
                            for (var e = arguments[0], n = arguments[1], i = e.iterator(); i.hasNext();) {
                                var o = i.next();
                                Ci.getLines(o, n)
                            }
                            return n
                        }
                        if (arguments[0] instanceof lt && "boolean" == typeof arguments[1]) {
                            var r = arguments[0],
                                s = arguments[1],
                                a = new Et;
                            return r.apply(new Ci(a, s)), a
                        }
                        if (arguments[0] instanceof lt && N(arguments[1], Lt)) {
                            var h = arguments[0],
                                u = arguments[1];
                            return h instanceof Xt ? u.add(h) : h.apply(new Ci(u)), u
                        }
                    } else if (3 === arguments.length) {
                        if ("boolean" == typeof arguments[2] && N(arguments[0], Lt) && N(arguments[1], Lt)) {
                            for (var l = arguments[0], c = arguments[1], p = arguments[2], f = l.iterator(); f.hasNext();) {
                                var d = f.next();
                                Ci.getLines(d, c, p)
                            }
                            return c
                        }
                        if ("boolean" == typeof arguments[2] && arguments[0] instanceof lt && N(arguments[1], Lt)) {
                            var _ = arguments[0],
                                g = arguments[1],
                                m = arguments[2];
                            return _.apply(new Ci(g, m)), g
                        }
                    }
                };
                var Ii = function() {
                    if (this._boundaryRule = dt.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, 0 === arguments.length);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        if (null === t) throw new y("Rule must be non-null");
                        this._boundaryRule = t
                    }
                };
                Ii.prototype.locateInternal = function() {
                    if (arguments[0] instanceof C && arguments[1] instanceof $t) {
                        var t = arguments[0],
                            e = arguments[1];
                        if (e.isEmpty()) return S.EXTERIOR;
                        var n = e.getExteriorRing(),
                            i = this.locateInPolygonRing(t, n);
                        if (i === S.EXTERIOR) return S.EXTERIOR;
                        if (i === S.BOUNDARY) return S.BOUNDARY;
                        for (var o = 0; o < e.getNumInteriorRing(); o++) {
                            var r = e.getInteriorRingN(o),
                                s = this.locateInPolygonRing(t, r);
                            if (s === S.INTERIOR) return S.EXTERIOR;
                            if (s === S.BOUNDARY) return S.BOUNDARY
                        }
                        return S.INTERIOR
                    }
                    if (arguments[0] instanceof C && arguments[1] instanceof Xt) {
                        var a = arguments[0],
                            h = arguments[1];
                        if (!h.getEnvelopeInternal().intersects(a)) return S.EXTERIOR;
                        var u = h.getCoordinates();
                        return h.isClosed() || !a.equals(u[0]) && !a.equals(u[u.length - 1]) ? at.isOnLine(a, u) ? S.INTERIOR : S.EXTERIOR : S.BOUNDARY
                    }
                    if (arguments[0] instanceof C && arguments[1] instanceof Kt) {
                        var l = arguments[0];
                        return arguments[1].getCoordinate().equals2D(l) ? S.INTERIOR : S.EXTERIOR
                    }
                }, Ii.prototype.locateInPolygonRing = function(t, e) {
                    return e.getEnvelopeInternal().intersects(t) ? at.locatePointInRing(t, e.getCoordinates()) : S.EXTERIOR
                }, Ii.prototype.intersects = function(t, e) {
                    return this.locate(t, e) !== S.EXTERIOR
                }, Ii.prototype.updateLocationInfo = function(t) {
                    t === S.INTERIOR && (this._isIn = !0), t === S.BOUNDARY && this._numBoundaries++
                }, Ii.prototype.computeLocation = function(t, e) {
                    if (e instanceof Kt && this.updateLocationInfo(this.locateInternal(t, e)), e instanceof Xt) this.updateLocationInfo(this.locateInternal(t, e));
                    else if (e instanceof $t) this.updateLocationInfo(this.locateInternal(t, e));
                    else if (e instanceof qt)
                        for (var n = e, i = 0; i < n.getNumGeometries(); i++) {
                            var o = n.getGeometryN(i);
                            this.updateLocationInfo(this.locateInternal(t, o))
                        } else if (e instanceof ne)
                            for (var r = e, s = 0; s < r.getNumGeometries(); s++) {
                                var a = r.getGeometryN(s);
                                this.updateLocationInfo(this.locateInternal(t, a))
                            } else if (e instanceof jt)
                                for (var h = new Un(e); h.hasNext();) {
                                    var u = h.next();
                                    u !== e && this.computeLocation(t, u)
                                }
                }, Ii.prototype.locate = function(t, e) {
                    return e.isEmpty() ? S.EXTERIOR : e instanceof Xt ? this.locateInternal(t, e) : e instanceof $t ? this.locateInternal(t, e) : (this._isIn = !1, this._numBoundaries = 0, this.computeLocation(t, e), this._boundaryRule.isInBoundary(this._numBoundaries) ? S.BOUNDARY : this._numBoundaries > 0 || this._isIn ? S.INTERIOR : S.EXTERIOR)
                }, Ii.prototype.interfaces_ = function() {
                    return []
                }, Ii.prototype.getClass = function() {
                    return Ii
                };
                var wi = function t() {
                        if (this._component = null, this._segIndex = null, this._pt = null, 2 === arguments.length) {
                            var e = arguments[0],
                                n = arguments[1];
                            t.call(this, e, t.INSIDE_AREA, n)
                        } else if (3 === arguments.length) {
                            var i = arguments[0],
                                o = arguments[1],
                                r = arguments[2];
                            this._component = i, this._segIndex = o, this._pt = r
                        }
                    },
                    Mi = {
                        INSIDE_AREA: {
                            configurable: !0
                        }
                    };
                wi.prototype.isInsideArea = function() {
                    return this._segIndex === wi.INSIDE_AREA
                }, wi.prototype.getCoordinate = function() {
                    return this._pt
                }, wi.prototype.getGeometryComponent = function() {
                    return this._component
                }, wi.prototype.getSegmentIndex = function() {
                    return this._segIndex
                }, wi.prototype.interfaces_ = function() {
                    return []
                }, wi.prototype.getClass = function() {
                    return wi
                }, Mi.INSIDE_AREA.get = function() {
                    return -1
                }, Object.defineProperties(wi, Mi);
                var Si = function(t) {
                    this._pts = t || null
                };
                Si.prototype.filter = function(t) {
                    t instanceof Kt && this._pts.add(t)
                }, Si.prototype.interfaces_ = function() {
                    return [Gt]
                }, Si.prototype.getClass = function() {
                    return Si
                }, Si.getPoints = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return t instanceof Kt ? $e.singletonList(t) : Si.getPoints(t, new Et)
                    }
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        return e instanceof Kt ? n.add(e) : e instanceof jt && e.apply(new Si(n)), n
                    }
                };
                var Pi = function() {
                    this._locations = null;
                    var t = arguments[0];
                    this._locations = t
                };
                Pi.prototype.filter = function(t) {
                    (t instanceof Kt || t instanceof Xt || t instanceof $t) && this._locations.add(new wi(t, 0, t.getCoordinate()))
                }, Pi.prototype.interfaces_ = function() {
                    return [Gt]
                }, Pi.prototype.getClass = function() {
                    return Pi
                }, Pi.getLocations = function(t) {
                    var e = new Et;
                    return t.apply(new Pi(e)), e
                };
                var Ni = function() {
                    if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new Ii, this._minDistanceLocation = null, this._minDistance = v.MAX_VALUE, 2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        this._geom = [t, e], this._terminateDistance = 0
                    } else if (3 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1],
                            o = arguments[2];
                        this._geom = new Array(2).fill(null), this._geom[0] = n, this._geom[1] = i, this._terminateDistance = o
                    }
                };
                Ni.prototype.computeContainmentDistance = function() {
                    if (0 === arguments.length) {
                        var t = new Array(2).fill(null);
                        if (this.computeContainmentDistance(0, t), this._minDistance <= this._terminateDistance) return null;
                        this.computeContainmentDistance(1, t)
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1],
                            i = 1 - e,
                            o = Ei.getPolygons(this._geom[e]);
                        if (o.size() > 0) {
                            var r = Pi.getLocations(this._geom[i]);
                            if (this.computeContainmentDistance(r, o, n), this._minDistance <= this._terminateDistance) return this._minDistanceLocation[i] = n[0], this._minDistanceLocation[e] = n[1], null
                        }
                    } else if (3 === arguments.length)
                        if (arguments[2] instanceof Array && N(arguments[0], bt) && N(arguments[1], bt)) {
                            for (var s = arguments[0], a = arguments[1], h = arguments[2], u = 0; u < s.size(); u++)
                                for (var l = s.get(u), c = 0; c < a.size(); c++)
                                    if (this.computeContainmentDistance(l, a.get(c), h), this._minDistance <= this._terminateDistance) return null
                        } else if (arguments[2] instanceof Array && arguments[0] instanceof wi && arguments[1] instanceof $t) {
                        var p = arguments[0],
                            f = arguments[1],
                            d = arguments[2],
                            _ = p.getCoordinate();
                        if (S.EXTERIOR !== this._ptLocator.locate(_, f)) return this._minDistance = 0, d[0] = p, d[1] = new wi(f, _), null
                    }
                }, Ni.prototype.computeMinDistanceLinesPoints = function(t, e, n) {
                    for (var i = 0; i < t.size(); i++)
                        for (var o = t.get(i), r = 0; r < e.size(); r++) {
                            var s = e.get(r);
                            if (this.computeMinDistance(o, s, n), this._minDistance <= this._terminateDistance) return null
                        }
                }, Ni.prototype.computeFacetDistance = function() {
                    var t = new Array(2).fill(null),
                        e = Ci.getLines(this._geom[0]),
                        n = Ci.getLines(this._geom[1]),
                        i = Si.getPoints(this._geom[0]),
                        o = Si.getPoints(this._geom[1]);
                    return this.computeMinDistanceLines(e, n, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(e, o, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(n, i, t), this.updateMinDistance(t, !0), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistancePoints(i, o, t), void this.updateMinDistance(t, !1))))
                }, Ni.prototype.nearestLocations = function() {
                    return this.computeMinDistance(), this._minDistanceLocation
                }, Ni.prototype.updateMinDistance = function(t, e) {
                    if (null === t[0]) return null;
                    e ? (this._minDistanceLocation[0] = t[1], this._minDistanceLocation[1] = t[0]) : (this._minDistanceLocation[0] = t[0], this._minDistanceLocation[1] = t[1])
                }, Ni.prototype.nearestPoints = function() {
                    return this.computeMinDistance(), [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()]
                }, Ni.prototype.computeMinDistance = function() {
                    if (0 === arguments.length) {
                        if (null !== this._minDistanceLocation) return null;
                        if (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance) return null;
                        this.computeFacetDistance()
                    } else if (3 === arguments.length)
                        if (arguments[2] instanceof Array && arguments[0] instanceof Xt && arguments[1] instanceof Kt) {
                            var t = arguments[0],
                                e = arguments[1],
                                n = arguments[2];
                            if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this._minDistance) return null;
                            for (var i = t.getCoordinates(), o = e.getCoordinate(), r = 0; r < i.length - 1; r++) {
                                var s = at.distancePointLine(o, i[r], i[r + 1]);
                                if (s < this._minDistance) {
                                    this._minDistance = s;
                                    var a = new _n(i[r], i[r + 1]).closestPoint(o);
                                    n[0] = new wi(t, r, a), n[1] = new wi(e, 0, o)
                                }
                                if (this._minDistance <= this._terminateDistance) return null
                            }
                        } else if (arguments[2] instanceof Array && arguments[0] instanceof Xt && arguments[1] instanceof Xt) {
                        var h = arguments[0],
                            u = arguments[1],
                            l = arguments[2];
                        if (h.getEnvelopeInternal().distance(u.getEnvelopeInternal()) > this._minDistance) return null;
                        for (var c = h.getCoordinates(), p = u.getCoordinates(), f = 0; f < c.length - 1; f++)
                            for (var d = 0; d < p.length - 1; d++) {
                                var _ = at.distanceLineLine(c[f], c[f + 1], p[d], p[d + 1]);
                                if (_ < this._minDistance) {
                                    this._minDistance = _;
                                    var g = new _n(c[f], c[f + 1]),
                                        m = new _n(p[d], p[d + 1]),
                                        y = g.closestPoints(m);
                                    l[0] = new wi(h, f, y[0]), l[1] = new wi(u, d, y[1])
                                }
                                if (this._minDistance <= this._terminateDistance) return null
                            }
                    }
                }, Ni.prototype.computeMinDistancePoints = function(t, e, n) {
                    for (var i = 0; i < t.size(); i++)
                        for (var o = t.get(i), r = 0; r < e.size(); r++) {
                            var s = e.get(r),
                                a = o.getCoordinate().distance(s.getCoordinate());
                            if (a < this._minDistance && (this._minDistance = a, n[0] = new wi(o, 0, o.getCoordinate()), n[1] = new wi(s, 0, s.getCoordinate())), this._minDistance <= this._terminateDistance) return null
                        }
                }, Ni.prototype.distance = function() {
                    if (null === this._geom[0] || null === this._geom[1]) throw new y("null geometries are not supported");
                    return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance)
                }, Ni.prototype.computeMinDistanceLines = function(t, e, n) {
                    for (var i = 0; i < t.size(); i++)
                        for (var o = t.get(i), r = 0; r < e.size(); r++) {
                            var s = e.get(r);
                            if (this.computeMinDistance(o, s, n), this._minDistance <= this._terminateDistance) return null
                        }
                }, Ni.prototype.interfaces_ = function() {
                    return []
                }, Ni.prototype.getClass = function() {
                    return Ni
                }, Ni.distance = function(t, e) {
                    return new Ni(t, e).distance()
                }, Ni.isWithinDistance = function(t, e, n) {
                    return new Ni(t, e, n).distance() <= n
                }, Ni.nearestPoints = function(t, e) {
                    return new Ni(t, e).nearestPoints()
                };
                var Ti = function() {
                    this._pt = [new C, new C], this._distance = v.NaN, this._isNull = !0
                };
                Ti.prototype.getCoordinates = function() {
                    return this._pt
                }, Ti.prototype.getCoordinate = function(t) {
                    return this._pt[t]
                }, Ti.prototype.setMinimum = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        this.setMinimum(t._pt[0], t._pt[1])
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        if (this._isNull) return this.initialize(e, n), null;
                        var i = e.distance(n);
                        i < this._distance && this.initialize(e, n, i)
                    }
                }, Ti.prototype.initialize = function() {
                    if (0 === arguments.length) this._isNull = !0;
                    else if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        this._pt[0].setCoordinate(t), this._pt[1].setCoordinate(e), this._distance = t.distance(e), this._isNull = !1
                    } else if (3 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1],
                            o = arguments[2];
                        this._pt[0].setCoordinate(n), this._pt[1].setCoordinate(i), this._distance = o, this._isNull = !1
                    }
                }, Ti.prototype.toString = function() {
                    return Q.toLineString(this._pt[0], this._pt[1])
                }, Ti.prototype.getDistance = function() {
                    return this._distance
                }, Ti.prototype.setMaximum = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        this.setMaximum(t._pt[0], t._pt[1])
                    } else if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        if (this._isNull) return this.initialize(e, n), null;
                        var i = e.distance(n);
                        i > this._distance && this.initialize(e, n, i)
                    }
                }, Ti.prototype.interfaces_ = function() {
                    return []
                }, Ti.prototype.getClass = function() {
                    return Ti
                };
                var Oi = function() {};
                Oi.prototype.interfaces_ = function() {
                    return []
                }, Oi.prototype.getClass = function() {
                    return Oi
                }, Oi.computeDistance = function() {
                    if (arguments[2] instanceof Ti && arguments[0] instanceof Xt && arguments[1] instanceof C)
                        for (var t = arguments[0], e = arguments[1], n = arguments[2], i = new _n, o = t.getCoordinates(), r = 0; r < o.length - 1; r++) {
                            i.setCoordinates(o[r], o[r + 1]);
                            var s = i.closestPoint(e);
                            n.setMinimum(s, e)
                        } else if (arguments[2] instanceof Ti && arguments[0] instanceof $t && arguments[1] instanceof C) {
                            var a = arguments[0],
                                h = arguments[1],
                                u = arguments[2];
                            Oi.computeDistance(a.getExteriorRing(), h, u);
                            for (var l = 0; l < a.getNumInteriorRing(); l++) Oi.computeDistance(a.getInteriorRingN(l), h, u)
                        } else if (arguments[2] instanceof Ti && arguments[0] instanceof lt && arguments[1] instanceof C) {
                        var c = arguments[0],
                            p = arguments[1],
                            f = arguments[2];
                        if (c instanceof Xt) Oi.computeDistance(c, p, f);
                        else if (c instanceof $t) Oi.computeDistance(c, p, f);
                        else if (c instanceof jt)
                            for (var d = c, _ = 0; _ < d.getNumGeometries(); _++) {
                                var g = d.getGeometryN(_);
                                Oi.computeDistance(g, p, f)
                            } else f.setMinimum(c.getCoordinate(), p)
                    } else if (arguments[2] instanceof Ti && arguments[0] instanceof _n && arguments[1] instanceof C) {
                        var m = arguments[0],
                            y = arguments[1],
                            v = arguments[2],
                            L = m.closestPoint(y);
                        v.setMinimum(L, y)
                    }
                };
                var Ai = function() {
                        this._g0 = null, this._g1 = null, this._ptDist = new Ti, this._densifyFrac = 0;
                        var t = arguments[0],
                            e = arguments[1];
                        this._g0 = t, this._g1 = e
                    },
                    Ri = {
                        MaxPointDistanceFilter: {
                            configurable: !0
                        },
                        MaxDensifiedByFractionDistanceFilter: {
                            configurable: !0
                        }
                    };
                Ai.prototype.getCoordinates = function() {
                    return this._ptDist.getCoordinates()
                }, Ai.prototype.setDensifyFraction = function(t) {
                    if (t > 1 || t <= 0) throw new y("Fraction is not in range (0.0 - 1.0]");
                    this._densifyFrac = t
                }, Ai.prototype.compute = function(t, e) {
                    this.computeOrientedDistance(t, e, this._ptDist), this.computeOrientedDistance(e, t, this._ptDist)
                }, Ai.prototype.distance = function() {
                    return this.compute(this._g0, this._g1), this._ptDist.getDistance()
                }, Ai.prototype.computeOrientedDistance = function(t, e, n) {
                    var i = new Di(e);
                    if (t.apply(i), n.setMaximum(i.getMaxPointDistance()), this._densifyFrac > 0) {
                        var o = new ki(e, this._densifyFrac);
                        t.apply(o), n.setMaximum(o.getMaxPointDistance())
                    }
                }, Ai.prototype.orientedDistance = function() {
                    return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance()
                }, Ai.prototype.interfaces_ = function() {
                    return []
                }, Ai.prototype.getClass = function() {
                    return Ai
                }, Ai.distance = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        return new Ai(t, e).distance()
                    }
                    if (3 === arguments.length) {
                        var n = arguments[0],
                            i = arguments[1],
                            o = arguments[2],
                            r = new Ai(n, i);
                        return r.setDensifyFraction(o), r.distance()
                    }
                }, Ri.MaxPointDistanceFilter.get = function() {
                    return Di
                }, Ri.MaxDensifiedByFractionDistanceFilter.get = function() {
                    return ki
                }, Object.defineProperties(Ai, Ri);
                var Di = function() {
                    this._maxPtDist = new Ti, this._minPtDist = new Ti, this._euclideanDist = new Oi, this._geom = null;
                    var t = arguments[0];
                    this._geom = t
                };
                Di.prototype.filter = function(t) {
                    this._minPtDist.initialize(), Oi.computeDistance(this._geom, t, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist)
                }, Di.prototype.getMaxPointDistance = function() {
                    return this._maxPtDist
                }, Di.prototype.interfaces_ = function() {
                    return [ft]
                }, Di.prototype.getClass = function() {
                    return Di
                };
                var ki = function() {
                    this._maxPtDist = new Ti, this._minPtDist = new Ti, this._geom = null, this._numSubSegs = 0;
                    var t = arguments[0],
                        e = arguments[1];
                    this._geom = t, this._numSubSegs = Math.trunc(Math.round(1 / e))
                };
                ki.prototype.filter = function(t, e) {
                    if (0 === e) return null;
                    for (var n = t.getCoordinate(e - 1), i = t.getCoordinate(e), o = (i.x - n.x) / this._numSubSegs, r = (i.y - n.y) / this._numSubSegs, s = 0; s < this._numSubSegs; s++) {
                        var a = n.x + s * o,
                            h = n.y + s * r,
                            u = new C(a, h);
                        this._minPtDist.initialize(), Oi.computeDistance(this._geom, u, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist)
                    }
                }, ki.prototype.isDone = function() {
                    return !1
                }, ki.prototype.isGeometryChanged = function() {
                    return !1
                }, ki.prototype.getMaxPointDistance = function() {
                    return this._maxPtDist
                }, ki.prototype.interfaces_ = function() {
                    return [Ut]
                }, ki.prototype.getClass = function() {
                    return ki
                };
                var Fi = function(t, e, n) {
                        this._minValidDistance = null, this._maxValidDistance = null, this._minDistanceFound = null, this._maxDistanceFound = null, this._isValid = !0, this._errMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t || null, this._bufDistance = e || null, this._result = n || null
                    },
                    zi = {
                        VERBOSE: {
                            configurable: !0
                        },
                        MAX_DISTANCE_DIFF_FRAC: {
                            configurable: !0
                        }
                    };
                Fi.prototype.checkMaximumDistance = function(t, e, n) {
                    var i = new Ai(e, t);
                    if (i.setDensifyFraction(.25), this._maxDistanceFound = i.orientedDistance(), this._maxDistanceFound > n) {
                        this._isValid = !1;
                        var o = i.getCoordinates();
                        this._errorLocation = o[1], this._errorIndicator = t.getFactory().createLineString(o), this._errMsg = "Distance between buffer curve and input is too large (" + this._maxDistanceFound + " at " + Q.toLineString(o[0], o[1]) + ")"
                    }
                }, Fi.prototype.isValid = function() {
                    var t = Math.abs(this._bufDistance),
                        e = Fi.MAX_DISTANCE_DIFF_FRAC * t;
                    return this._minValidDistance = t - e, this._maxValidDistance = t + e, !(!this._input.isEmpty() && !this._result.isEmpty()) || (this._bufDistance > 0 ? this.checkPositiveValid() : this.checkNegativeValid(), Fi.VERBOSE && Z.out.println("Min Dist= " + this._minDistanceFound + "  err= " + (1 - this._minDistanceFound / this._bufDistance) + "  Max Dist= " + this._maxDistanceFound + "  err= " + (this._maxDistanceFound / this._bufDistance - 1)), this._isValid)
                }, Fi.prototype.checkNegativeValid = function() {
                    if (!(this._input instanceof $t || this._input instanceof ne || this._input instanceof jt)) return null;
                    var t = this.getPolygonLines(this._input);
                    if (this.checkMinimumDistance(t, this._result, this._minValidDistance), !this._isValid) return null;
                    this.checkMaximumDistance(t, this._result, this._maxValidDistance)
                }, Fi.prototype.getErrorIndicator = function() {
                    return this._errorIndicator
                }, Fi.prototype.checkMinimumDistance = function(t, e, n) {
                    var i = new Ni(t, e, n);
                    if (this._minDistanceFound = i.distance(), this._minDistanceFound < n) {
                        this._isValid = !1;
                        var o = i.nearestPoints();
                        this._errorLocation = i.nearestPoints()[1], this._errorIndicator = t.getFactory().createLineString(o), this._errMsg = "Distance between buffer curve and input is too small (" + this._minDistanceFound + " at " + Q.toLineString(o[0], o[1]) + " )"
                    }
                }, Fi.prototype.checkPositiveValid = function() {
                    var t = this._result.getBoundary();
                    if (this.checkMinimumDistance(this._input, t, this._minValidDistance), !this._isValid) return null;
                    this.checkMaximumDistance(this._input, t, this._maxValidDistance)
                }, Fi.prototype.getErrorLocation = function() {
                    return this._errorLocation
                }, Fi.prototype.getPolygonLines = function(t) {
                    for (var e = new Et, n = new Ci(e), i = Ei.getPolygons(t).iterator(); i.hasNext();) i.next().apply(n);
                    return t.getFactory().buildGeometry(e)
                }, Fi.prototype.getErrorMessage = function() {
                    return this._errMsg
                }, Fi.prototype.interfaces_ = function() {
                    return []
                }, Fi.prototype.getClass = function() {
                    return Fi
                }, zi.VERBOSE.get = function() {
                    return !1
                }, zi.MAX_DISTANCE_DIFF_FRAC.get = function() {
                    return .012
                }, Object.defineProperties(Fi, zi);
                var Bi = function(t, e, n) {
                        this._isValid = !0, this._errorMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t || null, this._distance = e || null, this._result = n || null
                    },
                    Gi = {
                        VERBOSE: {
                            configurable: !0
                        },
                        MAX_ENV_DIFF_FRAC: {
                            configurable: !0
                        }
                    };
                Bi.prototype.isValid = function() {
                    return this.checkPolygonal(), this._isValid ? (this.checkExpectedEmpty(), this._isValid ? (this.checkEnvelope(), this._isValid ? (this.checkArea(), this._isValid ? (this.checkDistance(), this._isValid) : this._isValid) : this._isValid) : this._isValid) : this._isValid
                }, Bi.prototype.checkEnvelope = function() {
                    if (this._distance < 0) return null;
                    var t = this._distance * Bi.MAX_ENV_DIFF_FRAC;
                    0 === t && (t = .001);
                    var e = new H(this._input.getEnvelopeInternal());
                    e.expandBy(this._distance);
                    var n = new H(this._result.getEnvelopeInternal());
                    n.expandBy(t), n.contains(e) || (this._isValid = !1, this._errorMsg = "Buffer envelope is incorrect", this._errorIndicator = this._input.getFactory().toGeometry(n)), this.report("Envelope")
                }, Bi.prototype.checkDistance = function() {
                    var t = new Fi(this._input, this._distance, this._result);
                    t.isValid() || (this._isValid = !1, this._errorMsg = t.getErrorMessage(), this._errorLocation = t.getErrorLocation(), this._errorIndicator = t.getErrorIndicator()), this.report("Distance")
                }, Bi.prototype.checkArea = function() {
                    var t = this._input.getArea(),
                        e = this._result.getArea();
                    this._distance > 0 && t > e && (this._isValid = !1, this._errorMsg = "Area of positive buffer is smaller than input", this._errorIndicator = this._result), this._distance < 0 && t < e && (this._isValid = !1, this._errorMsg = "Area of negative buffer is larger than input", this._errorIndicator = this._result), this.report("Area")
                }, Bi.prototype.checkPolygonal = function() {
                    this._result instanceof $t || this._result instanceof ne || (this._isValid = !1), this._errorMsg = "Result is not polygonal", this._errorIndicator = this._result, this.report("Polygonal")
                }, Bi.prototype.getErrorIndicator = function() {
                    return this._errorIndicator
                }, Bi.prototype.getErrorLocation = function() {
                    return this._errorLocation
                }, Bi.prototype.checkExpectedEmpty = function() {
                    return this._input.getDimension() >= 2 ? null : this._distance > 0 ? null : (this._result.isEmpty() || (this._isValid = !1, this._errorMsg = "Result is non-empty", this._errorIndicator = this._result), void this.report("ExpectedEmpty"))
                }, Bi.prototype.report = function(t) {
                    if (!Bi.VERBOSE) return null;
                    Z.out.println("Check " + t + ": " + (this._isValid ? "passed" : "FAILED"))
                }, Bi.prototype.getErrorMessage = function() {
                    return this._errorMsg
                }, Bi.prototype.interfaces_ = function() {
                    return []
                }, Bi.prototype.getClass = function() {
                    return Bi
                }, Bi.isValidMsg = function(t, e, n) {
                    var i = new Bi(t, e, n);
                    return i.isValid() ? null : i.getErrorMessage()
                }, Bi.isValid = function(t, e, n) {
                    return !!new Bi(t, e, n).isValid()
                }, Gi.VERBOSE.get = function() {
                    return !1
                }, Gi.MAX_ENV_DIFF_FRAC.get = function() {
                    return .012
                }, Object.defineProperties(Bi, Gi);
                var Ui = function() {
                    this._pts = null, this._data = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this._pts = t, this._data = e
                };
                Ui.prototype.getCoordinates = function() {
                    return this._pts
                }, Ui.prototype.size = function() {
                    return this._pts.length
                }, Ui.prototype.getCoordinate = function(t) {
                    return this._pts[t]
                }, Ui.prototype.isClosed = function() {
                    return this._pts[0].equals(this._pts[this._pts.length - 1])
                }, Ui.prototype.getSegmentOctant = function(t) {
                    return t === this._pts.length - 1 ? -1 : cn.octant(this.getCoordinate(t), this.getCoordinate(t + 1))
                }, Ui.prototype.setData = function(t) {
                    this._data = t
                }, Ui.prototype.getData = function() {
                    return this._data
                }, Ui.prototype.toString = function() {
                    return Q.toLineString(new he(this._pts))
                }, Ui.prototype.interfaces_ = function() {
                    return [pn]
                }, Ui.prototype.getClass = function() {
                    return Ui
                };
                var ji = function() {
                    this._findAllIntersections = !1, this._isCheckEndSegmentsOnly = !1, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new Et, this._intersectionCount = 0, this._keepIntersections = !0;
                    var t = arguments[0];
                    this._li = t, this._interiorIntersection = null
                };
                ji.prototype.getInteriorIntersection = function() {
                    return this._interiorIntersection
                }, ji.prototype.setCheckEndSegmentsOnly = function(t) {
                    this._isCheckEndSegmentsOnly = t
                }, ji.prototype.getIntersectionSegments = function() {
                    return this._intSegments
                }, ji.prototype.count = function() {
                    return this._intersectionCount
                }, ji.prototype.getIntersections = function() {
                    return this._intersections
                }, ji.prototype.setFindAllIntersections = function(t) {
                    this._findAllIntersections = t
                }, ji.prototype.setKeepIntersections = function(t) {
                    this._keepIntersections = t
                }, ji.prototype.processIntersections = function(t, e, n, i) {
                    if (!this._findAllIntersections && this.hasIntersection()) return null;
                    if (t === n && e === i) return null;
                    if (this._isCheckEndSegmentsOnly && !this.isEndSegment(t, e) && !this.isEndSegment(n, i)) return null;
                    var o = t.getCoordinates()[e],
                        r = t.getCoordinates()[e + 1],
                        s = n.getCoordinates()[i],
                        a = n.getCoordinates()[i + 1];
                    this._li.computeIntersection(o, r, s, a), this._li.hasIntersection() && this._li.isInteriorIntersection() && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = o, this._intSegments[1] = r, this._intSegments[2] = s, this._intSegments[3] = a, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++)
                }, ji.prototype.isEndSegment = function(t, e) {
                    return 0 === e || e >= t.size() - 2
                }, ji.prototype.hasIntersection = function() {
                    return null !== this._interiorIntersection
                }, ji.prototype.isDone = function() {
                    return !this._findAllIntersections && null !== this._interiorIntersection
                }, ji.prototype.interfaces_ = function() {
                    return [Wn]
                }, ji.prototype.getClass = function() {
                    return ji
                }, ji.createAllIntersectionsFinder = function(t) {
                    var e = new ji(t);
                    return e.setFindAllIntersections(!0), e
                }, ji.createAnyIntersectionFinder = function(t) {
                    return new ji(t)
                }, ji.createIntersectionCounter = function(t) {
                    var e = new ji(t);
                    return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e
                };
                var qi = function() {
                    this._li = new ot, this._segStrings = null, this._findAllIntersections = !1, this._segInt = null, this._isValid = !0;
                    var t = arguments[0];
                    this._segStrings = t
                };
                qi.prototype.execute = function() {
                    if (null !== this._segInt) return null;
                    this.checkInteriorIntersections()
                }, qi.prototype.getIntersections = function() {
                    return this._segInt.getIntersections()
                }, qi.prototype.isValid = function() {
                    return this.execute(), this._isValid
                }, qi.prototype.setFindAllIntersections = function(t) {
                    this._findAllIntersections = t
                }, qi.prototype.checkInteriorIntersections = function() {
                    this._isValid = !0, this._segInt = new ji(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections);
                    var t = new bn;
                    if (t.setSegmentIntersector(this._segInt), t.computeNodes(this._segStrings), this._segInt.hasIntersection()) return this._isValid = !1, null
                }, qi.prototype.checkValid = function() {
                    if (this.execute(), !this._isValid) throw new Se(this.getErrorMessage(), this._segInt.getInteriorIntersection())
                }, qi.prototype.getErrorMessage = function() {
                    if (this._isValid) return "no intersections found";
                    var t = this._segInt.getIntersectionSegments();
                    return "found non-noded intersection between " + Q.toLineString(t[0], t[1]) + " and " + Q.toLineString(t[2], t[3])
                }, qi.prototype.interfaces_ = function() {
                    return []
                }, qi.prototype.getClass = function() {
                    return qi
                }, qi.computeIntersections = function(t) {
                    var e = new qi(t);
                    return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections()
                };
                var Zi = function t() {
                    this._nv = null;
                    var e = arguments[0];
                    this._nv = new qi(t.toSegmentStrings(e))
                };
                Zi.prototype.checkValid = function() {
                    this._nv.checkValid()
                }, Zi.prototype.interfaces_ = function() {
                    return []
                }, Zi.prototype.getClass = function() {
                    return Zi
                }, Zi.toSegmentStrings = function(t) {
                    for (var e = new Et, n = t.iterator(); n.hasNext();) {
                        var i = n.next();
                        e.add(new Ui(i.getCoordinates(), i))
                    }
                    return e
                }, Zi.checkValid = function(t) {
                    new Zi(t).checkValid()
                };
                var Vi = function(t) {
                    this._mapOp = t
                };
                Vi.prototype.map = function(t) {
                    for (var e = new Et, n = 0; n < t.getNumGeometries(); n++) {
                        var i = this._mapOp.map(t.getGeometryN(n));
                        i.isEmpty() || e.add(i)
                    }
                    return t.getFactory().createGeometryCollection(me.toGeometryArray(e))
                }, Vi.prototype.interfaces_ = function() {
                    return []
                }, Vi.prototype.getClass = function() {
                    return Vi
                }, Vi.map = function(t, e) {
                    return new Vi(e).map(t)
                };
                var Hi = function() {
                    this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new Et, this._resultLineList = new Et;
                    var t = arguments[0],
                        e = arguments[1],
                        n = arguments[2];
                    this._op = t, this._geometryFactory = e, this._ptLocator = n
                };
                Hi.prototype.collectLines = function(t) {
                    for (var e = this._op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {
                        var n = e.next();
                        this.collectLineEdge(n, t, this._lineEdgesList), this.collectBoundaryTouchEdge(n, t, this._lineEdgesList)
                    }
                }, Hi.prototype.labelIsolatedLine = function(t, e) {
                    var n = this._ptLocator.locate(t.getCoordinate(), this._op.getArgGeometry(e));
                    t.getLabel().setLocation(e, n)
                }, Hi.prototype.build = function(t) {
                    return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this._resultLineList
                }, Hi.prototype.collectLineEdge = function(t, e, n) {
                    var i = t.getLabel(),
                        o = t.getEdge();
                    t.isLineEdge() && (t.isVisited() || !Mo.isResultOfOp(i, e) || o.isCovered() || (n.add(o), t.setVisitedEdge(!0)))
                }, Hi.prototype.findCoveredLineEdges = function() {
                    for (var t = this._op.getGraph().getNodes().iterator(); t.hasNext();) t.next().getEdges().findCoveredLineEdges();
                    for (var e = this._op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {
                        var n = e.next(),
                            i = n.getEdge();
                        if (n.isLineEdge() && !i.isCoveredSet()) {
                            var o = this._op.isCoveredByA(n.getCoordinate());
                            i.setCovered(o)
                        }
                    }
                }, Hi.prototype.labelIsolatedLines = function(t) {
                    for (var e = t.iterator(); e.hasNext();) {
                        var n = e.next(),
                            i = n.getLabel();
                        n.isIsolated() && (i.isNull(0) ? this.labelIsolatedLine(n, 0) : this.labelIsolatedLine(n, 1))
                    }
                }, Hi.prototype.buildLines = function(t) {
                    for (var e = this._lineEdgesList.iterator(); e.hasNext();) {
                        var n = e.next(),
                            i = this._geometryFactory.createLineString(n.getCoordinates());
                        this._resultLineList.add(i), n.setInResult(!0)
                    }
                }, Hi.prototype.collectBoundaryTouchEdge = function(t, e, n) {
                    var i = t.getLabel();
                    return t.isLineEdge() ? null : t.isVisited() ? null : t.isInteriorAreaEdge() ? null : t.getEdge().isInResult() ? null : (et.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()), void(Mo.isResultOfOp(i, e) && e === Mo.INTERSECTION && (n.add(t.getEdge()), t.setVisitedEdge(!0))))
                }, Hi.prototype.interfaces_ = function() {
                    return []
                }, Hi.prototype.getClass = function() {
                    return Hi
                };
                var Yi = function() {
                    this._op = null, this._geometryFactory = null, this._resultPointList = new Et;
                    var t = arguments[0],
                        e = arguments[1];
                    this._op = t, this._geometryFactory = e
                };
                Yi.prototype.filterCoveredNodeToPoint = function(t) {
                    var e = t.getCoordinate();
                    if (!this._op.isCoveredByLA(e)) {
                        var n = this._geometryFactory.createPoint(e);
                        this._resultPointList.add(n)
                    }
                }, Yi.prototype.extractNonCoveredResultNodes = function(t) {
                    for (var e = this._op.getGraph().getNodes().iterator(); e.hasNext();) {
                        var n = e.next();
                        if (!(n.isInResult() || n.isIncidentEdgeInResult() || 0 !== n.getEdges().getDegree() && t !== Mo.INTERSECTION)) {
                            var i = n.getLabel();
                            Mo.isResultOfOp(i, t) && this.filterCoveredNodeToPoint(n)
                        }
                    }
                }, Yi.prototype.build = function(t) {
                    return this.extractNonCoveredResultNodes(t), this._resultPointList
                }, Yi.prototype.interfaces_ = function() {
                    return []
                }, Yi.prototype.getClass = function() {
                    return Yi
                };
                var Wi = function() {
                    this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = !0, this._preserveGeometryCollectionType = !0, this._preserveCollections = !1, this._preserveType = !1
                };
                Wi.prototype.transformPoint = function(t, e) {
                    return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t))
                }, Wi.prototype.transformPolygon = function(t, e) {
                    var n = !0,
                        i = this.transformLinearRing(t.getExteriorRing(), t);
                    null !== i && i instanceof ee && !i.isEmpty() || (n = !1);
                    for (var o = new Et, r = 0; r < t.getNumInteriorRing(); r++) {
                        var s = this.transformLinearRing(t.getInteriorRingN(r), t);
                        null === s || s.isEmpty() || (s instanceof ee || (n = !1), o.add(s))
                    }
                    if (n) return this._factory.createPolygon(i, o.toArray([]));
                    var a = new Et;
                    return null !== i && a.add(i), a.addAll(o), this._factory.buildGeometry(a)
                }, Wi.prototype.createCoordinateSequence = function(t) {
                    return this._factory.getCoordinateSequenceFactory().create(t)
                }, Wi.prototype.getInputGeometry = function() {
                    return this._inputGeom
                }, Wi.prototype.transformMultiLineString = function(t, e) {
                    for (var n = new Et, i = 0; i < t.getNumGeometries(); i++) {
                        var o = this.transformLineString(t.getGeometryN(i), t);
                        null !== o && (o.isEmpty() || n.add(o))
                    }
                    return this._factory.buildGeometry(n)
                }, Wi.prototype.transformCoordinates = function(t, e) {
                    return this.copy(t)
                }, Wi.prototype.transformLineString = function(t, e) {
                    return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t))
                }, Wi.prototype.transformMultiPoint = function(t, e) {
                    for (var n = new Et, i = 0; i < t.getNumGeometries(); i++) {
                        var o = this.transformPoint(t.getGeometryN(i), t);
                        null !== o && (o.isEmpty() || n.add(o))
                    }
                    return this._factory.buildGeometry(n)
                }, Wi.prototype.transformMultiPolygon = function(t, e) {
                    for (var n = new Et, i = 0; i < t.getNumGeometries(); i++) {
                        var o = this.transformPolygon(t.getGeometryN(i), t);
                        null !== o && (o.isEmpty() || n.add(o))
                    }
                    return this._factory.buildGeometry(n)
                }, Wi.prototype.copy = function(t) {
                    return t.copy()
                }, Wi.prototype.transformGeometryCollection = function(t, e) {
                    for (var n = new Et, i = 0; i < t.getNumGeometries(); i++) {
                        var o = this.transform(t.getGeometryN(i));
                        null !== o && (this._pruneEmptyGeometry && o.isEmpty() || n.add(o))
                    }
                    return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(me.toGeometryArray(n)) : this._factory.buildGeometry(n)
                }, Wi.prototype.transform = function(t) {
                    if (this._inputGeom = t, this._factory = t.getFactory(), t instanceof Kt) return this.transformPoint(t, null);
                    if (t instanceof te) return this.transformMultiPoint(t, null);
                    if (t instanceof ee) return this.transformLinearRing(t, null);
                    if (t instanceof Xt) return this.transformLineString(t, null);
                    if (t instanceof qt) return this.transformMultiLineString(t, null);
                    if (t instanceof $t) return this.transformPolygon(t, null);
                    if (t instanceof ne) return this.transformMultiPolygon(t, null);
                    if (t instanceof jt) return this.transformGeometryCollection(t, null);
                    throw new y("Unknown Geometry subtype: " + t.getClass().getName())
                }, Wi.prototype.transformLinearRing = function(t, e) {
                    var n = this.transformCoordinates(t.getCoordinateSequence(), t);
                    if (null === n) return this._factory.createLinearRing(null);
                    var i = n.size();
                    return i > 0 && i < 4 && !this._preserveType ? this._factory.createLineString(n) : this._factory.createLinearRing(n)
                }, Wi.prototype.interfaces_ = function() {
                    return []
                }, Wi.prototype.getClass = function() {
                    return Wi
                };
                var Xi = function t() {
                    if (this._snapTolerance = 0, this._srcPts = null, this._seg = new _n, this._allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof Xt && "number" == typeof arguments[1]) {
                        var e = arguments[0],
                            n = arguments[1];
                        t.call(this, e.getCoordinates(), n)
                    } else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) {
                        var i = arguments[0],
                            o = arguments[1];
                        this._srcPts = i, this._isClosed = t.isClosed(i), this._snapTolerance = o
                    }
                };
                Xi.prototype.snapVertices = function(t, e) {
                    for (var n = this._isClosed ? t.size() - 1 : t.size(), i = 0; i < n; i++) {
                        var o = t.get(i),
                            r = this.findSnapForVertex(o, e);
                        null !== r && (t.set(i, new C(r)), 0 === i && this._isClosed && t.set(t.size() - 1, new C(r)))
                    }
                }, Xi.prototype.findSnapForVertex = function(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        if (t.equals2D(e[n])) return null;
                        if (t.distance(e[n]) < this._snapTolerance) return e[n]
                    }
                    return null
                }, Xi.prototype.snapTo = function(t) {
                    var e = new It(this._srcPts);
                    return this.snapVertices(e, t), this.snapSegments(e, t), e.toCoordinateArray()
                }, Xi.prototype.snapSegments = function(t, e) {
                    if (0 === e.length) return null;
                    var n = e.length;
                    e[0].equals2D(e[e.length - 1]) && (n = e.length - 1);
                    for (var i = 0; i < n; i++) {
                        var o = e[i],
                            r = this.findSegmentIndexToSnap(o, t);
                        r >= 0 && t.add(r + 1, new C(o), !1)
                    }
                }, Xi.prototype.findSegmentIndexToSnap = function(t, e) {
                    for (var n = v.MAX_VALUE, i = -1, o = 0; o < e.size() - 1; o++) {
                        if (this._seg.p0 = e.get(o), this._seg.p1 = e.get(o + 1), this._seg.p0.equals2D(t) || this._seg.p1.equals2D(t)) {
                            if (this._allowSnappingToSourceVertices) continue;
                            return -1
                        }
                        var r = this._seg.distance(t);
                        r < this._snapTolerance && r < n && (n = r, i = o)
                    }
                    return i
                }, Xi.prototype.setAllowSnappingToSourceVertices = function(t) {
                    this._allowSnappingToSourceVertices = t
                }, Xi.prototype.interfaces_ = function() {
                    return []
                }, Xi.prototype.getClass = function() {
                    return Xi
                }, Xi.isClosed = function(t) {
                    return !(t.length <= 1) && t[0].equals2D(t[t.length - 1])
                };
                var Ji = function(t) {
                        this._srcGeom = t || null
                    },
                    Ki = {
                        SNAP_PRECISION_FACTOR: {
                            configurable: !0
                        }
                    };
                Ji.prototype.snapTo = function(t, e) {
                    var n = this.extractTargetCoordinates(t);
                    return new Qi(e, n).transform(this._srcGeom)
                }, Ji.prototype.snapToSelf = function(t, e) {
                    var n = this.extractTargetCoordinates(this._srcGeom),
                        i = new Qi(t, n, !0).transform(this._srcGeom),
                        o = i;
                    return e && N(o, Qt) && (o = i.buffer(0)), o
                }, Ji.prototype.computeSnapTolerance = function(t) {
                    return this.computeMinimumSegmentLength(t) / 10
                }, Ji.prototype.extractTargetCoordinates = function(t) {
                    for (var e = new f, n = t.getCoordinates(), i = 0; i < n.length; i++) e.add(n[i]);
                    return e.toArray(new Array(0).fill(null))
                }, Ji.prototype.computeMinimumSegmentLength = function(t) {
                    for (var e = v.MAX_VALUE, n = 0; n < t.length - 1; n++) {
                        var i = t[n].distance(t[n + 1]);
                        i < e && (e = i)
                    }
                    return e
                }, Ji.prototype.interfaces_ = function() {
                    return []
                }, Ji.prototype.getClass = function() {
                    return Ji
                }, Ji.snap = function(t, e, n) {
                    var i = new Array(2).fill(null),
                        o = new Ji(t);
                    i[0] = o.snapTo(e, n);
                    var r = new Ji(e);
                    return i[1] = r.snapTo(i[0], n), i
                }, Ji.computeOverlaySnapTolerance = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0],
                            e = Ji.computeSizeBasedSnapTolerance(t),
                            n = t.getPrecisionModel();
                        if (n.getType() === fe.FIXED) {
                            var i = 1 / n.getScale() * 2 / 1.415;
                            i > e && (e = i)
                        }
                        return e
                    }
                    if (2 === arguments.length) {
                        var o = arguments[0],
                            r = arguments[1];
                        return Math.min(Ji.computeOverlaySnapTolerance(o), Ji.computeOverlaySnapTolerance(r))
                    }
                }, Ji.computeSizeBasedSnapTolerance = function(t) {
                    var e = t.getEnvelopeInternal();
                    return Math.min(e.getHeight(), e.getWidth()) * Ji.SNAP_PRECISION_FACTOR
                }, Ji.snapToSelf = function(t, e, n) {
                    return new Ji(t).snapToSelf(e, n)
                }, Ki.SNAP_PRECISION_FACTOR.get = function() {
                    return 1e-9
                }, Object.defineProperties(Ji, Ki);
                var Qi = function(t) {
                        function e(e, n, i) {
                            t.call(this), this._snapTolerance = e || null, this._snapPts = n || null, this._isSelfSnap = void 0 !== i && i
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.snapLine = function(t, e) {
                            var n = new Xi(t, this._snapTolerance);
                            return n.setAllowSnappingToSourceVertices(this._isSelfSnap), n.snapTo(e)
                        }, e.prototype.transformCoordinates = function(t, e) {
                            var n = t.toCoordinateArray(),
                                i = this.snapLine(n, this._snapPts);
                            return this._factory.getCoordinateSequenceFactory().create(i)
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e
                    }(Wi),
                    $i = function() {
                        this._isFirst = !0, this._commonMantissaBitsCount = 53, this._commonBits = 0, this._commonSignExp = null
                    };
                $i.prototype.getCommon = function() {
                    return v.longBitsToDouble(this._commonBits)
                }, $i.prototype.add = function(t) {
                    var e = v.doubleToLongBits(t);
                    return this._isFirst ? (this._commonBits = e, this._commonSignExp = $i.signExpBits(this._commonBits), this._isFirst = !1, null) : $i.signExpBits(e) !== this._commonSignExp ? (this._commonBits = 0, null) : (this._commonMantissaBitsCount = $i.numCommonMostSigMantissaBits(this._commonBits, e), void(this._commonBits = $i.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount))))
                }, $i.prototype.toString = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0],
                            e = v.longBitsToDouble(t),
                            n = "0000000000000000000000000000000000000000000000000000000000000000" + v.toBinaryString(t),
                            i = n.substring(n.length - 64);
                        return i.substring(0, 1) + "  " + i.substring(1, 12) + "(exp) " + i.substring(12) + " [ " + e + " ]"
                    }
                }, $i.prototype.interfaces_ = function() {
                    return []
                }, $i.prototype.getClass = function() {
                    return $i
                }, $i.getBit = function(t, e) {
                    return 0 != (t & 1 << e) ? 1 : 0
                }, $i.signExpBits = function(t) {
                    return t >> 52
                }, $i.zeroLowerBits = function(t, e) {
                    return t & ~((1 << e) - 1)
                }, $i.numCommonMostSigMantissaBits = function(t, e) {
                    for (var n = 0, i = 52; i >= 0; i--) {
                        if ($i.getBit(t, i) !== $i.getBit(e, i)) return n;
                        n++
                    }
                    return 52
                };
                var to = function() {
                        this._commonCoord = null, this._ccFilter = new no
                    },
                    eo = {
                        CommonCoordinateFilter: {
                            configurable: !0
                        },
                        Translater: {
                            configurable: !0
                        }
                    };
                to.prototype.addCommonBits = function(t) {
                    var e = new io(this._commonCoord);
                    t.apply(e), t.geometryChanged()
                }, to.prototype.removeCommonBits = function(t) {
                    if (0 === this._commonCoord.x && 0 === this._commonCoord.y) return t;
                    var e = new C(this._commonCoord);
                    e.x = -e.x, e.y = -e.y;
                    var n = new io(e);
                    return t.apply(n), t.geometryChanged(), t
                }, to.prototype.getCommonCoordinate = function() {
                    return this._commonCoord
                }, to.prototype.add = function(t) {
                    t.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate()
                }, to.prototype.interfaces_ = function() {
                    return []
                }, to.prototype.getClass = function() {
                    return to
                }, eo.CommonCoordinateFilter.get = function() {
                    return no
                }, eo.Translater.get = function() {
                    return io
                }, Object.defineProperties(to, eo);
                var no = function() {
                    this._commonBitsX = new $i, this._commonBitsY = new $i
                };
                no.prototype.filter = function(t) {
                    this._commonBitsX.add(t.x), this._commonBitsY.add(t.y)
                }, no.prototype.getCommonCoordinate = function() {
                    return new C(this._commonBitsX.getCommon(), this._commonBitsY.getCommon())
                }, no.prototype.interfaces_ = function() {
                    return [ft]
                }, no.prototype.getClass = function() {
                    return no
                };
                var io = function() {
                    this.trans = null;
                    var t = arguments[0];
                    this.trans = t
                };
                io.prototype.filter = function(t, e) {
                    var n = t.getOrdinate(e, 0) + this.trans.x,
                        i = t.getOrdinate(e, 1) + this.trans.y;
                    t.setOrdinate(e, 0, n), t.setOrdinate(e, 1, i)
                }, io.prototype.isDone = function() {
                    return !1
                }, io.prototype.isGeometryChanged = function() {
                    return !0
                }, io.prototype.interfaces_ = function() {
                    return [Ut]
                }, io.prototype.getClass = function() {
                    return io
                };
                var oo = function(t, e) {
                    this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null, this._geom[0] = t, this._geom[1] = e, this.computeSnapTolerance()
                };
                oo.prototype.selfSnap = function(t) {
                    return new Ji(t).snapTo(t, this._snapTolerance)
                }, oo.prototype.removeCommonBits = function(t) {
                    this._cbr = new to, this._cbr.add(t[0]), this._cbr.add(t[1]);
                    var e = new Array(2).fill(null);
                    return e[0] = this._cbr.removeCommonBits(t[0].copy()), e[1] = this._cbr.removeCommonBits(t[1].copy()), e
                }, oo.prototype.prepareResult = function(t) {
                    return this._cbr.addCommonBits(t), t
                }, oo.prototype.getResultGeometry = function(t) {
                    var e = this.snap(this._geom),
                        n = Mo.overlayOp(e[0], e[1], t);
                    return this.prepareResult(n)
                }, oo.prototype.checkValid = function(t) {
                    t.isValid() || Z.out.println("Snapped geometry is invalid")
                }, oo.prototype.computeSnapTolerance = function() {
                    this._snapTolerance = Ji.computeOverlaySnapTolerance(this._geom[0], this._geom[1])
                }, oo.prototype.snap = function(t) {
                    var e = this.removeCommonBits(t);
                    return Ji.snap(e[0], e[1], this._snapTolerance)
                }, oo.prototype.interfaces_ = function() {
                    return []
                }, oo.prototype.getClass = function() {
                    return oo
                }, oo.overlayOp = function(t, e, n) {
                    return new oo(t, e).getResultGeometry(n)
                }, oo.union = function(t, e) {
                    return oo.overlayOp(t, e, Mo.UNION)
                }, oo.intersection = function(t, e) {
                    return oo.overlayOp(t, e, Mo.INTERSECTION)
                }, oo.symDifference = function(t, e) {
                    return oo.overlayOp(t, e, Mo.SYMDIFFERENCE)
                }, oo.difference = function(t, e) {
                    return oo.overlayOp(t, e, Mo.DIFFERENCE)
                };
                var ro = function(t, e) {
                    this._geom = new Array(2).fill(null), this._geom[0] = t, this._geom[1] = e
                };
                ro.prototype.getResultGeometry = function(t) {
                    var e = null,
                        n = !1,
                        i = null;
                    try {
                        e = Mo.overlayOp(this._geom[0], this._geom[1], t), n = !0
                    } catch (t) {
                        if (!(t instanceof $)) throw t;
                        i = t
                    }
                    if (!n) try {
                        e = oo.overlayOp(this._geom[0], this._geom[1], t)
                    } catch (t) {
                        throw t instanceof $ ? i : t
                    }
                    return e
                }, ro.prototype.interfaces_ = function() {
                    return []
                }, ro.prototype.getClass = function() {
                    return ro
                }, ro.overlayOp = function(t, e, n) {
                    return new ro(t, e).getResultGeometry(n)
                }, ro.union = function(t, e) {
                    return ro.overlayOp(t, e, Mo.UNION)
                }, ro.intersection = function(t, e) {
                    return ro.overlayOp(t, e, Mo.INTERSECTION)
                }, ro.symDifference = function(t, e) {
                    return ro.overlayOp(t, e, Mo.SYMDIFFERENCE)
                }, ro.difference = function(t, e) {
                    return ro.overlayOp(t, e, Mo.DIFFERENCE)
                };
                var so = function() {
                    this.mce = null, this.chainIndex = null;
                    var t = arguments[0],
                        e = arguments[1];
                    this.mce = t, this.chainIndex = e
                };
                so.prototype.computeIntersections = function(t, e) {
                    this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e)
                }, so.prototype.interfaces_ = function() {
                    return []
                }, so.prototype.getClass = function() {
                    return so
                };
                var ao = function t() {
                        if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, 2 === arguments.length) {
                            var e = arguments[0],
                                n = arguments[1];
                            this._eventType = t.DELETE, this._xValue = e, this._insertEvent = n
                        } else if (3 === arguments.length) {
                            var i = arguments[0],
                                o = arguments[1],
                                r = arguments[2];
                            this._eventType = t.INSERT, this._label = i, this._xValue = o, this._obj = r
                        }
                    },
                    ho = {
                        INSERT: {
                            configurable: !0
                        },
                        DELETE: {
                            configurable: !0
                        }
                    };
                ao.prototype.isDelete = function() {
                    return this._eventType === ao.DELETE
                }, ao.prototype.setDeleteEventIndex = function(t) {
                    this._deleteEventIndex = t
                }, ao.prototype.getObject = function() {
                    return this._obj
                }, ao.prototype.compareTo = function(t) {
                    var e = t;
                    return this._xValue < e._xValue ? -1 : this._xValue > e._xValue ? 1 : this._eventType < e._eventType ? -1 : this._eventType > e._eventType ? 1 : 0
                }, ao.prototype.getInsertEvent = function() {
                    return this._insertEvent
                }, ao.prototype.isInsert = function() {
                    return this._eventType === ao.INSERT
                }, ao.prototype.isSameLabel = function(t) {
                    return null !== this._label && this._label === t._label
                }, ao.prototype.getDeleteEventIndex = function() {
                    return this._deleteEventIndex
                }, ao.prototype.interfaces_ = function() {
                    return [x]
                }, ao.prototype.getClass = function() {
                    return ao
                }, ho.INSERT.get = function() {
                    return 1
                }, ho.DELETE.get = function() {
                    return 2
                }, Object.defineProperties(ao, ho);
                var uo = function() {};
                uo.prototype.interfaces_ = function() {
                    return []
                }, uo.prototype.getClass = function() {
                    return uo
                };
                var lo = function() {
                    this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = !1, this._isDoneWhenProperInt = !1;
                    var t = arguments[0],
                        e = arguments[1],
                        n = arguments[2];
                    this._li = t, this._includeProper = e, this._recordIsolated = n
                };
                lo.prototype.isTrivialIntersection = function(t, e, n, i) {
                    if (t === n && 1 === this._li.getIntersectionNum()) {
                        if (lo.isAdjacentSegments(e, i)) return !0;
                        if (t.isClosed()) {
                            var o = t.getNumPoints() - 1;
                            if (0 === e && i === o || 0 === i && e === o) return !0
                        }
                    }
                    return !1
                }, lo.prototype.getProperIntersectionPoint = function() {
                    return this._properIntersectionPoint
                }, lo.prototype.setIsDoneIfProperInt = function(t) {
                    this._isDoneWhenProperInt = t
                }, lo.prototype.hasProperInteriorIntersection = function() {
                    return this._hasProperInterior
                }, lo.prototype.isBoundaryPointInternal = function(t, e) {
                    for (var n = e.iterator(); n.hasNext();) {
                        var i = n.next().getCoordinate();
                        if (t.isIntersection(i)) return !0
                    }
                    return !1
                }, lo.prototype.hasProperIntersection = function() {
                    return this._hasProper
                }, lo.prototype.hasIntersection = function() {
                    return this._hasIntersection
                }, lo.prototype.isDone = function() {
                    return this._isDone
                }, lo.prototype.isBoundaryPoint = function(t, e) {
                    return !(null === e || !this.isBoundaryPointInternal(t, e[0]) && !this.isBoundaryPointInternal(t, e[1]))
                }, lo.prototype.setBoundaryNodes = function(t, e) {
                    this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = t, this._bdyNodes[1] = e
                }, lo.prototype.addIntersections = function(t, e, n, i) {
                    if (t === n && e === i) return null;
                    this.numTests++;
                    var o = t.getCoordinates()[e],
                        r = t.getCoordinates()[e + 1],
                        s = n.getCoordinates()[i],
                        a = n.getCoordinates()[i + 1];
                    this._li.computeIntersection(o, r, s, a), this._li.hasIntersection() && (this._recordIsolated && (t.setIsolated(!1), n.setIsolated(!1)), this._numIntersections++, this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, !this._includeProper && this._li.isProper() || (t.addIntersections(this._li, e, 0), n.addIntersections(this._li, i, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = !0, this._isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = !0))))
                }, lo.prototype.interfaces_ = function() {
                    return []
                }, lo.prototype.getClass = function() {
                    return lo
                }, lo.isAdjacentSegments = function(t, e) {
                    return 1 === Math.abs(t - e)
                };
                var co = function(t) {
                        function e() {
                            t.call(this), this.events = new Et, this.nOverlaps = null
                        }
                        return t && (e.__proto__ = t),
                            e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.prepareEvents = function() {
                                $e.sort(this.events);
                                for (var t = 0; t < this.events.size(); t++) {
                                    var e = this.events.get(t);
                                    e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t)
                                }
                            }, e.prototype.computeIntersections = function() {
                                if (1 === arguments.length) {
                                    var t = arguments[0];
                                    this.nOverlaps = 0, this.prepareEvents();
                                    for (var e = 0; e < this.events.size(); e++) {
                                        var n = this.events.get(e);
                                        if (n.isInsert() && this.processOverlaps(e, n.getDeleteEventIndex(), n, t), t.isDone()) break
                                    }
                                } else if (3 === arguments.length)
                                    if (arguments[2] instanceof lo && N(arguments[0], bt) && N(arguments[1], bt)) {
                                        var i = arguments[0],
                                            o = arguments[1],
                                            r = arguments[2];
                                        this.addEdges(i, i), this.addEdges(o, o), this.computeIntersections(r)
                                    } else if ("boolean" == typeof arguments[2] && N(arguments[0], bt) && arguments[1] instanceof lo) {
                                    var s = arguments[0],
                                        a = arguments[1];
                                    arguments[2] ? this.addEdges(s, null) : this.addEdges(s), this.computeIntersections(a)
                                }
                            }, e.prototype.addEdge = function(t, e) {
                                for (var n = t.getMonotoneChainEdge(), i = n.getStartIndexes(), o = 0; o < i.length - 1; o++) {
                                    var r = new so(n, o),
                                        s = new ao(e, n.getMinX(o), r);
                                    this.events.add(s), this.events.add(new ao(n.getMaxX(o), s))
                                }
                            }, e.prototype.processOverlaps = function(t, e, n, i) {
                                for (var o = n.getObject(), r = t; r < e; r++) {
                                    var s = this.events.get(r);
                                    if (s.isInsert()) {
                                        var a = s.getObject();
                                        n.isSameLabel(s) || (o.computeIntersections(a, i), this.nOverlaps++)
                                    }
                                }
                            }, e.prototype.addEdges = function() {
                                if (1 === arguments.length)
                                    for (var t = arguments[0].iterator(); t.hasNext();) {
                                        var e = t.next();
                                        this.addEdge(e, e)
                                    } else if (2 === arguments.length)
                                        for (var n = arguments[0], i = arguments[1], o = n.iterator(); o.hasNext();) {
                                            var r = o.next();
                                            this.addEdge(r, i)
                                        }
                            }, e.prototype.interfaces_ = function() {
                                return []
                            }, e.prototype.getClass = function() {
                                return e
                            }, e
                    }(uo),
                    po = function() {
                        this._min = v.POSITIVE_INFINITY, this._max = v.NEGATIVE_INFINITY
                    },
                    fo = {
                        NodeComparator: {
                            configurable: !0
                        }
                    };
                po.prototype.getMin = function() {
                    return this._min
                }, po.prototype.intersects = function(t, e) {
                    return !(this._min > e || this._max < t)
                }, po.prototype.getMax = function() {
                    return this._max
                }, po.prototype.toString = function() {
                    return Q.toLineString(new C(this._min, 0), new C(this._max, 0))
                }, po.prototype.interfaces_ = function() {
                    return []
                }, po.prototype.getClass = function() {
                    return po
                }, fo.NodeComparator.get = function() {
                    return _o
                }, Object.defineProperties(po, fo);
                var _o = function() {};
                _o.prototype.compare = function(t, e) {
                    var n = t,
                        i = e,
                        o = (n._min + n._max) / 2,
                        r = (i._min + i._max) / 2;
                    return o < r ? -1 : o > r ? 1 : 0
                }, _o.prototype.interfaces_ = function() {
                    return [E]
                }, _o.prototype.getClass = function() {
                    return _o
                };
                var go = function(t) {
                        function e() {
                            t.call(this), this._item = null;
                            var e = arguments[0],
                                n = arguments[1],
                                i = arguments[2];
                            this._min = e, this._max = n, this._item = i
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.query = function(t, e, n) {
                            if (!this.intersects(t, e)) return null;
                            n.visitItem(this._item)
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e
                    }(po),
                    mo = function(t) {
                        function e() {
                            t.call(this), this._node1 = null, this._node2 = null;
                            var e = arguments[0],
                                n = arguments[1];
                            this._node1 = e, this._node2 = n, this.buildExtent(this._node1, this._node2)
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.buildExtent = function(t, e) {
                            this._min = Math.min(t._min, e._min), this._max = Math.max(t._max, e._max)
                        }, e.prototype.query = function(t, e, n) {
                            if (!this.intersects(t, e)) return null;
                            null !== this._node1 && this._node1.query(t, e, n), null !== this._node2 && this._node2.query(t, e, n)
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e
                    }(po),
                    yo = function() {
                        this._leaves = new Et, this._root = null, this._level = 0
                    };
                yo.prototype.buildTree = function() {
                    $e.sort(this._leaves, new po.NodeComparator);
                    for (var t = this._leaves, e = null, n = new Et;;) {
                        if (this.buildLevel(t, n), 1 === n.size()) return n.get(0);
                        e = t, t = n, n = e
                    }
                }, yo.prototype.insert = function(t, e, n) {
                    if (null !== this._root) throw new Error("Index cannot be added to once it has been queried");
                    this._leaves.add(new go(t, e, n))
                }, yo.prototype.query = function(t, e, n) {
                    this.init(), this._root.query(t, e, n)
                }, yo.prototype.buildRoot = function() {
                    if (null !== this._root) return null;
                    this._root = this.buildTree()
                }, yo.prototype.printNode = function(t) {
                    Z.out.println(Q.toLineString(new C(t._min, this._level), new C(t._max, this._level)))
                }, yo.prototype.init = function() {
                    if (null !== this._root) return null;
                    this.buildRoot()
                }, yo.prototype.buildLevel = function(t, e) {
                    this._level++, e.clear();
                    for (var n = 0; n < t.size(); n += 2) {
                        var i = t.get(n);
                        if (null === (n + 1 < t.size() ? t.get(n) : null)) e.add(i);
                        else {
                            var o = new mo(t.get(n), t.get(n + 1));
                            e.add(o)
                        }
                    }
                }, yo.prototype.interfaces_ = function() {
                    return []
                }, yo.prototype.getClass = function() {
                    return yo
                };
                var vo = function() {
                    this._items = new Et
                };
                vo.prototype.visitItem = function(t) {
                    this._items.add(t)
                }, vo.prototype.getItems = function() {
                    return this._items
                }, vo.prototype.interfaces_ = function() {
                    return [Xe]
                }, vo.prototype.getClass = function() {
                    return vo
                };
                var Lo = function() {
                        this._index = null;
                        var t = arguments[0];
                        if (!N(t, Qt)) throw new y("Argument must be Polygonal");
                        this._index = new Eo(t)
                    },
                    xo = {
                        SegmentVisitor: {
                            configurable: !0
                        },
                        IntervalIndexedGeometry: {
                            configurable: !0
                        }
                    };
                Lo.prototype.locate = function(t) {
                    var e = new st(t),
                        n = new bo(e);
                    return this._index.query(t.y, t.y, n), e.getLocation()
                }, Lo.prototype.interfaces_ = function() {
                    return [Gn]
                }, Lo.prototype.getClass = function() {
                    return Lo
                }, xo.SegmentVisitor.get = function() {
                    return bo
                }, xo.IntervalIndexedGeometry.get = function() {
                    return Eo
                }, Object.defineProperties(Lo, xo);
                var bo = function() {
                    this._counter = null;
                    var t = arguments[0];
                    this._counter = t
                };
                bo.prototype.visitItem = function(t) {
                    var e = t;
                    this._counter.countSegment(e.getCoordinate(0), e.getCoordinate(1))
                }, bo.prototype.interfaces_ = function() {
                    return [Xe]
                }, bo.prototype.getClass = function() {
                    return bo
                };
                var Eo = function() {
                    this._index = new yo;
                    var t = arguments[0];
                    this.init(t)
                };
                Eo.prototype.init = function(t) {
                    for (var e = Ci.getLines(t).iterator(); e.hasNext();) {
                        var n = e.next().getCoordinates();
                        this.addLine(n)
                    }
                }, Eo.prototype.addLine = function(t) {
                    for (var e = 1; e < t.length; e++) {
                        var n = new _n(t[e - 1], t[e]),
                            i = Math.min(n.p0.y, n.p1.y),
                            o = Math.max(n.p0.y, n.p1.y);
                        this._index.insert(i, o, n)
                    }
                }, Eo.prototype.query = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1],
                            n = new vo;
                        return this._index.query(t, e, n), n.getItems()
                    }
                    if (3 === arguments.length) {
                        var i = arguments[0],
                            o = arguments[1],
                            r = arguments[2];
                        this._index.query(i, o, r)
                    }
                }, Eo.prototype.interfaces_ = function() {
                    return []
                }, Eo.prototype.getClass = function() {
                    return Eo
                };
                var Co = function(t) {
                        function e() {
                            if (t.call(this), this._parentGeom = null, this._lineEdgeMap = new pe, this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = !0, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = !1, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Ii, 2 === arguments.length) {
                                var e = arguments[0],
                                    n = arguments[1],
                                    i = dt.OGC_SFS_BOUNDARY_RULE;
                                this._argIndex = e, this._parentGeom = n, this._boundaryNodeRule = i, null !== n && this.add(n)
                            } else if (3 === arguments.length) {
                                var o = arguments[0],
                                    r = arguments[1],
                                    s = arguments[2];
                                this._argIndex = o, this._parentGeom = r, this._boundaryNodeRule = s, null !== r && this.add(r)
                            }
                        }
                        return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.insertBoundaryPoint = function(t, n) {
                            var i = this._nodes.addNode(n).getLabel(),
                                o = 1;
                            S.NONE, i.getLocation(t, Ie.ON) === S.BOUNDARY && o++;
                            var r = e.determineBoundary(this._boundaryNodeRule, o);
                            i.setLocation(t, r)
                        }, e.prototype.computeSelfNodes = function() {
                            if (2 === arguments.length) {
                                var t = arguments[0],
                                    e = arguments[1];
                                return this.computeSelfNodes(t, e, !1)
                            }
                            if (3 === arguments.length) {
                                var n = arguments[0],
                                    i = arguments[1],
                                    o = arguments[2],
                                    r = new lo(n, !0, !1);
                                r.setIsDoneIfProperInt(o);
                                var s = this.createEdgeSetIntersector(),
                                    a = this._parentGeom instanceof ee || this._parentGeom instanceof $t || this._parentGeom instanceof ne,
                                    h = i || !a;
                                return s.computeIntersections(this._edges, r, h), this.addSelfIntersectionNodes(this._argIndex), r
                            }
                        }, e.prototype.computeSplitEdges = function(t) {
                            for (var e = this._edges.iterator(); e.hasNext();) e.next().eiList.addSplitEdges(t)
                        }, e.prototype.computeEdgeIntersections = function(t, e, n) {
                            var i = new lo(e, n, !0);
                            return i.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes()), this.createEdgeSetIntersector().computeIntersections(this._edges, t._edges, i), i
                        }, e.prototype.getGeometry = function() {
                            return this._parentGeom
                        }, e.prototype.getBoundaryNodeRule = function() {
                            return this._boundaryNodeRule
                        }, e.prototype.hasTooFewPoints = function() {
                            return this._hasTooFewPoints
                        }, e.prototype.addPoint = function() {
                            if (arguments[0] instanceof Kt) {
                                var t = arguments[0].getCoordinate();
                                this.insertPoint(this._argIndex, t, S.INTERIOR)
                            } else if (arguments[0] instanceof C) {
                                var e = arguments[0];
                                this.insertPoint(this._argIndex, e, S.INTERIOR)
                            }
                        }, e.prototype.addPolygon = function(t) {
                            this.addPolygonRing(t.getExteriorRing(), S.EXTERIOR, S.INTERIOR);
                            for (var e = 0; e < t.getNumInteriorRing(); e++) {
                                var n = t.getInteriorRingN(e);
                                this.addPolygonRing(n, S.INTERIOR, S.EXTERIOR)
                            }
                        }, e.prototype.addEdge = function(t) {
                            this.insertEdge(t);
                            var e = t.getCoordinates();
                            this.insertPoint(this._argIndex, e[0], S.BOUNDARY), this.insertPoint(this._argIndex, e[e.length - 1], S.BOUNDARY)
                        }, e.prototype.addLineString = function(t) {
                            var e = wt.removeRepeatedPoints(t.getCoordinates());
                            if (e.length < 2) return this._hasTooFewPoints = !0, this._invalidPoint = e[0], null;
                            var n = new ni(e, new Oe(this._argIndex, S.INTERIOR));
                            this._lineEdgeMap.put(t, n), this.insertEdge(n), et.isTrue(e.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this._argIndex, e[0]), this.insertBoundaryPoint(this._argIndex, e[e.length - 1])
                        }, e.prototype.getInvalidPoint = function() {
                            return this._invalidPoint
                        }, e.prototype.getBoundaryPoints = function() {
                            for (var t = this.getBoundaryNodes(), e = new Array(t.size()).fill(null), n = 0, i = t.iterator(); i.hasNext();) {
                                var o = i.next();
                                e[n++] = o.getCoordinate().copy()
                            }
                            return e
                        }, e.prototype.getBoundaryNodes = function() {
                            return null === this._boundaryNodes && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes
                        }, e.prototype.addSelfIntersectionNode = function(t, e, n) {
                            if (this.isBoundaryNode(t, e)) return null;
                            n === S.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(t, e) : this.insertPoint(t, e, n)
                        }, e.prototype.addPolygonRing = function(t, e, n) {
                            if (t.isEmpty()) return null;
                            var i = wt.removeRepeatedPoints(t.getCoordinates());
                            if (i.length < 4) return this._hasTooFewPoints = !0, this._invalidPoint = i[0], null;
                            var o = e,
                                r = n;
                            at.isCCW(i) && (o = n, r = e);
                            var s = new ni(i, new Oe(this._argIndex, S.BOUNDARY, o, r));
                            this._lineEdgeMap.put(t, s), this.insertEdge(s), this.insertPoint(this._argIndex, i[0], S.BOUNDARY)
                        }, e.prototype.insertPoint = function(t, e, n) {
                            var i = this._nodes.addNode(e),
                                o = i.getLabel();
                            null === o ? i._label = new Oe(t, n) : o.setLocation(t, n)
                        }, e.prototype.createEdgeSetIntersector = function() {
                            return new co
                        }, e.prototype.addSelfIntersectionNodes = function(t) {
                            for (var e = this._edges.iterator(); e.hasNext();)
                                for (var n = e.next(), i = n.getLabel().getLocation(t), o = n.eiList.iterator(); o.hasNext();) {
                                    var r = o.next();
                                    this.addSelfIntersectionNode(t, r.coord, i)
                                }
                        }, e.prototype.add = function() {
                            if (1 !== arguments.length) return t.prototype.add.apply(this, arguments);
                            var e = arguments[0];
                            if (e.isEmpty()) return null;
                            if (e instanceof ne && (this._useBoundaryDeterminationRule = !1), e instanceof $t) this.addPolygon(e);
                            else if (e instanceof Xt) this.addLineString(e);
                            else if (e instanceof Kt) this.addPoint(e);
                            else if (e instanceof te) this.addCollection(e);
                            else if (e instanceof qt) this.addCollection(e);
                            else if (e instanceof ne) this.addCollection(e);
                            else {
                                if (!(e instanceof jt)) throw new Error(e.getClass().getName());
                                this.addCollection(e)
                            }
                        }, e.prototype.addCollection = function(t) {
                            for (var e = 0; e < t.getNumGeometries(); e++) {
                                var n = t.getGeometryN(e);
                                this.add(n)
                            }
                        }, e.prototype.locate = function(t) {
                            return N(this._parentGeom, Qt) && this._parentGeom.getNumGeometries() > 50 ? (null === this._areaPtLocator && (this._areaPtLocator = new Lo(this._parentGeom)), this._areaPtLocator.locate(t)) : this._ptLocator.locate(t, this._parentGeom)
                        }, e.prototype.findEdge = function() {
                            if (1 === arguments.length) {
                                var e = arguments[0];
                                return this._lineEdgeMap.get(e)
                            }
                            return t.prototype.findEdge.apply(this, arguments)
                        }, e.prototype.interfaces_ = function() {
                            return []
                        }, e.prototype.getClass = function() {
                            return e
                        }, e.determineBoundary = function(t, e) {
                            return t.isInBoundary(e) ? S.BOUNDARY : S.INTERIOR
                        }, e
                    }(Ze),
                    Io = function() {
                        if (this._li = new ot, this._resultPrecisionModel = null, this._arg = null, 1 === arguments.length) {
                            var t = arguments[0];
                            this.setComputationPrecision(t.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new Co(0, t)
                        } else if (2 === arguments.length) {
                            var e = arguments[0],
                                n = arguments[1],
                                i = dt.OGC_SFS_BOUNDARY_RULE;
                            e.getPrecisionModel().compareTo(n.getPrecisionModel()) >= 0 ? this.setComputationPrecision(e.getPrecisionModel()) : this.setComputationPrecision(n.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Co(0, e, i), this._arg[1] = new Co(1, n, i)
                        } else if (3 === arguments.length) {
                            var o = arguments[0],
                                r = arguments[1],
                                s = arguments[2];
                            o.getPrecisionModel().compareTo(r.getPrecisionModel()) >= 0 ? this.setComputationPrecision(o.getPrecisionModel()) : this.setComputationPrecision(r.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Co(0, o, s), this._arg[1] = new Co(1, r, s)
                        }
                    };
                Io.prototype.getArgGeometry = function(t) {
                    return this._arg[t].getGeometry()
                }, Io.prototype.setComputationPrecision = function(t) {
                    this._resultPrecisionModel = t, this._li.setPrecisionModel(this._resultPrecisionModel)
                }, Io.prototype.interfaces_ = function() {
                    return []
                }, Io.prototype.getClass = function() {
                    return Io
                };
                var wo = function() {};
                wo.prototype.interfaces_ = function() {
                    return []
                }, wo.prototype.getClass = function() {
                    return wo
                }, wo.map = function() {
                    if (arguments[0] instanceof lt && N(arguments[1], wo.MapOp)) {
                        for (var t = arguments[0], e = arguments[1], n = new Et, i = 0; i < t.getNumGeometries(); i++) {
                            var o = e.map(t.getGeometryN(i));
                            null !== o && n.add(o)
                        }
                        return t.getFactory().buildGeometry(n)
                    }
                    if (N(arguments[0], Lt) && N(arguments[1], wo.MapOp)) {
                        for (var r = arguments[0], s = arguments[1], a = new Et, h = r.iterator(); h.hasNext();) {
                            var u = h.next(),
                                l = s.map(u);
                            null !== l && a.add(l)
                        }
                        return a
                    }
                }, wo.MapOp = function() {};
                var Mo = function(t) {
                    function e() {
                        var e = arguments[0],
                            n = arguments[1];
                        t.call(this, e, n), this._ptLocator = new Ii, this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new Yn, this._resultPolyList = new Et, this._resultLineList = new Et, this._resultPointList = new Et, this._graph = new Ze(new Vn), this._geomFact = e.getFactory()
                    }
                    return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.insertUniqueEdge = function(t) {
                        var e = this._edgeList.findEqualEdge(t);
                        if (null !== e) {
                            var n = e.getLabel(),
                                i = t.getLabel();
                            e.isPointwiseEqual(t) || (i = new Oe(t.getLabel())).flip();
                            var o = e.getDepth();
                            o.isNull() && o.add(n), o.add(i), n.merge(i)
                        } else this._edgeList.add(t)
                    }, e.prototype.getGraph = function() {
                        return this._graph
                    }, e.prototype.cancelDuplicateResultEdges = function() {
                        for (var t = this._graph.getEdgeEnds().iterator(); t.hasNext();) {
                            var e = t.next(),
                                n = e.getSym();
                            e.isInResult() && n.isInResult() && (e.setInResult(!1), n.setInResult(!1))
                        }
                    }, e.prototype.isCoveredByLA = function(t) {
                        return !!this.isCovered(t, this._resultLineList) || !!this.isCovered(t, this._resultPolyList)
                    }, e.prototype.computeGeometry = function(t, n, i, o) {
                        var r = new Et;
                        return r.addAll(t), r.addAll(n), r.addAll(i), r.isEmpty() ? e.createEmptyResult(o, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(r)
                    }, e.prototype.mergeSymLabels = function() {
                        for (var t = this._graph.getNodes().iterator(); t.hasNext();) t.next().getEdges().mergeSymLabels()
                    }, e.prototype.isCovered = function(t, e) {
                        for (var n = e.iterator(); n.hasNext();) {
                            var i = n.next();
                            if (this._ptLocator.locate(t, i) !== S.EXTERIOR) return !0
                        }
                        return !1
                    }, e.prototype.replaceCollapsedEdges = function() {
                        for (var t = new Et, e = this._edgeList.iterator(); e.hasNext();) {
                            var n = e.next();
                            n.isCollapsed() && (e.remove(), t.add(n.getCollapsedEdge()))
                        }
                        this._edgeList.addAll(t)
                    }, e.prototype.updateNodeLabelling = function() {
                        for (var t = this._graph.getNodes().iterator(); t.hasNext();) {
                            var e = t.next(),
                                n = e.getEdges().getLabel();
                            e.getLabel().merge(n)
                        }
                    }, e.prototype.getResultGeometry = function(t) {
                        return this.computeOverlay(t), this._resultGeom
                    }, e.prototype.insertUniqueEdges = function(t) {
                        for (var e = t.iterator(); e.hasNext();) {
                            var n = e.next();
                            this.insertUniqueEdge(n)
                        }
                    }, e.prototype.computeOverlay = function(t) {
                        this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, !1), this._arg[1].computeSelfNodes(this._li, !1), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !0);
                        var e = new Et;
                        this._arg[0].computeSplitEdges(e), this._arg[1].computeSplitEdges(e), this.insertUniqueEdges(e), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Zi.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t), this.cancelDuplicateResultEdges();
                        var n = new Ve(this._geomFact);
                        n.add(this._graph), this._resultPolyList = n.getPolygons();
                        var i = new Hi(this, this._geomFact, this._ptLocator);
                        this._resultLineList = i.build(t);
                        var o = new Yi(this, this._geomFact, this._ptLocator);
                        this._resultPointList = o.build(t), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, t)
                    }, e.prototype.labelIncompleteNode = function(t, e) {
                        var n = this._ptLocator.locate(t.getCoordinate(), this._arg[e].getGeometry());
                        t.getLabel().setLocation(e, n)
                    }, e.prototype.copyPoints = function(t) {
                        for (var e = this._arg[t].getNodeIterator(); e.hasNext();) {
                            var n = e.next();
                            this._graph.addNode(n.getCoordinate()).setLabel(t, n.getLabel().getLocation(t))
                        }
                    }, e.prototype.findResultAreaEdges = function(t) {
                        for (var n = this._graph.getEdgeEnds().iterator(); n.hasNext();) {
                            var i = n.next(),
                                o = i.getLabel();
                            o.isArea() && !i.isInteriorAreaEdge() && e.isResultOfOp(o.getLocation(0, Ie.RIGHT), o.getLocation(1, Ie.RIGHT), t) && i.setInResult(!0)
                        }
                    }, e.prototype.computeLabelsFromDepths = function() {
                        for (var t = this._edgeList.iterator(); t.hasNext();) {
                            var e = t.next(),
                                n = e.getLabel(),
                                i = e.getDepth();
                            if (!i.isNull()) {
                                i.normalize();
                                for (var o = 0; o < 2; o++) n.isNull(o) || !n.isArea() || i.isNull(o) || (0 === i.getDelta(o) ? n.toLine(o) : (et.isTrue(!i.isNull(o, Ie.LEFT), "depth of LEFT side has not been initialized"), n.setLocation(o, Ie.LEFT, i.getLocation(o, Ie.LEFT)), et.isTrue(!i.isNull(o, Ie.RIGHT), "depth of RIGHT side has not been initialized"), n.setLocation(o, Ie.RIGHT, i.getLocation(o, Ie.RIGHT))))
                            }
                        }
                    }, e.prototype.computeLabelling = function() {
                        for (var t = this._graph.getNodes().iterator(); t.hasNext();) t.next().getEdges().computeLabelling(this._arg);
                        this.mergeSymLabels(), this.updateNodeLabelling()
                    }, e.prototype.labelIncompleteNodes = function() {
                        for (var t = this._graph.getNodes().iterator(); t.hasNext();) {
                            var e = t.next(),
                                n = e.getLabel();
                            e.isIsolated() && (n.isNull(0) ? this.labelIncompleteNode(e, 0) : this.labelIncompleteNode(e, 1)), e.getEdges().updateLabelling(n)
                        }
                    }, e.prototype.isCoveredByA = function(t) {
                        return !!this.isCovered(t, this._resultPolyList)
                    }, e.prototype.interfaces_ = function() {
                        return []
                    }, e.prototype.getClass = function() {
                        return e
                    }, e
                }(Io);
                Mo.overlayOp = function(t, e, n) {
                    return new Mo(t, e).getResultGeometry(n)
                }, Mo.intersection = function(t, e) {
                    if (t.isEmpty() || e.isEmpty()) return Mo.createEmptyResult(Mo.INTERSECTION, t, e, t.getFactory());
                    if (t.isGeometryCollection()) {
                        var n = e;
                        return Vi.map(t, {
                            interfaces_: function() {
                                return [wo.MapOp]
                            },
                            map: function(t) {
                                return t.intersection(n)
                            }
                        })
                    }
                    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), ro.overlayOp(t, e, Mo.INTERSECTION)
                }, Mo.symDifference = function(t, e) {
                    if (t.isEmpty() || e.isEmpty()) {
                        if (t.isEmpty() && e.isEmpty()) return Mo.createEmptyResult(Mo.SYMDIFFERENCE, t, e, t.getFactory());
                        if (t.isEmpty()) return e.copy();
                        if (e.isEmpty()) return t.copy()
                    }
                    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), ro.overlayOp(t, e, Mo.SYMDIFFERENCE)
                }, Mo.resultDimension = function(t, e, n) {
                    var i = e.getDimension(),
                        o = n.getDimension(),
                        r = -1;
                    switch (t) {
                        case Mo.INTERSECTION:
                            r = Math.min(i, o);
                            break;
                        case Mo.UNION:
                            r = Math.max(i, o);
                            break;
                        case Mo.DIFFERENCE:
                            r = i;
                            break;
                        case Mo.SYMDIFFERENCE:
                            r = Math.max(i, o)
                    }
                    return r
                }, Mo.createEmptyResult = function(t, e, n, i) {
                    var o = null;
                    switch (Mo.resultDimension(t, e, n)) {
                        case -1:
                            o = i.createGeometryCollection(new Array(0).fill(null));
                            break;
                        case 0:
                            o = i.createPoint();
                            break;
                        case 1:
                            o = i.createLineString();
                            break;
                        case 2:
                            o = i.createPolygon()
                    }
                    return o
                }, Mo.difference = function(t, e) {
                    return t.isEmpty() ? Mo.createEmptyResult(Mo.DIFFERENCE, t, e, t.getFactory()) : e.isEmpty() ? t.copy() : (t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), ro.overlayOp(t, e, Mo.DIFFERENCE))
                }, Mo.isResultOfOp = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1],
                            n = t.getLocation(0),
                            i = t.getLocation(1);
                        return Mo.isResultOfOp(n, i, e)
                    }
                    if (3 === arguments.length) {
                        var o = arguments[0],
                            r = arguments[1],
                            s = arguments[2];
                        switch (o === S.BOUNDARY && (o = S.INTERIOR), r === S.BOUNDARY && (r = S.INTERIOR), s) {
                            case Mo.INTERSECTION:
                                return o === S.INTERIOR && r === S.INTERIOR;
                            case Mo.UNION:
                                return o === S.INTERIOR || r === S.INTERIOR;
                            case Mo.DIFFERENCE:
                                return o === S.INTERIOR && r !== S.INTERIOR;
                            case Mo.SYMDIFFERENCE:
                                return o === S.INTERIOR && r !== S.INTERIOR || o !== S.INTERIOR && r === S.INTERIOR
                        }
                        return !1
                    }
                }, Mo.INTERSECTION = 1, Mo.UNION = 2, Mo.DIFFERENCE = 3, Mo.SYMDIFFERENCE = 4;
                var So = function() {
                    this._g = null, this._boundaryDistanceTolerance = null, this._linework = null, this._ptLocator = new Ii, this._seg = new _n;
                    var t = arguments[0],
                        e = arguments[1];
                    this._g = t, this._boundaryDistanceTolerance = e, this._linework = this.extractLinework(t)
                };
                So.prototype.isWithinToleranceOfBoundary = function(t) {
                    for (var e = 0; e < this._linework.getNumGeometries(); e++)
                        for (var n = this._linework.getGeometryN(e).getCoordinateSequence(), i = 0; i < n.size() - 1; i++)
                            if (n.getCoordinate(i, this._seg.p0), n.getCoordinate(i + 1, this._seg.p1), this._seg.distance(t) <= this._boundaryDistanceTolerance) return !0;
                    return !1
                }, So.prototype.getLocation = function(t) {
                    return this.isWithinToleranceOfBoundary(t) ? S.BOUNDARY : this._ptLocator.locate(t, this._g)
                }, So.prototype.extractLinework = function(t) {
                    var e = new Po;
                    t.apply(e);
                    var n = e.getLinework(),
                        i = me.toLineStringArray(n);
                    return t.getFactory().createMultiLineString(i)
                }, So.prototype.interfaces_ = function() {
                    return []
                }, So.prototype.getClass = function() {
                    return So
                };
                var Po = function() {
                    this._linework = null, this._linework = new Et
                };
                Po.prototype.getLinework = function() {
                    return this._linework
                }, Po.prototype.filter = function(t) {
                    if (t instanceof $t) {
                        var e = t;
                        this._linework.add(e.getExteriorRing());
                        for (var n = 0; n < e.getNumInteriorRing(); n++) this._linework.add(e.getInteriorRingN(n))
                    }
                }, Po.prototype.interfaces_ = function() {
                    return [Gt]
                }, Po.prototype.getClass = function() {
                    return Po
                };
                var No = function() {
                    this._g = null, this._doLeft = !0, this._doRight = !0;
                    var t = arguments[0];
                    this._g = t
                };
                No.prototype.extractPoints = function(t, e, n) {
                    for (var i = t.getCoordinates(), o = 0; o < i.length - 1; o++) this.computeOffsetPoints(i[o], i[o + 1], e, n)
                }, No.prototype.setSidesToGenerate = function(t, e) {
                    this._doLeft = t, this._doRight = e
                }, No.prototype.getPoints = function(t) {
                    for (var e = new Et, n = Ci.getLines(this._g).iterator(); n.hasNext();) {
                        var i = n.next();
                        this.extractPoints(i, t, e)
                    }
                    return e
                }, No.prototype.computeOffsetPoints = function(t, e, n, i) {
                    var o = e.x - t.x,
                        r = e.y - t.y,
                        s = Math.sqrt(o * o + r * r),
                        a = n * o / s,
                        h = n * r / s,
                        u = (e.x + t.x) / 2,
                        l = (e.y + t.y) / 2;
                    if (this._doLeft) {
                        var c = new C(u - h, l + a);
                        i.add(c)
                    }
                    if (this._doRight) {
                        var p = new C(u + h, l - a);
                        i.add(p)
                    }
                }, No.prototype.interfaces_ = function() {
                    return []
                }, No.prototype.getClass = function() {
                    return No
                };
                var To = function t() {
                        this._geom = null, this._locFinder = null, this._location = new Array(3).fill(null), this._invalidLocation = null, this._boundaryDistanceTolerance = t.TOLERANCE, this._testCoords = new Et;
                        var e = arguments[0],
                            n = arguments[1],
                            i = arguments[2];
                        this._boundaryDistanceTolerance = t.computeBoundaryDistanceTolerance(e, n), this._geom = [e, n, i], this._locFinder = [new So(this._geom[0], this._boundaryDistanceTolerance), new So(this._geom[1], this._boundaryDistanceTolerance), new So(this._geom[2], this._boundaryDistanceTolerance)]
                    },
                    Oo = {
                        TOLERANCE: {
                            configurable: !0
                        }
                    };
                To.prototype.reportResult = function(t, e, n) {
                    Z.out.println("Overlay result invalid - A:" + S.toLocationSymbol(e[0]) + " B:" + S.toLocationSymbol(e[1]) + " expected:" + (n ? "i" : "e") + " actual:" + S.toLocationSymbol(e[2]))
                }, To.prototype.isValid = function(t) {
                    return this.addTestPts(this._geom[0]), this.addTestPts(this._geom[1]), this.checkValid(t)
                }, To.prototype.checkValid = function() {
                    if (1 === arguments.length) {
                        for (var t = arguments[0], e = 0; e < this._testCoords.size(); e++) {
                            var n = this._testCoords.get(e);
                            if (!this.checkValid(t, n)) return this._invalidLocation = n, !1
                        }
                        return !0
                    }
                    if (2 === arguments.length) {
                        var i = arguments[0],
                            o = arguments[1];
                        return this._location[0] = this._locFinder[0].getLocation(o), this._location[1] = this._locFinder[1].getLocation(o), this._location[2] = this._locFinder[2].getLocation(o), !!To.hasLocation(this._location, S.BOUNDARY) || this.isValidResult(i, this._location)
                    }
                }, To.prototype.addTestPts = function(t) {
                    var e = new No(t);
                    this._testCoords.addAll(e.getPoints(5 * this._boundaryDistanceTolerance))
                }, To.prototype.isValidResult = function(t, e) {
                    var n = Mo.isResultOfOp(e[0], e[1], t),
                        i = !(n ^ e[2] === S.INTERIOR);
                    return i || this.reportResult(t, e, n), i
                }, To.prototype.getInvalidLocation = function() {
                    return this._invalidLocation
                }, To.prototype.interfaces_ = function() {
                    return []
                }, To.prototype.getClass = function() {
                    return To
                }, To.hasLocation = function(t, e) {
                    for (var n = 0; n < 3; n++)
                        if (t[n] === e) return !0;
                    return !1
                }, To.computeBoundaryDistanceTolerance = function(t, e) {
                    return Math.min(Ji.computeSizeBasedSnapTolerance(t), Ji.computeSizeBasedSnapTolerance(e))
                }, To.isValid = function(t, e, n, i) {
                    return new To(t, e, i).isValid(n)
                }, Oo.TOLERANCE.get = function() {
                    return 1e-6
                }, Object.defineProperties(To, Oo);
                var Ao = function t(e) {
                    this._geomFactory = null, this._skipEmpty = !1, this._inputGeoms = null, this._geomFactory = t.extractFactory(e), this._inputGeoms = e
                };
                Ao.prototype.extractElements = function(t, e) {
                    if (null === t) return null;
                    for (var n = 0; n < t.getNumGeometries(); n++) {
                        var i = t.getGeometryN(n);
                        this._skipEmpty && i.isEmpty() || e.add(i)
                    }
                }, Ao.prototype.combine = function() {
                    for (var t = new Et, e = this._inputGeoms.iterator(); e.hasNext();) {
                        var n = e.next();
                        this.extractElements(n, t)
                    }
                    return 0 === t.size() ? null !== this._geomFactory ? this._geomFactory.createGeometryCollection(null) : null : this._geomFactory.buildGeometry(t)
                }, Ao.prototype.interfaces_ = function() {
                    return []
                }, Ao.prototype.getClass = function() {
                    return Ao
                }, Ao.combine = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return new Ao(t).combine()
                    }
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        return new Ao(Ao.createList(e, n)).combine()
                    }
                    if (3 === arguments.length) {
                        var i = arguments[0],
                            o = arguments[1],
                            r = arguments[2];
                        return new Ao(Ao.createList(i, o, r)).combine()
                    }
                }, Ao.extractFactory = function(t) {
                    return t.isEmpty() ? null : t.iterator().next().getFactory()
                }, Ao.createList = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1],
                            n = new Et;
                        return n.add(t), n.add(e), n
                    }
                    if (3 === arguments.length) {
                        var i = arguments[0],
                            o = arguments[1],
                            r = arguments[2],
                            s = new Et;
                        return s.add(i), s.add(o), s.add(r), s
                    }
                };
                var Ro = function() {
                        this._inputPolys = null, this._geomFactory = null;
                        var t = arguments[0];
                        this._inputPolys = t, null === this._inputPolys && (this._inputPolys = new Et)
                    },
                    Do = {
                        STRTREE_NODE_CAPACITY: {
                            configurable: !0
                        }
                    };
                Ro.prototype.reduceToGeometries = function(t) {
                    for (var e = new Et, n = t.iterator(); n.hasNext();) {
                        var i = n.next(),
                            o = null;
                        N(i, bt) ? o = this.unionTree(i) : i instanceof lt && (o = i), e.add(o)
                    }
                    return e
                }, Ro.prototype.extractByEnvelope = function(t, e, n) {
                    for (var i = new Et, o = 0; o < e.getNumGeometries(); o++) {
                        var r = e.getGeometryN(o);
                        r.getEnvelopeInternal().intersects(t) ? i.add(r) : n.add(r)
                    }
                    return this._geomFactory.buildGeometry(i)
                }, Ro.prototype.unionOptimized = function(t, e) {
                    var n = t.getEnvelopeInternal(),
                        i = e.getEnvelopeInternal();
                    if (!n.intersects(i)) return Ao.combine(t, e);
                    if (t.getNumGeometries() <= 1 && e.getNumGeometries() <= 1) return this.unionActual(t, e);
                    var o = n.intersection(i);
                    return this.unionUsingEnvelopeIntersection(t, e, o)
                }, Ro.prototype.union = function() {
                    if (null === this._inputPolys) throw new Error("union() method cannot be called twice");
                    if (this._inputPolys.isEmpty()) return null;
                    this._geomFactory = this._inputPolys.iterator().next().getFactory();
                    for (var t = new sn(Ro.STRTREE_NODE_CAPACITY), e = this._inputPolys.iterator(); e.hasNext();) {
                        var n = e.next();
                        t.insert(n.getEnvelopeInternal(), n)
                    }
                    this._inputPolys = null;
                    var i = t.itemsTree();
                    return this.unionTree(i)
                }, Ro.prototype.binaryUnion = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return this.binaryUnion(t, 0, t.size())
                    }
                    if (3 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1],
                            i = arguments[2];
                        if (i - n <= 1) {
                            var o = Ro.getGeometry(e, n);
                            return this.unionSafe(o, null)
                        }
                        if (i - n == 2) return this.unionSafe(Ro.getGeometry(e, n), Ro.getGeometry(e, n + 1));
                        var r = Math.trunc((i + n) / 2),
                            s = this.binaryUnion(e, n, r),
                            a = this.binaryUnion(e, r, i);
                        return this.unionSafe(s, a)
                    }
                }, Ro.prototype.repeatedUnion = function(t) {
                    for (var e = null, n = t.iterator(); n.hasNext();) {
                        var i = n.next();
                        e = null === e ? i.copy() : e.union(i)
                    }
                    return e
                }, Ro.prototype.unionSafe = function(t, e) {
                    return null === t && null === e ? null : null === t ? e.copy() : null === e ? t.copy() : this.unionOptimized(t, e)
                }, Ro.prototype.unionActual = function(t, e) {
                    return Ro.restrictToPolygons(t.union(e))
                }, Ro.prototype.unionTree = function(t) {
                    var e = this.reduceToGeometries(t);
                    return this.binaryUnion(e)
                }, Ro.prototype.unionUsingEnvelopeIntersection = function(t, e, n) {
                    var i = new Et,
                        o = this.extractByEnvelope(n, t, i),
                        r = this.extractByEnvelope(n, e, i),
                        s = this.unionActual(o, r);
                    return i.add(s), Ao.combine(i)
                }, Ro.prototype.bufferUnion = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return t.get(0).getFactory().buildGeometry(t).buffer(0)
                    }
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        return e.getFactory().createGeometryCollection([e, n]).buffer(0)
                    }
                }, Ro.prototype.interfaces_ = function() {
                    return []
                }, Ro.prototype.getClass = function() {
                    return Ro
                }, Ro.restrictToPolygons = function(t) {
                    if (N(t, Qt)) return t;
                    var e = Ei.getPolygons(t);
                    return 1 === e.size() ? e.get(0) : t.getFactory().createMultiPolygon(me.toPolygonArray(e))
                }, Ro.getGeometry = function(t, e) {
                    return e >= t.size() ? null : t.get(e)
                }, Ro.union = function(t) {
                    return new Ro(t).union()
                }, Do.STRTREE_NODE_CAPACITY.get = function() {
                    return 4
                }, Object.defineProperties(Ro, Do);
                var ko = function() {};
                ko.prototype.interfaces_ = function() {
                    return []
                }, ko.prototype.getClass = function() {
                    return ko
                }, ko.union = function(t, e) {
                    if (t.isEmpty() || e.isEmpty()) {
                        if (t.isEmpty() && e.isEmpty()) return Mo.createEmptyResult(Mo.UNION, t, e, t.getFactory());
                        if (t.isEmpty()) return e.copy();
                        if (e.isEmpty()) return t.copy()
                    }
                    return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), ro.overlayOp(t, e, Mo.UNION)
                }, t.GeoJSONReader = Ee, t.GeoJSONWriter = Ce, t.OverlayOp = Mo, t.UnionOp = ko, t.BufferOp = _i, Object.defineProperty(t, "__esModule", {
                    value: !0
                })
            }(e)
        },
        function(t, e, n) {
            function i(t) {
                var e = 0;
                if (t && t.length > 0) {
                    e += Math.abs(o(t[0]));
                    for (var n = 1; n < t.length; n++) e -= Math.abs(o(t[n]))
                }
                return e
            }

            function o(t) {
                var e, n, i, o, s, h, u = 0,
                    l = t.length;
                if (l > 2) {
                    for (h = 0; h < l; h++) h === l - 2 ? (i = l - 2, o = l - 1, s = 0) : h === l - 1 ? (i = l - 1, o = 0, s = 1) : (i = h, o = h + 1, s = h + 2), e = t[i], n = t[o], u += (r(t[s][0]) - r(e[0])) * Math.sin(r(n[1]));
                    u = u * a * a / 2
                }
                return u
            }

            function r(t) {
                return t * Math.PI / 180
            }
            var s = n(6),
                a = 6378137;
            e.a = function(t) {
                return Object(s.b)(t, function(t, e) {
                    return t + function t(e) {
                        var n, o = 0;
                        switch (e.type) {
                            case "Polygon":
                                return i(e.coordinates);
                            case "MultiPolygon":
                                for (n = 0; n < e.coordinates.length; n++) o += i(e.coordinates[n]);
                                return o;
                            case "Point":
                            case "MultiPoint":
                            case "LineString":
                            case "MultiLineString":
                                return 0;
                            case "GeometryCollection":
                                for (n = 0; n < e.geometries.length; n++) o += t(e.geometries[n]);
                                return o
                        }
                    }(e)
                }, 0)
            }
        },
        function(t, e, n) {
            function i(t) {
                if (!t) throw new Error("geojson is required");
                if (void 0 !== t.geometry) return t.geometry;
                if (t.coordinates || t.geometries) return t;
                throw new Error("geojson must be a valid Feature or Geometry Object")
            }
            n.d(e, "a", function() {
                return i
            }), n(2)
        },
        function(t, e, n) {
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.default = void 0;
            var i = {
                _initDraggableLayer: function() {
                    this._tempDragCoord = null;
                    var t = this._layer._path ? this._layer._path : this._layer._renderer._container;
                    L.DomUtil.addClass(t, "leaflet-pm-draggable"), this._originalMapDragState = this._layer._map.dragging._enabled, this._safeToCacheDragState = !0, this._layer.on("mousedown", this._dragMixinOnMouseDown, this)
                },
                _dragMixinOnMouseUp: function() {
                    var t = this,
                        e = this._layer._path ? this._layer._path : this._layer._renderer._container;
                    return this._originalMapDragState && this._layer._map.dragging.enable(), this._safeToCacheDragState = !0, this._layer._map.off("mousemove", this._dragMixinOnMouseMove, this),
                        this._layer.off("mouseup", this._dragMixinOnMouseUp, this), !!this._dragging && (this._initMarkers(), window.setTimeout(function() {
                            t._dragging = !1, L.DomUtil.removeClass(e, "leaflet-pm-dragging"), t._layer.fire("pm:dragend"), t._fireEdit()
                        }, 10), !0)
                },
                _dragMixinOnMouseMove: function(t) {
                    var e = this._layer._path ? this._layer._path : this._layer._renderer._container;
                    this._dragging || (this._dragging = !0, L.DomUtil.addClass(e, "leaflet-pm-dragging"), this._layer.bringToFront(), this._originalMapDragState && this._layer._map.dragging.disable(), this._markerGroup.clearLayers(), this._layer.fire("pm:dragstart")), this._onLayerDrag(t)
                },
                _dragMixinOnMouseDown: function(t) {
                    t.originalEvent.button > 0 || (this._safeToCacheDragState && (this._originalMapDragState = this._layer._map.dragging._enabled, this._safeToCacheDragState = !1), this._tempDragCoord = t.latlng, this._layer.on("mouseup", this._dragMixinOnMouseUp, this), this._layer._map.on("mousemove", this._dragMixinOnMouseMove, this))
                },
                dragging: function() {
                    return this._dragging
                },
                _onLayerDrag: function(t) {
                    var e, n = t.latlng,
                        i = n.lat - this._tempDragCoord.lat,
                        o = n.lng - this._tempDragCoord.lng,
                        r = function(t) {
                            return t.map(function(t) {
                                return {
                                    lat: t.lat + i,
                                    lng: t.lng + o
                                }
                            })
                        };
                    e = this.isPolygon() ? this._layer._latlngs.map(r, this) : r(this._layer._latlngs), this._layer.setLatLngs(e).redraw(), this._tempDragCoord = n, this._layer.fire("pm:drag")
                }
            };
            e.default = i
        },
        function(t, e, n) {
            var i;
            ((i = n(1)) && i.__esModule ? i : {
                default: i
            }).default.LayerGroup = L.Class.extend({
                initialize: function(t) {
                    var e = this;
                    this._layerGroup = t, this._layers = this.findLayers(), this._layers.forEach(function(t) {
                        return e._initLayer(t)
                    }), this._layerGroup.on("layeradd", function(t) {
                        t.target._pmTempLayer || (e._layers = e.findLayers(), t.layer.pm && e._initLayer(t.layer), t.target.pm.enabled())
                    })
                },
                findLayers: function() {
                    var t = this._layerGroup.getLayers();
                    return t = (t = t.filter(function(t) {
                        return !!t.pm
                    })).filter(function(t) {
                        return !t._pmTempLayer
                    })
                },
                _initLayer: function(t) {
                    var e = this;
                    ["pm:edit", "pm:update", "pm:remove", "pm:dragstart", "pm:drag", "pm:dragend", "pm:snap", "pm:unsnap", "pm:cut", "pm:intersect", "pm:raiseMarkers", "pm:markerdragend", "pm:markerdragstart", "pm:vertexadded", "pm:vertexremoved", "pm:centerplaced"].forEach(function(n) {
                        t.on(n, e._fireEvent, e)
                    }), t.pm._layerGroup = this._layerGroup
                },
                _fireEvent: function(t) {
                    this._layerGroup.fireEvent(t.type, t)
                },
                toggleEdit: function(t) {
                    this._options = t, this._layers.forEach(function(e) {
                        e.pm.toggleEdit(t)
                    })
                },
                enable: function(t) {
                    this._options = t, this._layers.forEach(function(e) {
                        e.pm.enable(t)
                    })
                },
                disable: function() {
                    this._layers.forEach(function(t) {
                        t.pm.disable()
                    })
                },
                enabled: function() {
                    return !!this._layers.find(function(t) {
                        return t.pm.enabled()
                    })
                },
                dragging: function() {
                    return !!this._layers.find(function(t) {
                        return t.pm.dragging()
                    })
                },
                getOptions: function() {
                    return this._options
                }
            })
        },
        function(t, e, n) {
            var i, o = (i = n(1)) && i.__esModule ? i : {
                default: i
            };
            o.default.Marker = o.default.extend({
                initialize: function(t) {
                    this._layer = t, this._enabled = !1, this._layer.on("dragend", this._onDragEnd, this)
                },
                toggleEdit: function(t) {
                    this.enabled() ? this.disable() : this.enable(t)
                },
                enable: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                        draggable: !0,
                        snappable: !0
                    };
                    this.options = t, this._map = this._layer._map, this.enabled() || (this._enabled = !0, this.options.preventMarkerRemoval || this._layer.on("contextmenu", this._removeMarker, this), this.options.draggable && this._layer.dragging.enable(), this.options.snappable && this._initSnappableMarkers())
                },
                enabled: function() {
                    return this._enabled
                },
                disable: function() {
                    this._enabled = !1, this._layer.dragging.disable(), this._layer.off("contextmenu", this._removeMarker, this), this._layerEdited && this._layer.fire("pm:update", {}), this._layerEdited = !1
                },
                _removeMarker: function(t) {
                    var e = t.target;
                    e.remove(), e.fire("pm:remove")
                },
                _onDragEnd: function(t) {
                    t.target.fire("pm:edit"), this._layerEdited = !0
                },
                _initSnappableMarkers: function() {
                    var t = this._layer;
                    this.options.snapDistance = this.options.snapDistance || 30, t.off("drag", this._handleSnapping, this), t.on("drag", this._handleSnapping, this), t.off("dragend", this._cleanupSnapping, this), t.on("dragend", this._cleanupSnapping, this), t.off("pm:dragstart", this._unsnap, this), t.on("pm:dragstart", this._unsnap, this)
                }
            })
        },
        function(t, e, n) {
            function i(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }
            var o = i(n(4)),
                r = i(n(1));
            r.default.Line = r.default.extend({
                initialize: function(t) {
                    this._layer = t, this._enabled = !1
                },
                toggleEdit: function(t) {
                    this.enabled() ? this.disable() : this.enable(t)
                },
                enable: function(t) {
                    L.Util.setOptions(this, t), this._map = this._layer._map, this._map && (this.enabled() || this.disable(), this._enabled = !0, this._initMarkers(), this._layer.on("remove", this._onLayerRemove, this), this.options.allowSelfIntersection || this._layer.on("pm:vertexremoved", this._handleSelfIntersectionOnVertexRemoval, this), this.options.draggable && this._initDraggableLayer(), this.options.allowSelfIntersection || this._handleLayerStyle())
                },
                _onLayerRemove: function(t) {
                    this.disable(t.target)
                },
                enabled: function() {
                    return this._enabled
                },
                disable: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._layer;
                    if (!this.enabled()) return !1;
                    if (t.pm._dragging) return !1;
                    t.pm._enabled = !1, t.pm._markerGroup.clearLayers(), t.off("mousedown"), t.off("mouseup"), this._layer.off("remove", this._onLayerRemove), this.options.allowSelfIntersection || this._layer.off("pm:vertexremoved", this._handleSelfIntersectionOnVertexRemoval);
                    var e = t._path ? t._path : this._layer._renderer._container;
                    return L.DomUtil.removeClass(e, "leaflet-pm-draggable"), this.hasSelfIntersection() && L.DomUtil.removeClass(e, "leaflet-pm-invalid"), this._layerEdited && this._layer.fire("pm:update", {}), this._layerEdited = !1, !0
                },
                hasSelfIntersection: function() {
                    return (0, o.default)(this._layer.toGeoJSON()).features.length > 0
                },
                _handleSelfIntersectionOnVertexRemoval: function() {
                    this._handleLayerStyle(!0), this.hasSelfIntersection() && (this._layer.setLatLngs(this._coordsBeforeEdit), this._coordsBeforeEdit = null, this._initMarkers())
                },
                _handleLayerStyle: function(t) {
                    var e = this._layer._path ? this._layer._path : this._layer._renderer._container;
                    if (this.hasSelfIntersection()) {
                        if (L.DomUtil.hasClass(e, "leaflet-pm-invalid")) return;
                        t ? (L.DomUtil.addClass(e, "leaflet-pm-invalid"), window.setTimeout(function() {
                            L.DomUtil.removeClass(e, "leaflet-pm-invalid")
                        }, 200)) : L.DomUtil.addClass(e, "leaflet-pm-invalid"), this._layer.fire("pm:intersect", {
                            intersection: (0, o.default)(this._layer.toGeoJSON())
                        })
                    } else L.DomUtil.removeClass(e, "leaflet-pm-invalid")
                },
                _initMarkers: function() {
                    var t = this,
                        e = this._map,
                        n = this._layer.getLatLngs();
                    this._markerGroup && this._markerGroup.clearLayers(), this._markerGroup = new L.LayerGroup, this._markerGroup._pmTempLayer = !0, e.addLayer(this._markerGroup);
                    var i = function(e) {
                        var n = e.map(t._createMarker, t);
                        return e.map(function(i, o) {
                            var r;
                            return r = t.isPolygon() ? (o + 1) % e.length : o + 1, t._createMiddleMarker(n[o], n[r])
                        }), n
                    };
                    this._markers = [], this.isPolygon() ? this._markers = n.map(i, this) : this._markers = i(n), this.options.snappable && this._initSnappableMarkers()
                },
                _createMarker: function(t) {
                    var e = new L.Marker(t, {
                        draggable: !this.options.preventVertexEdit,
                        icon: L.divIcon({
                            className: "marker-icon"
                        })
                    });
                    return e._pmTempLayer = !0, e.on("dragstart", this._onMarkerDragStart, this), e.on("move", this._onMarkerDrag, this), e.on("dragend", this._onMarkerDragEnd, this), this.options.preventMarkerRemoval || e.on("contextmenu", this._removeMarker, this), this._markerGroup.addLayer(e), e
                },
                _createMiddleMarker: function(t, e) {
                    var n = this;
                    if (!t || !e) return !1;
                    var i = this._calcMiddleLatLng(t.getLatLng(), e.getLatLng()),
                        o = this._createMarker(i),
                        r = L.divIcon({
                            className: "marker-icon marker-icon-middle"
                        });
                    return o.setIcon(r), t._middleMarkerNext = o, e._middleMarkerPrev = o, o.on("click", function() {
                        var i = L.divIcon({
                            className: "marker-icon"
                        });
                        o.setIcon(i), n._addMarker(o, t, e)
                    }), o.on("movestart", function() {
                        o.on("moveend", function() {
                            var t = L.divIcon({
                                className: "marker-icon"
                            });
                            o.setIcon(t), o.off("moveend")
                        }), n._addMarker(o, t, e)
                    }), o
                },
                _addMarker: function(t, e, n) {
                    t.off("movestart"), t.off("click");
                    var i = t.getLatLng(),
                        o = this._layer._latlngs,
                        r = this.findMarkerIndex(this._markers, n),
                        s = r.ringIndex,
                        a = r.index,
                        h = s > -1 ? o[s] : o,
                        u = s > -1 ? this._markers[s] : this._markers;
                    h.splice(a, 0, i), u.splice(a, 0, t), this._layer.setLatLngs(o), this._createMiddleMarker(e, t), this._createMiddleMarker(t, n), this._fireEdit(), this._layer.fire("pm:vertexadded", {
                        layer: this._layer,
                        marker: t,
                        index: a,
                        ringIndex: s
                    }), this.options.snappable && this._initSnappableMarkers()
                },
                _removeMarker: function(t) {
                    if (!this.options.allowSelfIntersection) {
                        var e = this._layer.getLatLngs();
                        this._coordsBeforeEdit = JSON.parse(JSON.stringify(e))
                    }
                    var n = t.target,
                        i = this._layer.getLatLngs(),
                        o = this.findMarkerIndex(this._markers, n),
                        r = o.ringIndex,
                        s = o.index,
                        a = r > -1 ? i[r] : i,
                        h = r > -1 ? this._markers[r] : this._markers;
                    if (-1 !== this.findMarkerIndex(this._markers, n).index) {
                        var u, l;
                        if (a.splice(s, 1), this._layer.setLatLngs(i), a.length <= 1 && (i.splice(r, 1), this._layer.setLatLngs(i), this.disable(), this.enable(this.options)), i.length < 1 && this._layer.remove(), n._middleMarkerPrev && this._markerGroup.removeLayer(n._middleMarkerPrev), n._middleMarkerNext && this._markerGroup.removeLayer(n._middleMarkerNext), this._markerGroup.removeLayer(n), this.isPolygon() ? (u = (s + 1) % h.length, l = (s + (h.length - 1)) % h.length) : (l = s - 1 < 0 ? void 0 : s - 1, u = s + 1 >= h.length ? void 0 : s + 1), u !== l) {
                            var c = h[l],
                                p = h[u];
                            this._createMiddleMarker(c, p)
                        }
                        h.splice(s, 1), this._fireEdit(), this._layer.fire("pm:vertexremoved", {
                            layer: this._layer,
                            marker: n,
                            index: s,
                            ringIndex: r
                        })
                    }
                },
                findMarkerIndex: function(t, e) {
                    var n, i;
                    return this.isPolygon() ? i = t.findIndex(function(t) {
                        return (n = t.findIndex(function(t) {
                            return e._leaflet_id === t._leaflet_id
                        })) > -1
                    }) : n = t.findIndex(function(t) {
                        return e._leaflet_id === t._leaflet_id
                    }), {
                        index: n,
                        ringIndex: i
                    }
                },
                updatePolygonCoordsFromMarkerDrag: function(t) {
                    var e = this._layer.getLatLngs(),
                        n = this.findMarkerIndex(this._markers, t),
                        i = n.ringIndex,
                        o = n.index;
                    (i > -1 ? e[i] : e).splice(o, 1, t.getLatLng()), this._layer.setLatLngs(e).redraw()
                },
                _onMarkerDrag: function(t) {
                    var e = t.target;
                    if (-1 !== this.findMarkerIndex(this._markers, e).index) {
                        this.updatePolygonCoordsFromMarkerDrag(e);
                        var n = this.findMarkerIndex(this._markers, e),
                            i = n.ringIndex,
                            o = n.index,
                            r = i > -1 ? this._markers[i] : this._markers,
                            s = (o + 1) % r.length,
                            a = (o + r.length - 1) % r.length,
                            h = e.getLatLng(),
                            u = r[a].getLatLng(),
                            l = r[s].getLatLng();
                        if (e._middleMarkerNext) {
                            var c = this._calcMiddleLatLng(h, l);
                            e._middleMarkerNext.setLatLng(c)
                        }
                        if (e._middleMarkerPrev) {
                            var p = this._calcMiddleLatLng(h, u);
                            e._middleMarkerPrev.setLatLng(p)
                        }
                        this.options.allowSelfIntersection || this._handleLayerStyle()
                    }
                },
                _onMarkerDragEnd: function(t) {
                    var e = t.target,
                        n = this.findMarkerIndex(this._markers, e),
                        i = n.ringIndex,
                        o = n.index;
                    if (!this.options.allowSelfIntersection && this.hasSelfIntersection()) return this._layer.setLatLngs(this._coordsBeforeEdit), this._coordsBeforeEdit = null, this._initMarkers(), void this._handleLayerStyle();
                    this._layer.fire("pm:markerdragend", {
                        markerEvent: t,
                        ringIndex: i,
                        index: o
                    }), this._fireEdit()
                },
                _onMarkerDragStart: function(t) {
                    var e = t.target,
                        n = this.findMarkerIndex(this._markers, e),
                        i = n.ringIndex,
                        o = n.index;
                    this._layer.fire("pm:markerdragstart", {
                        markerEvent: t,
                        ringIndex: i,
                        index: o
                    }), this.options.allowSelfIntersection || (this._coordsBeforeEdit = this._layer.getLatLngs())
                },
                _fireEdit: function() {
                    this._layerEdited = !0, this._layer.fire("pm:edit")
                },
                _calcMiddleLatLng: function(t, e) {
                    var n = this._map,
                        i = n.project(t),
                        o = n.project(e);
                    return n.unproject(i._add(o)._divideBy(2))
                }
            })
        },
        function(t, e, n) {
            var i, o = (i = n(1)) && i.__esModule ? i : {
                default: i
            };
            o.default.Poly = o.default.Line.extend({})
        },
        function(t, e, n) {
            var i, o = (i = n(1)) && i.__esModule ? i : {
                default: i
            };
            o.default.Rectangle = o.default.Poly.extend({
                _initMarkers: function() {
                    var t = this._map,
                        e = this._findCorners();
                    this._markerGroup && this._markerGroup.clearLayers(), this._markerGroup = new L.LayerGroup, this._markerGroup._pmTempLayer = !0, t.addLayer(this._markerGroup), this._markers = [], this._markers[0] = e.map(this._createMarker, this), this._cornerMarkers = this._markers[0], this.options.snappable && this._initSnappableMarkers()
                },
                _createMarker: function(t, e) {
                    var n = new L.Marker(t, {
                        draggable: !this.options.preventVertexEdit,
                        icon: L.divIcon({
                            className: "marker-icon"
                        })
                    });
                    return n._origLatLng = t, n._index = e, n._pmTempLayer = !0, n.on("dragstart", this._onMarkerDragStart, this), n.on("drag", this._onMarkerDrag, this), n.on("dragend", this._onMarkerDragEnd, this), n.on("pm:snap", this._adjustRectangleForMarkerSnap, this), this.options.preventMarkerRemoval || n.on("contextmenu", this._removeMarker, this), this._markerGroup.addLayer(n), n
                },
                _removeMarker: function() {
                    return null
                },
                _onMarkerDragStart: function(t) {
                    var e = t.target,
                        n = this._findCorners();
                    e._oppositeCornerLatLng = n[(e._index + 2) % 4], e._snapped = !1, this._layer.fire("pm:markerdragstart", {
                        markerEvent: t
                    })
                },
                _onMarkerDrag: function(t) {
                    var e = t.target;
                    void 0 !== e._index && (e._snapped || this._adjustRectangleForMarkerMove(e))
                },
                _onMarkerDragEnd: function(t) {
                    var e = this._findCorners();
                    this._adjustAllMarkers(e), this._cornerMarkers.forEach(function(t) {
                        delete t._oppositeCornerLatLng
                    }), this._layer.setLatLngs(e), this._layer.redraw(), this._layer.fire("pm:markerdragend", {
                        markerEvent: t
                    }), this._fireEdit()
                },
                _adjustRectangleForMarkerMove: function(t) {
                    L.extend(t._origLatLng, t._latlng);
                    var e = t.getLatLng();
                    this._layer.setBounds(L.latLngBounds(e, t._oppositeCornerLatLng)), this._adjustAdjacentMarkers(t), this._layer.redraw()
                },
                _adjustRectangleForMarkerSnap: function(t) {
                    if (this.options.snappable) {
                        var e = t.target;
                        this._adjustRectangleForMarkerMove(e)
                    }
                },
                _adjustAllMarkers: function(t) {
                    t.length && 4 == t.length ? this._cornerMarkers.forEach(function(e, n) {
                        e.setLatLng(t[n])
                    }) : console.error("_adjustAllMarkers() requires an array of EXACTLY 4 LatLng coordinates")
                },
                _adjustAdjacentMarkers: function(t) {
                    if (t && t.getLatLng && t._oppositeCornerLatLng) {
                        var e = t.getLatLng(),
                            n = t._oppositeCornerLatLng,
                            i = [];
                        this._findCorners().forEach(function(t) {
                            t.equals(e) || t.equals(n) || i.push(t)
                        });
                        var o = 0;
                        2 == i.length && this._cornerMarkers.forEach(function(t) {
                            var r = t.getLatLng();
                            r.equals(e) || r.equals(n) || (t.setLatLng(i[o]), o += 1)
                        })
                    } else console.error("_adjustAdjacentMarkers() requires a valid Marker object")
                },
                _findCorners: function() {
                    var t = this._layer.getBounds();
                    return [t.getNorthWest(), t.getNorthEast(), t.getSouthEast(), t.getSouthWest()]
                }
            })
        },
        function(t, e, n) {
            var i, o = (i = n(1)) && i.__esModule ? i : {
                default: i
            };
            o.default.Circle = o.default.extend({
                initialize: function(t) {
                    this._layer = t, this._enabled = !1
                },
                toggleEdit: function(t) {
                    this.enabled() ? this.disable() : this.enable(t)
                },
                enabled: function() {
                    return this._enabled
                },
                enable: function(t) {
                    var e = this;
                    L.Util.setOptions(this, t), this._map = this._layer._map, this.enabled() || this.disable(), this._enabled = !0, this._initMarkers(), this._layer.on("remove", function(t) {
                        e.disable(t.target)
                    })
                },
                disable: function() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._layer;
                    if (!this.enabled()) return !1;
                    if (t.pm._dragging) return !1;
                    t.pm._enabled = !1, t.pm._layerGroup.clearLayers(), t.off("mousedown"), t.off("mouseup");
                    var e = t._path;
                    return L.DomUtil.removeClass(e, "leaflet-pm-draggable"), this._layerEdited && this._layer.fire("pm:update", {}), this._layerEdited = !1, !0
                },
                _initMarkers: function() {
                    var t = this._map;
                    this._layerGroup && this._layerGroup.clearLayers(), this._layerGroup = new L.LayerGroup, t.addLayer(this._layerGroup);
                    var e = this._layer.getLatLng(),
                        n = this._layer._radius,
                        i = this._getLatLngOnCircle(e, n);
                    this._centerMarker = this._createCenterMarker(e), this._outerMarker = this._createOuterMarker(i), this._markers = [this._centerMarker, this._outerMarker], this._createHintLine(this._centerMarker, this._outerMarker), this.options.snappable && this._initSnappableMarkers()
                },
                _getLatLngOnCircle: function(t, e) {
                    var n = this._map.project(t),
                        i = L.point(n.x + e, n.y);
                    return this._map.unproject(i)
                },
                _resizeCircle: function() {
                    this._syncHintLine(), this._syncCircleRadius()
                },
                _moveCircle: function(t) {
                    var e = t.latlng;
                    this._layer.setLatLng(e);
                    var n = this._layer._radius,
                        i = this._getLatLngOnCircle(e, n);
                    this._outerMarker.setLatLng(i), this._syncHintLine(), this._layer.fire("pm:centerplaced", {
                        layer: this._layer,
                        latlng: e
                    })
                },
                _onMarkerDragStart: function(t) {
                    this._layer.fire("pm:markerdragstart", {
                        markerEvent: t
                    })
                },
                _onMarkerDragEnd: function(t) {
                    this._fireEdit(), this._layer.fire("pm:markerdragend", {
                        markerEvent: t
                    })
                },
                _syncCircleRadius: function() {
                    var t = this._centerMarker.getLatLng(),
                        e = this._outerMarker.getLatLng(),
                        n = t.distanceTo(e);
                    this._layer.setRadius(n)
                },
                _syncHintLine: function() {
                    var t = this._centerMarker.getLatLng(),
                        e = this._outerMarker.getLatLng();
                    this._hintline.setLatLngs([t, e])
                },
                _createHintLine: function(t, e) {
                    var n = t.getLatLng(),
                        i = e.getLatLng();
                    this._hintline = L.polyline([n, i], this.options.hintlineStyle), this._hintline._pmTempLayer = !0, this._layerGroup.addLayer(this._hintline)
                },
                _createCenterMarker: function(t) {
                    var e = this._createMarker(t);
                    return e.on("move", this._moveCircle, this), e
                },
                _createOuterMarker: function(t) {
                    var e = this._createMarker(t);
                    return this.options.preventVertexEdit && e.dragging.disable(), e.on("move", this._resizeCircle, this), e
                },
                _createMarker: function(t) {
                    var e = new L.Marker(t, {
                        draggable: !0,
                        icon: L.divIcon({
                            className: "marker-icon"
                        })
                    });
                    return e._origLatLng = t, e._pmTempLayer = !0, e.on("dragstart", this._onMarkerDragStart, this), e.on("dragend", this._onMarkerDragEnd, this), this._layerGroup.addLayer(e), e
                },
                _fireEdit: function() {
                    this._layer.fire("pm:edit"), this._layerEdited = !0
                }
            })
        },
        function(t, e) {},
        function(t, e) {}
    ]),
    function(t, e, n) {
        e.h337 = function() {
            var t = {
                    defaultRadius: 40,
                    defaultRenderer: "canvas2d",
                    defaultGradient: {.25: "rgb(0,0,255)", .55: "rgb(0,255,0)", .85: "yellow", 1: "rgb(255,0,0)"
                    },
                    defaultMaxOpacity: 1,
                    defaultMinOpacity: 0,
                    defaultBlur: .85,
                    defaultXField: "x",
                    defaultYField: "y",
                    defaultValueField: "value",
                    plugins: {}
                },
                e = function() {
                    var e = function(t) {
                            this._coordinator = {}, this._data = [], this._radi = [], this._min = 0, this._max = 1, this._xField = t.xField || t.defaultXField, this._yField = t.yField || t.defaultYField, this._valueField = t.valueField || t.defaultValueField, t.radius && (this._cfgRadius = t.radius)
                        },
                        n = t.defaultRadius;
                    return e.prototype = {
                        _organiseData: function(t, e) {
                            var i = t[this._xField],
                                o = t[this._yField],
                                r = this._radi,
                                s = this._data,
                                a = this._max,
                                h = this._min,
                                u = t[this._valueField] || 1,
                                l = t.radius || this._cfgRadius || n;
                            return s[i] || (s[i] = [], r[i] = []), s[i][o] ? s[i][o] += u : (s[i][o] = u, r[i][o] = l), s[i][o] > a ? (e ? this.setDataMax(s[i][o]) : this._max = s[i][o], !1) : {
                                x: i,
                                y: o,
                                value: u,
                                radius: l,
                                min: h,
                                max: a
                            }
                        },
                        _unOrganizeData: function() {
                            var t = [],
                                e = this._data,
                                n = this._radi;
                            for (var i in e)
                                for (var o in e[i]) t.push({
                                    x: i,
                                    y: o,
                                    radius: n[i][o],
                                    value: e[i][o]
                                });
                            return {
                                min: this._min,
                                max: this._max,
                                data: t
                            }
                        },
                        _onExtremaChange: function() {
                            this._coordinator.emit("extremachange", {
                                min: this._min,
                                max: this._max
                            })
                        },
                        addData: function() {
                            if (arguments[0].length > 0)
                                for (var t = arguments[0], e = t.length; e--;) this.addData.call(this, t[e]);
                            else {
                                var n = this._organiseData(arguments[0], !0);
                                n && this._coordinator.emit("renderpartial", {
                                    min: this._min,
                                    max: this._max,
                                    data: [n]
                                })
                            }
                            return this
                        },
                        setData: function(t) {
                            var e = t.data,
                                n = e.length;
                            this._data = [], this._radi = [];
                            for (var i = 0; i < n; i++) this._organiseData(e[i], !1);
                            return this._max = t.max, this._min = t.min || 0, this._onExtremaChange(), this._coordinator.emit("renderall", this._getInternalData()), this
                        },
                        removeData: function() {},
                        setDataMax: function(t) {
                            return this._max = t, this._onExtremaChange(), this._coordinator.emit("renderall", this._getInternalData()), this
                        },
                        setDataMin: function(t) {
                            return this._min = t, this._onExtremaChange(), this._coordinator.emit("renderall", this._getInternalData()), this
                        },
                        setCoordinator: function(t) {
                            this._coordinator = t
                        },
                        _getInternalData: function() {
                            return {
                                max: this._max,
                                min: this._min,
                                data: this._data,
                                radi: this._radi
                            }
                        },
                        getData: function() {
                            return this._unOrganizeData()
                        }
                    }, e
                }(),
                n = function() {
                    function t(t) {
                        var n = t.container,
                            i = this.shadowCanvas = document.createElement("canvas"),
                            o = this.canvas = t.canvas || document.createElement("canvas"),
                            r = (this._renderBoundaries = [1e4, 1e4, 0, 0], getComputedStyle(t.container) || {});
                        o.className = "heatmap-canvas", this._width = o.width = i.width = +r.width.replace(/px/, ""), this._height = o.height = i.height = +r.height.replace(/px/, ""), this.shadowCtx = i.getContext("2d"), this.ctx = o.getContext("2d"), o.style.cssText = i.style.cssText = "position:absolute;left:0;top:0;", n.style.position = "relative", n.appendChild(o), this._palette = e(t), this._templates = {}, this._setStyles(t)
                    }
                    var e = function(t) {
                            var e = t.gradient || t.defaultGradient,
                                n = document.createElement("canvas"),
                                i = n.getContext("2d");
                            n.width = 256, n.height = 1;
                            var o = i.createLinearGradient(0, 0, 256, 1);
                            for (var r in e) o.addColorStop(r, e[r]);
                            return i.fillStyle = o, i.fillRect(0, 0, 256, 1), i.getImageData(0, 0, 256, 1).data
                        },
                        n = function(t, e) {
                            var n = document.createElement("canvas"),
                                i = n.getContext("2d"),
                                o = t,
                                r = t;
                            if (n.width = n.height = 2 * t, 1 == e) i.beginPath(), i.arc(o, r, t, 0, 2 * Math.PI, !1), i.fillStyle = "rgba(0,0,0,1)", i.fill();
                            else {
                                var s = i.createRadialGradient(o, r, t * e, o, r, t);
                                s.addColorStop(0, "rgba(0,0,0,1)"), s.addColorStop(1, "rgba(0,0,0,0)"), i.fillStyle = s, i.fillRect(0, 0, 2 * t, 2 * t)
                            }
                            return n
                        },
                        i = function(t) {
                            for (var e = [], n = t.min, i = t.max, o = t.radi, t = t.data, r = Object.keys(t), s = r.length; s--;)
                                for (var a = r[s], h = Object.keys(t[a]), u = h.length; u--;) {
                                    var l = h[u],
                                        c = t[a][l],
                                        p = o[a][l];
                                    e.push({
                                        x: a,
                                        y: l,
                                        value: c,
                                        radius: p
                                    })
                                }
                            return {
                                min: n,
                                max: i,
                                data: e
                            }
                        };
                    return t.prototype = {
                        renderPartial: function(t) {
                            this._drawAlpha(t), this._colorize()
                        },
                        renderAll: function(t) {
                            this._clear(), this._drawAlpha(i(t)), this._colorize()
                        },
                        _updateGradient: function(t) {
                            this._palette = e(t)
                        },
                        updateConfig: function(t) {
                            t.gradient && this._updateGradient(t), this._setStyles(t)
                        },
                        setDimensions: function(t, e) {
                            this._width = t, this._height = e, this.canvas.width = this.shadowCanvas.width = t, this.canvas.height = this.shadowCanvas.height = e
                        },
                        _clear: function() {
                            this.shadowCtx.clearRect(0, 0, this._width, this._height), this.ctx.clearRect(0, 0, this._width, this._height)
                        },
                        _setStyles: function(t) {
                            this._blur = 0 == t.blur ? 0 : t.blur || t.defaultBlur, t.backgroundColor && (this.canvas.style.backgroundColor = t.backgroundColor), this._opacity = 255 * (t.opacity || 0), this._maxOpacity = 255 * (t.maxOpacity || t.defaultMaxOpacity), this._minOpacity = 255 * (t.minOpacity || t.defaultMinOpacity), this._useGradientOpacity = !!t.useGradientOpacity
                        },
                        _drawAlpha: function(t) {
                            for (var e = this._min = t.min, i = this._max = t.max, t = t.data || [], o = t.length, r = 1 - this._blur; o--;) {
                                var s, a = t[o],
                                    h = a.x,
                                    u = a.y,
                                    l = a.radius,
                                    c = Math.min(a.value, i),
                                    p = h - l,
                                    f = u - l,
                                    d = this.shadowCtx;
                                this._templates[l] ? s = this._templates[l] : this._templates[l] = s = n(l, r), d.globalAlpha = (c - e) / (i - e), d.drawImage(s, p, f), p < this._renderBoundaries[0] && (this._renderBoundaries[0] = p), f < this._renderBoundaries[1] && (this._renderBoundaries[1] = f), p + 2 * l > this._renderBoundaries[2] && (this._renderBoundaries[2] = p + 2 * l), f + 2 * l > this._renderBoundaries[3] && (this._renderBoundaries[3] = f + 2 * l)
                            }
                        },
                        _colorize: function() {
                            var t = this._renderBoundaries[0],
                                e = this._renderBoundaries[1],
                                n = this._renderBoundaries[2] - t,
                                i = this._renderBoundaries[3] - e,
                                o = this._width,
                                r = this._height,
                                s = this._opacity,
                                a = this._maxOpacity,
                                h = this._minOpacity,
                                u = this._useGradientOpacity;
                            t < 0 && (t = 0), e < 0 && (e = 0), t + n > o && (n = o - t), e + i > r && (i = r - e);
                            for (var l = this.shadowCtx.getImageData(t, e, n, i), c = l.data, p = c.length, f = this._palette, d = 3; d < p; d += 4) {
                                var _ = c[d],
                                    g = 4 * _;
                                if (g) {
                                    var m;
                                    m = s > 0 ? s : _ < a ? _ < h ? h : _ : a, c[d - 3] = f[g], c[d - 2] = f[g + 1], c[d - 1] = f[g + 2], c[d] = u ? f[g + 3] : m
                                }
                            }
                            this.ctx.putImageData(l, t, e), this._renderBoundaries = [1e3, 1e3, 0, 0]
                        },
                        getValueAt: function(t) {
                            var e = this.shadowCtx,
                                n = e.getImageData(t.x, t.y, 1, 1),
                                i = n.data[3],
                                o = this._max,
                                r = this._min;
                            return Math.abs(o - r) * (i / 255) >> 0
                        },
                        getDataURL: function() {
                            return this.canvas.toDataURL()
                        }
                    }, t
                }(),
                i = function() {
                    var e = !1;
                    return "canvas2d" === t.defaultRenderer && (e = n), e
                }(),
                o = {
                    merge: function() {
                        for (var t = {}, e = arguments.length, n = 0; n < e; n++) {
                            var i = arguments[n];
                            for (var o in i) t[o] = i[o]
                        }
                        return t
                    }
                },
                r = function() {
                    function n() {
                        var n = this._config = o.merge(t, arguments[0] || {});
                        if (this._coordinator = new r, n.plugin) {
                            var a = n.plugin;
                            if (!t.plugins[a]) throw new Error("Plugin '" + a + "' not found. Maybe it was not registered.");
                            var h = t.plugins[a];
                            this._renderer = new h.renderer(n), this._store = new h.store(n)
                        } else this._renderer = new i(n), this._store = new e(n);
                        s(this)
                    }
                    var r = function() {
                            function t() {
                                this.cStore = {}
                            }
                            return t.prototype = {
                                on: function(t, e, n) {
                                    var i = this.cStore;
                                    i[t] || (i[t] = []), i[t].push(function(t) {
                                        return e.call(n, t)
                                    })
                                },
                                emit: function(t, e) {
                                    var n = this.cStore;
                                    if (n[t])
                                        for (var i = n[t].length, o = 0; o < i; o++) {
                                            var r = n[t][o];
                                            r(e)
                                        }
                                }
                            }, t
                        }(),
                        s = function(t) {
                            var e = t._renderer,
                                n = t._coordinator,
                                i = t._store;
                            n.on("renderpartial", e.renderPartial, e), n.on("renderall", e.renderAll, e), n.on("extremachange", function(e) {
                                t._config.onExtremaChange && t._config.onExtremaChange({
                                    min: e.min,
                                    max: e.max,
                                    gradient: t._config.gradient || t._config.defaultGradient
                                })
                            }), i.setCoordinator(n)
                        };
                    return n.prototype = {
                        addData: function() {
                            return this._store.addData.apply(this._store, arguments), this
                        },
                        removeData: function() {
                            return this._store.removeData && this._store.removeData.apply(this._store, arguments), this
                        },
                        setData: function() {
                            return this._store.setData.apply(this._store, arguments), this
                        },
                        setDataMax: function() {
                            return this._store.setDataMax.apply(this._store, arguments), this
                        },
                        setDataMin: function() {
                            return this._store.setDataMin.apply(this._store, arguments), this
                        },
                        configure: function(t) {
                            return this._config = o.merge(this._config, t), this._renderer.updateConfig(this._config), this._coordinator.emit("renderall", this._store._getInternalData()), this
                        },
                        repaint: function() {
                            return this._coordinator.emit("renderall", this._store._getInternalData()), this
                        },
                        getData: function() {
                            return this._store.getData()
                        },
                        getDataURL: function() {
                            return this._renderer.getDataURL()
                        },
                        getValueAt: function(t) {
                            return this._store.getValueAt ? this._store.getValueAt(t) : this._renderer.getValueAt ? this._renderer.getValueAt(t) : null
                        }
                    }, n
                }();
            return {
                create: function(t) {
                    return new r(t)
                },
                register: function(e, n) {
                    t.plugins[e] = n
                }
            }
        }()
    }(0, e),
    function(t, e, n) {
        e.HeatmapOverlay = function() {
            void 0 === L.Layer && (L.Layer = L.Class);
            var t = L.Layer.extend({
                initialize: function(t) {
                    this.cfg = t, this._el = L.DomUtil.create("div", "leaflet-zoom-hide"), this._data = [], this._max = 1, this._min = 0, this.cfg.container = this._el
                },
                onAdd: function(t) {
                    var e = t.getSize();
                    this._map = t, this._width = e.x, this._height = e.y, this._el.style.width = e.x + "px", this._el.style.height = e.y + "px", this._el.style.position = "absolute", this._resetOrigin(), t.getPanes().overlayPane.appendChild(this._el), this._heatmap || (this._heatmap = h337.create(this.cfg)), t.on("viewreset", this._resetOrigin, this), t.on("moveend", this._draw, this), this._draw()
                },
                onRemove: function(t) {
                    t.getPanes().overlayPane.removeChild(this._el), t.off("viewreset", this._resetOrigin, this), t.off("dragend", this._draw, this)
                },
                _draw: function() {
                    if (this._map) {
                        var e = this._map.getPanes().mapPane,
                            n = e._leaflet_pos;
                        this._el.style[t.CSS_TRANSFORM] = "translate(" + -Math.round(n.x) + "px," + -Math.round(n.y) + "px)", this._update()
                    }
                },
                _update: function() {
                    var t, e, n, i = {
                        max: this._max,
                        min: this._min,
                        data: []
                    };
                    if (t = this._map.getBounds(), e = this._map.getZoom(), n = Math.pow(2, e), 0 == this._data.length) return void(this._heatmap && this._heatmap.setData(i));
                    for (var o = [], r = this.cfg.scaleRadius ? n : 1, s = 0, a = 0, h = this.cfg.valueField, u = this._data.length; u--;) {
                        var l = this._data[u],
                            c = l[h],
                            p = l.latlng;
                        if (t.contains(p)) {
                            s = Math.max(c, s), a = Math.min(c, a);
                            var f = this._map.latLngToContainerPoint(p),
                                d = {
                                    x: Math.round(f.x),
                                    y: Math.round(f.y)
                                };
                            d[h] = c;
                            var _;
                            _ = l.radius ? l.radius * r : (this.cfg.radius || 2) * r, d.radius = _, o.push(d)
                        }
                    }
                    this.cfg.useLocalExtrema && (i.max = s, i.min = a), i.data = o, this._heatmap.setData(i)
                },
                setData: function(t) {
                    this._max = t.max || this._max, this._min = t.min || this._min;
                    for (var e = this.cfg.latField || "lat", n = this.cfg.lngField || "lng", i = this.cfg.valueField || "value", t = t.data, o = t.length, r = []; o--;) {
                        var s = t[o],
                            a = new L.LatLng(s[e], s[n]),
                            h = {
                                latlng: a
                            };
                        h[i] = s[i], s.radius && (h.radius = s.radius), r.push(h)
                    }
                    this._data = r, this._draw()
                },
                addData: function(t) {
                    if (t.length > 0)
                        for (var e = t.length; e--;) this.addData(t[e]);
                    else {
                        var n = this.cfg.latField || "lat",
                            i = this.cfg.lngField || "lng",
                            o = this.cfg.valueField || "value",
                            r = t,
                            s = new L.LatLng(r[n], r[i]),
                            a = {
                                latlng: s
                            };
                        a[o] = r[o], this._max = Math.max(this._max, a[o]), this._min = Math.min(this._min, a[o]), r.radius && (a.radius = r.radius), this._data.push(a), this._draw()
                    }
                },
                _resetOrigin: function() {
                    this._origin = this._map.layerPointToLatLng(new L.Point(0, 0)), this._draw()
                }
            });
            return t.CSS_TRANSFORM = function() {
                for (var t = document.createElement("div"), e = ["transform", "WebkitTransform", "MozTransform", "OTransform", "msTransform"], n = 0; n < e.length; n++) {
                    var i = e[n];
                    if (void 0 !== t.style[i]) return i
                }
                return e[0]
            }(), t
        }()
    }(0, e), L.Map.mergeOptions({
        zoomControl: !1,
        attributionControl: !1
    }), L.Map.include({
        getPopup: function() {
            return this._popup
        }
    }), L.Control.Attribution.mergeOptions({
        prefix: "超擎地图"
    }), L.extend(L.Util, {
        clone: function(t) {
            if (!t) return null;
            var e = JSON.stringify(t);
            return JSON.parse(e)
        },
        getAngle: function(t, e, n, i) {
            var o = Math.abs(t - n),
                r = Math.abs(e - i),
                s = Math.sqrt(Math.pow(o, 2) + Math.pow(r, 2)),
                a = r / s,
                h = Math.acos(a),
                u = Math.floor(180 / (Math.PI / h));
            return n > t && i > e && (u = 180 - u), n == t && i > e && (u = 180), n > t && i == e && (u = 90), n < t && i > e && (u = 180 + u), n < t && i == e && (u = 270), n < t && i < e && (u = 360 - u), u
        }
    });
    var o = i.Renderer.extend({
            options: {
                padding: .1,
                width: 0,
                height: 0,
                zIndex: 0
            },
            initialize: function(t) {
                i.Renderer.prototype.initialize.call(this, t), this._initContainer()
            },
            _initContainer: function() {
                this.container = this._container = document.createElement("canvas"), this.container.style.zIndex = this.options.zIndex, this.ctx = this._ctx = this.container.getContext("2d"), i.DomUtil.addClass(this._container, "leaflet-zoom-animated")
            },
            getContainer: function() {
                return this._container
            },
            onAdd: function() {
                this._container || (this._initContainer(), this._zoomAnimated && i.DomUtil.addClass(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this.clear()
            },
            _update: function() {
                var t = this.options.padding,
                    e = this._map.getSize();
                this.options.width && this.options.height && (e.x = this.options.width, e.y = this.options.height);
                var n = this._map.containerPointToLayerPoint(e.multiplyBy(-t)).round();
                this._bounds = new i.Bounds(n, n.add(e.multiplyBy(1 + 2 * t)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom()
            },
            clear: function() {
                if (this._map && (!this._map._animatingZoom || !this._bounds)) {
                    i.Renderer.prototype._update.call(this);
                    var t = this._bounds,
                        e = this._container,
                        n = t.getSize(),
                        o = i.Browser.retina ? 2 : 1;
                    i.DomUtil.setPosition(e, t.min), e.width = o * n.x, e.height = o * n.y, e.style.width = n.x + "px", e.style.height = n.y + "px", i.Browser.retina && this._ctx.scale(2, 2), this._ctx.translate(-t.min.x, -t.min.y)
                }
            }
        }),
        r = 52.35987755982988,
        s = 3.141592653589793,
        a = 6378245,
        h = .006693421622965943,
        u = function(t, e) {
            var t = +t,
                e = +e,
                n = t - .0065,
                i = e - .006,
                o = Math.sqrt(n * n + i * i) - 2e-5 * Math.sin(i * r),
                s = Math.atan2(i, n) - 3e-6 * Math.cos(n * r);
            return [o * Math.cos(s), o * Math.sin(s)]
        },
        l = function(t, e) {
            var e = +e,
                t = +t,
                n = Math.sqrt(t * t + e * e) + 2e-5 * Math.sin(e * r),
                i = Math.atan2(e, t) + 3e-6 * Math.cos(t * r);
            return [n * Math.cos(i) + .0065, n * Math.sin(i) + .006]
        },
        c = function(t, e) {
            var e = +e,
                t = +t;
            if (_(t, e)) return [t, e];
            var n = f(t - 105, e - 35),
                i = d(t - 105, e - 35),
                o = e / 180 * s,
                r = Math.sin(o);
            r = 1 - h * r * r;
            var u = Math.sqrt(r);
            return n = 180 * n / (a * (1 - h) / (r * u) * s), i = 180 * i / (a / u * Math.cos(o) * s), [t + i, e + n]
        },
        p = function(t, e) {
            var e = +e,
                t = +t;
            if (_(t, e)) return [t, e];
            var n = f(t - 105, e - 35),
                i = d(t - 105, e - 35),
                o = e / 180 * s,
                r = Math.sin(o);
            r = 1 - h * r * r;
            var u = Math.sqrt(r);
            return n = 180 * n / (a * (1 - h) / (r * u) * s), i = 180 * i / (a / u * Math.cos(o) * s), [2 * t - (t + i), 2 * e - (e + n)]
        },
        f = function(t, e) {
            var e = +e,
                t = +t,
                n = 2 * t - 100 + 3 * e + .2 * e * e + .1 * t * e + .2 * Math.sqrt(Math.abs(t));
            return n += 2 * (20 * Math.sin(6 * t * s) + 20 * Math.sin(2 * t * s)) / 3, n += 2 * (20 * Math.sin(e * s) + 40 * Math.sin(e / 3 * s)) / 3, n += 2 * (160 * Math.sin(e / 12 * s) + 320 * Math.sin(e * s / 30)) / 3
        },
        d = function(t, e) {
            var e = +e,
                t = +t,
                n = 300 + t + 2 * e + .1 * t * t + .1 * t * e + .1 * Math.sqrt(Math.abs(t));
            return n += 2 * (20 * Math.sin(6 * t * s) + 20 * Math.sin(2 * t * s)) / 3, n += 2 * (20 * Math.sin(t * s) + 40 * Math.sin(t / 3 * s)) / 3, n += 2 * (150 * Math.sin(t / 12 * s) + 300 * Math.sin(t / 30 * s)) / 3
        },
        _ = function(t, e) {
            var e = +e,
                t = +t;
            return !(t > 73.66 && t < 135.05 && e > 3.86 && e < 53.55)
        },
        g = function t(e) {
            var n = m(e),
                i = 0,
                o = 0;
            if ("array" === n)
                for (i = 0, o = e.length; i < o; i++) t(e[i]);
            else if ("object" === n) {
                for (var r in e) t(e[r]);
                if (e.longitude && e.latitude) {
                    var s = c(e.longitude, e.latitude);
                    e.longitude = s[0], e.latitude = s[1]
                }
            }
        },
        m = function(t) {
            var e = Object.prototype.toString,
                n = {
                    "[object Boolean]": "boolean",
                    "[object Number]": "number",
                    "[object String]": "string",
                    "[object Function]": "function",
                    "[object Array]": "array",
                    "[object Date]": "date",
                    "[object RegExp]": "regExp",
                    "[object Undefined]": "undefined",
                    "[object Null]": "null",
                    "[object Object]": "object"
                };
            return t instanceof Element ? "element" : n[e.call(t)]
        },
        y = {
            bd09togcj02: u,
            gcj02tobd09: l,
            wgs84togcj02: c,
            gcj02towgs84: p,
            transform: g
        },
        v = Object.freeze({
            SeCanvas: o,
            Coordtransform: y
        }),
        x = i.DivOverlay.extend({
            options: {
                latlng: null,
                text: "",
                opacity: 1,
                offset: [8, 0]
            },
            initialize: function(t) {
                i.setOptions(this, t), this.setLatLng(this.options.latlng), this.setContent(this.options.text)
            },
            onAdd: function(t) {
                i.DivOverlay.prototype.onAdd.call(this, t), this.setOpacity(this.options.opacity)
            },
            _initLayout: function() {
                var t = "leaflet-label " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
                this._contentNode = this._container = i.DomUtil.create("div", t)
            },
            _updateLayout: function() {},
            _adjustPan: function() {},
            _setPosition: function(t) {
                var e = i.point(this.options.offset),
                    n = this._getAnchor();
                this._zoomAnimated ? i.DomUtil.setPosition(this._container, t.add(n)) : e = e.add(t).add(n);
                var o = e.y - this._container.clientHeight / 2,
                    r = e.x;
                this._container.style.top = o + "px", this._container.style.left = r + "px"
            },
            _updatePosition: function() {
                var t = this._map.latLngToLayerPoint(this._latlng);
                this._setPosition(t)
            },
            setOpacity: function(t) {
                this.options.opacity = t, this._container && i.DomUtil.setOpacity(this._container, t)
            },
            _animateZoom: function(t) {
                var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center);
                this._setPosition(e)
            }
        }),
        b = i.Evented.extend({
            options: {
                circleMarker: {
                    color: "red",
                    radius: 5,
                    fillColor: "#ffffff",
                    weight: 1,
                    fillOpacity: 1
                },
                lineStyle: {
                    color: "red"
                },
                labelStyle: {
                    offset: [8, 0]
                }
            },
            initialize: function(t, e) {
                i.setOptions(this, e), this._map = t, this._enabled = !1, this._defaultCursor = this._map._container.style.cursor, this._allLayers = new i.LayerGroup, this._map.addLayer(this._allLayers)
            },
            enable: function() {
                this._enabled || (this._enabled = !0, this._map.doubleClickZoom.disable(), this._map._container.style.cursor = "crosshair", this._map.on("click", this._clicked, this), this._map.on("mousemove", this._moving, this), this._map.on("dblclick", this._closePath, this), this._start())
            },
            disable: function() {
                this._enabled && (this._enabled = !1, this._map.doubleClickZoom.enable(), this._map._container.style.cursor = this._defaultCursor, this._map.off("click", this._clicked, this), this._map.off("mousemove", this._moving, this), this._map.off("dblclick", this._closePath, this))
            },
            clear: function() {
                this._allLayers.clearLayers()
            },
            _start: function() {
                this._clickPoints = [], this._tempLayer = null, this._tempLine = null, this._tempLabel = null
            },
            _closePath: function(t) {
                var e = new i.FeatureGroup;
                this._allLayers.addLayer(e), this._drawPath(this._clickPoints, e, !0), this._clearTemp(), this._start(), this.fire("finish")
            },
            _clearTemp: function() {
                this._tempLayer && (this._map.removeLayer(this._tempLayer), this._tempLayer = null), this._tempLine && (this._map.removeLayer(this._tempLine), this._tempLine = null), this._tempLabel && (this._map.removeLayer(this._tempLabel), this._tempLabel = null)
            },
            _clicked: function(t) {
                var e = t.latlng;
                if (this._clickPoints.length > 0) {
                    var n = this._clickPoints[this._clickPoints.length - 1];
                    if (e.equals(n)) return void this._closePath()
                }
                this._clickPoints.push(e), this._drawTempLayer(this._clickPoints)
            },
            _moving: function(t) {
                var e = t.latlng;
                if (this._clickPoints && 0 != this._clickPoints.length) {
                    var n = this._clickPoints[this._clickPoints.length - 1];
                    if (this._tempLine) this._tempLine.setLatLngs([n, e]);
                    else {
                        var o = i.Util.clone(this.options.lineStyle);
                        o.dashArray = [5, 5], this._tempLine = new i.Polyline([n, e], o), this._map.addLayer(this._tempLine)
                    }
                    this._tempLabel ? this._tempLabel.setLatLng(e) : (this._tempLabel = new x({
                        latlng: e,
                        text: "双击结束",
                        offset: [10, 10]
                    }), this._map.addLayer(this._tempLabel))
                }
            },
            _drawTempLayer: function(t) {
                this._tempLayer || (this._tempLayer = new i.FeatureGroup, this._map.addLayer(this._tempLayer)), this._tempLayer.clearLayers(), this._drawPath(t, this._tempLayer)
            },
            _drawPath: function(t, e, n) {
                var o = this;
                if (!t || 0 == t.length) return null;
                var r = t.length;
                if (r > 1) {
                    var s = new i.Polyline(t, this.options.lineStyle);
                    e.addLayer(s)
                }
                for (var a = 0, h = 0; h < r; h++) {
                    var u = t[h],
                        l = new i.CircleMarker(u, this.options.circleMarker);
                    e.addLayer(l);
                    var c = "";
                    if (0 == h && (c = "开始"), h > 0) {
                        var p = t[h - 1];
                        a += this._map.distance(p, u);
                        var f = parseInt(a) / 1e3;
                        if (h == r - 1 && n) {
                            var d = document.createElement("span");
                            d.className = "measure-close",
                                function(t) {
                                    d.onclick = function() {
                                        o._allLayers.removeLayer(t)
                                    }
                                }(e), d.innerHTML = "X", i.DomEvent.disableClickPropagation(d);
                            var c = document.createElement("span");
                            c.innerHTML = "总长：" + f + "公里", c.appendChild(d)
                        } else c = f + "公里"
                    }
                    var _ = i.Util.clone(this.options.labelStyle);
                    _.latlng = u, _.text = c;
                    var g = new x(_);
                    e.addLayer(g)
                }
            }
        }),
        E = i.Evented.extend({
            options: {
                polygonStyle: {
                    color: "red",
                    fillOpacity: .2
                },
                labelStyle: {
                    offset: [8, 0]
                }
            },
            initialize: function(t, e) {
                i.setOptions(this, e), this._map = t, this._enabled = !1, this._defaultCursor = this._map._container.style.cursor, this._allLayers = new i.LayerGroup, this._map.addLayer(this._allLayers)
            },
            enable: function() {
                this._enabled || (this._enabled = !0, this._map.doubleClickZoom.disable(), this._map._container.style.cursor = "crosshair", this._map.on("click", this._clicked, this), this._map.on("mousemove", this._moving, this), this._map.on("dblclick", this._closePath, this), this._start())
            },
            disable: function() {
                this._enabled && (this._enabled = !1, this._map.doubleClickZoom.enable(), this._map._container.style.cursor = this._defaultCursor, this._map.off("click", this._clicked, this), this._map.off("mousemove", this._moving, this), this._map.off("dblclick", this._closePath, this))
            },
            clear: function() {
                this._allLayers.clearLayers()
            },
            _start: function() {
                this._clickPoints = [], this._tempLayer = null, this._tempLines = null, this._tempLabel = null
            },
            _closePath: function(t) {
                var e = new i.FeatureGroup;
                this._allLayers.addLayer(e), this._drawPath(this._clickPoints, e, !0), this._clearTemp(), this._start(), this.fire("finish")
            },
            _clearTemp: function() {
                this._tempLayer && (this._map.removeLayer(this._tempLayer), this._tempLayer = null), this._tempLines && (this._map.removeLayer(this._tempLines), this._tempLines = null), this._tempLabel && (this._map.removeLayer(this._tempLabel), this._tempLabel = null)
            },
            _clicked: function(t) {
                var e = t.latlng;
                if (this._clickPoints.length > 0) {
                    var n = this._clickPoints[this._clickPoints.length - 1];
                    if (e.equals(n)) return void this._closePath()
                }
                this._clickPoints.push(e), this._drawTempLayer(this._clickPoints)
            },
            _moving: function(t) {
                var e = t.latlng;
                if (this._clickPoints && 0 != this._clickPoints.length) {
                    this._tempLines || (this._tempLines = new i.FeatureGroup, this._map.addLayer(this._tempLines)), this._tempLines.clearLayers();
                    var n = this._clickPoints.length,
                        o = this._clickPoints[0],
                        r = i.Util.clone(this.options.polygonStyle);
                    r.dashArray = [5, 5];
                    var s = new i.Polyline([o, e], r);
                    if (this._tempLines.addLayer(s), n >= 2) {
                        var a = this._clickPoints[n - 1],
                            h = new i.Polyline([a, e], r);
                        this._tempLines.addLayer(h)
                    }
                    this._tempLabel ? this._tempLabel.setLatLng(e) : (this._tempLabel = new x({
                        latlng: e,
                        text: "双击结束",
                        offset: [10, 10]
                    }), this._map.addLayer(this._tempLabel))
                }
            },
            _drawTempLayer: function(t) {
                this._tempLayer || (this._tempLayer = new i.FeatureGroup, this._map.addLayer(this._tempLayer)), this._tempLayer.clearLayers(), this._drawPath(t, this._tempLayer)
            },
            _drawPath: function(t, e, n) {
                var o = this;
                if (!t || t.length < 2) return null;
                var r = t.length,
                    s = i.Util.clone(this.options.polygonStyle);
                if (2 == r) {
                    if (n) return null;
                    var a = new i.Polyline(t, s);
                    e.addLayer(a)
                } else {
                    var h = new i.Polygon(t, s);
                    if (e.addLayer(h), n) {
                        var u = this.geodesicArea(t);
                        u = parseInt(u / 1e6 * 1e4) / 1e4;
                        var l = document.createElement("span");
                        l.className = "measure-close",
                            function(t) {
                                l.onclick = function() {
                                    o._allLayers.removeLayer(t)
                                }
                            }(e), l.innerHTML = "X", i.DomEvent.disableClickPropagation(l);
                        var c = document.createElement("span");
                        c.innerHTML = "总面积：" + u + "平方千米", c.appendChild(l);
                        var p = i.Util.clone(this.options.labelStyle);
                        p.latlng = t[r - 1], p.text = c;
                        var f = new x(p);
                        e.addLayer(f)
                    }
                }
            },
            geodesicArea: function(t) {
                var e, n, i, o, r, s, a = function(t) {
                        return t * Math.PI / 180
                    },
                    h = 0,
                    u = t.length;
                if (u > 2) {
                    for (var l = 0; l < u; l++) l === u - 2 ? (o = u - 2, r = u - 1, s = 0) : l === u - 1 ? (o = u - 1, r = 0, s = 1) : (o = l, r = l + 1, s = l + 2), e = t[o], n = t[r], i = t[s], h += (a(i.lng) - a(e.lng)) * Math.sin(a(n.lat));
                    h = 6378137 * h * 6378137 / 2
                }
                return Math.abs(h)
            }
        }),
        C = Object.freeze({
            MeasurePathTool: b,
            MeasureAreaTool: E
        }),
        I = i.Marker.prototype.onAdd,
        w = i.Marker.prototype.onRemove;
    i.Marker.mergeOptions({
        bounceOnAdd: !1,
        bounceOnAddOptions: {
            duration: 1e3,
            height: -1
        },
        bounceOnAddCallback: function() {}
    }), i.Marker.include({
        _toPoint: function(t) {
            return this._map.latLngToContainerPoint(t)
        },
        _toLatLng: function(t) {
            return this._map.containerPointToLatLng(t)
        },
        _motionStep: function(t, e) {
            var n = this,
                o = new Date - e.start,
                r = o / e.duration;
            r > 1 && (r = 1);
            var s = n._easeOutBounce(r);
            if (e.step(s), 1 === r) return void e.end();
            i.Util.requestAnimFrame(function(t) {
                n._motionStep(t, e)
            })
        },
        _bounceMotion: function(t, e) {
            var n = i.latLng(this._origLatlng),
                o = this._dropPoint.y,
                r = this._dropPoint.x,
                s = this._point.y - o,
                a = this;
            a._bLock || (a._bLock = !0, i.Util.requestAnimFrame(function(i) {
                a._motionStep(i, {
                    delay: 10,
                    duration: t || 1e3,
                    start: new Date,
                    step: function(t) {
                        a._dropPoint.y = o + s * t - (a._map.project(a._map.getCenter()).y - a._origMapCenter.y), a._dropPoint.x = r - (a._map.project(a._map.getCenter()).x - a._origMapCenter.x), a.setLatLng(a._toLatLng(a._dropPoint))
                    },
                    end: function() {
                        a._bLock = !1, a.setLatLng(n), "function" == typeof e && e()
                    }
                })
            }))
        },
        _easeOutBounce: function(t) {
            return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
        },
        bounce: function(t, e) {
            this._origLatlng = this.getLatLng(), this._bounce(t, e)
        },
        _bounce: function(t, e) {
            "function" == typeof t && (e = t, t = null), t = t || {
                duration: 1e3,
                height: -1
            }, "number" == typeof t && (t.duration = arguments[0], t.height = arguments[1]), this._origMapCenter = this._map.project(this._map.getCenter()), this._dropPoint = this._getDropPoint(t.height), this._bounceMotion(t.duration, e)
        },
        _getDropPoint: function(t) {
            this._point = this._toPoint(this._origLatlng);
            var e;
            return e = void 0 === t || t < 0 ? this._toPoint(this._map.getBounds()._northEast).y : this._point.y - t, new i.Point(this._point.x, e)
        },
        onAdd: function(t) {
            this._map = t, this._origLatlng = this._latlng, !0 === this.options.bounceOnAdd && (void 0 !== this.options.bounceOnAddDuration && (this.options.bounceOnAddOptions.duration = this.options.bounceOnAddDuration), void 0 !== this.options.bounceOnAddHeight && (this.options.bounceOnAddOptions.height = this.options.bounceOnAddHeight), this._dropPoint = this._getDropPoint(this.options.bounceOnAddOptions.height), this.setLatLng(this._toLatLng(this._dropPoint))), I.call(this, t), !0 === this.options.bounceOnAdd && this._bounce(this.options.bounceOnAddOptions, this.options.bounceOnAddCallback)
        },
        onRemove: function(t) {
            clearInterval(this._intervalId), w.call(this, t)
        }
    }), i.Map.mergeOptions({
        contextmenuItems: []
    }), i.Map.ContextMenu = i.Handler.extend({
        _touchstart: i.Browser.msPointer ? "MSPointerDown" : i.Browser.pointer ? "pointerdown" : "touchstart",
        statics: {
            BASE_CLS: "leaflet-contextmenu"
        },
        initialize: function(t) {
            i.Handler.prototype.initialize.call(this, t), this._items = [], this._visible = !1;
            var e = this._container = i.DomUtil.create("div", i.Map.ContextMenu.BASE_CLS, t._container);
            e.style.zIndex = 1e4, e.style.position = "absolute", t.options.contextmenuWidth && (e.style.width = t.options.contextmenuWidth + "px"), this._createItems(), i.DomEvent.on(e, "click", i.DomEvent.stop).on(e, "mousedown", i.DomEvent.stop).on(e, "dblclick", i.DomEvent.stop).on(e, "contextmenu", i.DomEvent.stop)
        },
        addHooks: function() {
            var t = this._map.getContainer();
            i.DomEvent.on(t, "mouseleave", this._hide, this).on(document, "keydown", this._onKeyDown, this), i.Browser.touch && i.DomEvent.on(document, this._touchstart, this._hide, this), this._map.on({
                contextmenu: this._show,
                mousedown: this._hide,
                movestart: this._hide,
                zoomstart: this._hide
            }, this)
        },
        removeHooks: function() {
            var t = this._map.getContainer();
            i.DomEvent.off(t, "mouseleave", this._hide, this).off(document, "keydown", this._onKeyDown, this), i.Browser.touch && i.DomEvent.off(document, this._touchstart, this._hide, this), this._map.off({
                contextmenu: this._show,
                mousedown: this._hide,
                movestart: this._hide,
                zoomstart: this._hide
            }, this)
        },
        showAt: function(t, e) {
            t instanceof i.LatLng && (t = this._map.latLngToContainerPoint(t)), this._showAtPoint(t, e)
        },
        hide: function() {
            this._hide()
        },
        addItem: function(t) {
            return this.insertItem(t)
        },
        insertItem: function(t, e) {
            e = void 0 !== e ? e : this._items.length;
            var n = this._createItem(this._container, t, e);
            return this._items.push(n), this._sizeChanged = !0, this._map.fire("contextmenu.additem", {
                contextmenu: this,
                el: n.el,
                index: e
            }), n.el
        },
        removeItem: function(t) {
            var e = this._container;
            return isNaN(t) || (t = e.children[t]), t ? (this._removeItem(i.Util.stamp(t)), this._sizeChanged = !0, this._map.fire("contextmenu.removeitem", {
                contextmenu: this,
                el: t
            }), t) : null
        },
        removeAllItems: function() {
            for (var t, e = this._container.children; e.length;) t = e[0], this._removeItem(i.Util.stamp(t));
            return e
        },
        hideAllItems: function() {
            var t, e, n;
            for (e = 0, n = this._items.length; e < n; e++) t = this._items[e], t.el.style.display = "none"
        },
        showAllItems: function() {
            var t, e, n;
            for (e = 0, n = this._items.length; e < n; e++) t = this._items[e], t.el.style.display = ""
        },
        setDisabled: function(t, e) {
            var n = this._container,
                o = i.Map.ContextMenu.BASE_CLS + "-item";
            isNaN(t) || (t = n.children[t]), t && i.DomUtil.hasClass(t, o) && (e ? (i.DomUtil.addClass(t, o + "-disabled"), this._map.fire("contextmenu.disableitem", {
                contextmenu: this,
                el: t
            })) : (i.DomUtil.removeClass(t, o + "-disabled"), this._map.fire("contextmenu.enableitem", {
                contextmenu: this,
                el: t
            })))
        },
        isVisible: function() {
            return this._visible
        },
        _createItems: function() {
            var t, e, n = this._map.options.contextmenuItems;
            for (t = 0, e = n.length; t < e; t++) this._items.push(this._createItem(this._container, n[t]))
        },
        _createItem: function(t, e, n) {
            if (e.separator || "-" === e) return this._createSeparator(t, n);
            var o = i.Map.ContextMenu.BASE_CLS + "-item",
                r = e.disabled ? o + " " + o + "-disabled" : o,
                s = this._insertElementAt("a", r, t, n),
                a = this._createEventHandler(s, e.callback, e.context, e.hideOnSelect),
                h = this._getIcon(e),
                u = this._getIconCls(e),
                l = "";
            return h ? l = '<img class="' + i.Map.ContextMenu.BASE_CLS + '-icon" src="' + h + '"/>' : u && (l = '<span class="' + i.Map.ContextMenu.BASE_CLS + "-icon " + u + '"></span>'), s.innerHTML = l + e.text, s.href = "#", i.DomEvent.on(s, "mouseover", this._onItemMouseOver, this).on(s, "mouseout", this._onItemMouseOut, this).on(s, "mousedown", i.DomEvent.stopPropagation).on(s, "click", a), i.Browser.touch && i.DomEvent.on(s, this._touchstart, i.DomEvent.stopPropagation), i.Browser.pointer || i.DomEvent.on(s, "click", this._onItemMouseOut, this), {
                id: i.Util.stamp(s),
                el: s,
                callback: a
            }
        },
        _removeItem: function(t) {
            var e, n, o, r, s;
            for (o = 0, r = this._items.length; o < r; o++)
                if (e = this._items[o], e.id === t) return n = e.el, s = e.callback, s && (i.DomEvent.off(n, "mouseover", this._onItemMouseOver, this).off(n, "mouseover", this._onItemMouseOut, this).off(n, "mousedown", i.DomEvent.stopPropagation).off(n, "click", s), i.Browser.touch && i.DomEvent.off(n, this._touchstart, i.DomEvent.stopPropagation), i.Browser.pointer || i.DomEvent.on(n, "click", this._onItemMouseOut, this)), this._container.removeChild(n), this._items.splice(o, 1), e;
            return null
        },
        _createSeparator: function(t, e) {
            var n = this._insertElementAt("div", i.Map.ContextMenu.BASE_CLS + "-separator", t, e);
            return {
                id: i.Util.stamp(n),
                el: n
            }
        },
        _createEventHandler: function(t, e, n, o) {
            var r = this,
                s = this._map,
                a = i.Map.ContextMenu.BASE_CLS + "-item-disabled",
                o = void 0 === o || o;
            return function(h) {
                i.DomUtil.hasClass(t, a) || (o && r._hide(), e && (console.log(r), e.call(n || s, r._showLocation)), r._map.fire("contextmenu.select", {
                    contextmenu: r,
                    el: t
                }))
            }
        },
        _insertElementAt: function(t, e, n, i) {
            var o, r = document.createElement(t);
            return r.className = e, void 0 !== i && (o = n.children[i]), o ? n.insertBefore(r, o) : n.appendChild(r), r
        },
        _show: function(t) {
            this._showAtPoint(t.containerPoint, t)
        },
        _showAtPoint: function(t, e) {
            if (this._items.length) {
                var n = this._map,
                    o = n.containerPointToLayerPoint(t),
                    r = n.layerPointToLatLng(o),
                    s = i.extend(e || {}, {
                        contextmenu: this
                    });
                this._showLocation = {
                    latlng: r,
                    layerPoint: o,
                    containerPoint: t
                }, e && e.relatedTarget && (this._showLocation.relatedTarget = e.relatedTarget), this._setPosition(t), this._visible || (this._container.style.display = "block", this._visible = !0), this._map.fire("contextmenu.show", s)
            }
        },
        _hide: function() {
            this._visible && (this._visible = !1, this._container.style.display = "none", this._map.fire("contextmenu.hide", {
                contextmenu: this
            }))
        },
        _getIcon: function(t) {
            return i.Browser.retina && t.retinaIcon || t.icon
        },
        _getIconCls: function(t) {
            return i.Browser.retina && t.retinaIconCls || t.iconCls
        },
        _setPosition: function(t) {
            var e, n = this._map.getSize(),
                o = this._container,
                r = this._getElementSize(o);
            this._map.options.contextmenuAnchor && (e = i.point(this._map.options.contextmenuAnchor), t = t.add(e)), o._leaflet_pos = t, t.x + r.x > n.x ? (o.style.left = "auto", o.style.right = Math.min(Math.max(n.x - t.x, 0), n.x - r.x - 1) + "px") : (o.style.left = Math.max(t.x, 0) + "px", o.style.right = "auto"), t.y + r.y > n.y ? (o.style.top = "auto", o.style.bottom = Math.min(Math.max(n.y - t.y, 0), n.y - r.y - 1) + "px") : (o.style.top = Math.max(t.y, 0) + "px", o.style.bottom = "auto")
        },
        _getElementSize: function(t) {
            var e = this._size,
                n = t.style.display;
            return e && !this._sizeChanged || (e = {}, t.style.left = "-999999px", t.style.right = "auto", t.style.display = "block", e.x = t.offsetWidth, e.y = t.offsetHeight, t.style.left = "auto", t.style.display = n, this._sizeChanged = !1), e
        },
        _onKeyDown: function(t) {
            27 === t.keyCode && this._hide()
        },
        _onItemMouseOver: function(t) {
            i.DomUtil.addClass(t.target || t.srcElement, "over")
        },
        _onItemMouseOut: function(t) {
            i.DomUtil.removeClass(t.target || t.srcElement, "over")
        }
    }), i.Map.addInitHook("addHandler", "contextmenu", i.Map.ContextMenu), i.Mixin.ContextMenu = {
        bindContextMenu: function(t) {
            return i.setOptions(this, t), this._initContextMenu(), this
        },
        unbindContextMenu: function() {
            return this.off("contextmenu", this._showContextMenu, this), this
        },
        addContextMenuItem: function(t) {
            this.options.contextmenuItems.push(t)
        },
        removeContextMenuItemWithIndex: function(t) {
            for (var e = [], n = 0; n < this.options.contextmenuItems.length; n++) this.options.contextmenuItems[n].index == t && e.push(n);
            for (var i = e.pop(); void 0 !== i;) this.options.contextmenuItems.splice(i, 1), i = e.pop()
        },
        replaceContextMenuItem: function(t) {
            this.removeContextMenuItemWithIndex(t.index), this.addContextMenuItem(t)
        },
        _initContextMenu: function() {
            this._items = [], this.on("contextmenu", this._showContextMenu, this)
        },
        _showContextMenu: function(t) {
            var e, n, o, r, s;
            if (this._map.contextmenu) {
                for (n = i.extend({
                    relatedTarget: this
                }, t), o = this._map.mouseEventToContainerPoint(t.originalEvent), this.options.contextmenuInheritItems || this._map.contextmenu.hideAllItems(), r = 0, s = this.options.contextmenuItems.length; r < s; r++) e = this.options.contextmenuItems[r], this._items.push(this._map.contextmenu.insertItem(e, e.index));
                this._map.once("contextmenu.hide", this._hideContextMenu, this), this._map.contextmenu.showAt(o, n)
            }
        },
        _hideContextMenu: function() {
            var t, e;
            for (t = 0, e = this._items.length; t < e; t++) this._map.contextmenu.removeItem(this._items[t]);
            this._items.length = 0, this.options.contextmenuInheritItems || this._map.contextmenu.showAllItems()
        }
    };
    var M, S, P, N = [i.Marker, i.Path],
        T = {
            contextmenu: !1,
            contextmenuItems: [],
            contextmenuInheritItems: !0
        };
    for (S = 0, P = N.length; S < P; S++) M = N[S], M.prototype.options ? M.mergeOptions(T) : M.prototype.options = T, M.addInitHook(function() {
        this.options.contextmenu && this._initContextMenu()
    }), M.include(i.Mixin.ContextMenu);
    i.Icon.Default.mergeOptions({
        iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAGmklEQVRYw7VXeUyTZxjvNnfELFuyIzOabermMZEeQC/OclkO49CpOHXOLJl/CAURuYbQi3KLgEhbrhZ1aDwmaoGqKII6odATmH/scDFbdC7LvFqOCc+e95s2VG50X/LLm/f4/Z7neY/ne18aANCmAr5E/xZf1uDOkTcGcWR6hl9247tT5U7Y6SNvWsKT63P58qbfeLJG8M5qcgTknrvvrdDbsT7Ml+tv82X6vVxJE33aRmgSyYtcWVMqX97Yv2JvW39UhRE2HuyBL+t+gK1116ly06EeWFNlAmHxlQE0OMiV6mQCScusKRlhS3QLeVJdl1+23h5dY4FNB3thrbYboqptEFlphTC1hSpJnbRvxP4NWgsE5Jyz86QNNi/5qSUTGuFk1gu54tN9wuK2wc3o+Wc13RCmsoBwEqzGcZsxsvCSy/9wJKf7UWf1mEY8JWfewc67UUoDbDjQC+FqK4QqLVMGGR9d2wurKzqBk3nqIT/9zLxRRjgZ9bqQgub+DdoeCC03Q8j+0QhFhBHR/eP3U/zCln7Uu+hihJ1+bBNffLIvmkyP0gpBZWYXhKussK6mBz5HT6M1Nqpcp+mBCPXosYQfrekGvrjewd59/GvKCE7TbK/04/ZV5QZYVWmDwH1mF3xa2Q3ra3DBC5vBT1oP7PTj4C0+CcL8c7C2CtejqhuCnuIQHaKHzvcRfZpnylFfXsYJx3pNLwhKzRAwAhEqG0SpusBHfAKkxw3w4627MPhoCH798z7s0ZnBJ/MEJbZSbXPhER2ih7p2ok/zSj2cEJDd4CAe+5WYnBCgR2uruyEw6zRoW6/DWJ/OeAP8pd/BGtzOZKpG8oke0SX6GMmRk6GFlyAc59K32OTEinILRJRchah8HQwND8N435Z9Z0FY1EqtxUg+0SO6RJ/mmXz4VuS+DpxXC3gXmZwIL7dBSH4zKE50wESf8qwVgrP1EIlTO5JP9Igu0aexdh28F1lmAEGJGfh7jE6ElyM5Rw/FDcYJjWhbeiBYoYNIpc2FT/SILivp0F1ipDWk4BIEo2VuodEJUifhbiltnNBIXPUFCMpthtAyqws/BPlEF/VbaIxErdxPphsU7rcCp8DohC+GvBIPJS/tW2jtvTmmAeuNO8BNOYQeG8G/2OzCJ3q+soYB5i6NhMaKr17FSal7GIHheuV3uSCY8qYVuEm1cOzqdWr7ku/R0BDoTT+DT+ohCM6/CCvKLKO4RI+dXPeAuaMqksaKrZ7L3FE5FIFbkIceeOZ2OcHO6wIhTkNo0ffgjRGxEqogXHYUPHfWAC/lADpwGcLRY3aeK4/oRGCKYcZXPVoeX/kelVYY8dUGf8V5EBRbgJXT5QIPhP9ePJi428JKOiEYhYXFBqou2Guh+p/mEB1/RfMw6rY7cxcjTrneI1FrDyuzUSRm9miwEJx8E/gUmqlyvHGkneiwErR21F3tNOK5Tf0yXaT+O7DgCvALTUBXdM4YhC/IawPU+2PduqMvuaR6eoxSwUk75ggqsYJ7VicsnwGIkZBSXKOUww73WGXyqP+J2/b9c+gi1YAg/xpwck3gJuucNrh5JvDPvQr0WFXf0piyt8f8/WI0hV4pRxxkQZdJDfDJNOAmM0Ag8jyT6hz0WGXWuP94Yh2jcfjmXAGvHCMslRimDHYuHuDsy2QtHuIavznhbYURq5R57KpzBBRZKPJi8eQg48h4j8SDdowifdIrEVdU+gbO6QNvRRt4ZBthUaZhUnjlYObNagV3keoeru3rU7rcuceqU1mJBxy+BWZYlNEBH+0eH4vRiB+OYybU2hnblYlTvkHinM4m54YnxSyaZYSF6R3jwgP7udKLGIX6r/lbNa9N6y5MFynjWDtrHd75ZvTYAPO/6RgF0k76mQla3FGq7dO+cH8sKn0Vo7nDllwAhqwLPkxrHwWmHJOo+AKJ4rab5OgrM7rVu8eWb2Pu0Dh4eDgXoOfvp7Y7QeqknRmvcTBEyq9m/HQQSCSz6LHq3z0yzsNySRfMS253wl2KyRDbcZPcfJKjZmSEOjcxyi+Y8dUOtsIEH6R2wNykdqrkYJ0RV92H0W58pkfQk7cKevsLK10Py8SdMGfXNXATY+pPbyJR/ET6n9nIfztNtZYRV9XniQu9IA2vOVgy4ir7GCLVmmd+zjkH0eAF9Po6K61pmCXHxU5rHMYd1ftc3owjwRSVRzLjKvqZEty6cRUD7jGqiOdu5HG6MdHjNcNYGqfDm5YRzLBBCCDl/2bk8a8gdbqcfwECu62Fg/HrggAAAABJRU5ErkJggg==",
        iconRetinaUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAABSCAYAAAAWy4frAAAPiElEQVR42t1bCVCU5xkmbabtZJJOO+l0mhgT0yQe0WXZgz2570NB8I6J6UzaTBoORRFEruVGDhWUPRAQRFFREDnVxCtEBRb24DBNE3Waaatpkmluo4m+fd9v999olGVBDu3OPLj+//s+7/W93/f9//6/EwA4/T9g3AlFOUeeUGR2uMqzOyJk2R2x0qyOAmnmkS3SrCPrZJlHlsqzjypcs49OX1Jf//P7KhD885A0u10my2ovQscvybI6wEF8ivI7pFntAV6qkw9PWSBK1bEnZRltm2WZ7R8h4FbI0VG33GPgXXgCAra+A4EIn8KT4JH/FigoiJ/IIz6TZbVVKLLan5u0QESqlkckWW3p0sy2bxDAgZwO13TDytoB+NPe9+zild2DEFGuB7/NpzDodriF55o0o7XIRXXoNxMaiCSj9VU09C8EENxyj0C4thterh2EV+veuwOr6s7Dy3ssoO93k3llzxBE6PTgkXcMOF7EJ9KMtqjR9JFDQnNV9b+QqlqqEECQZ7TBgu1nYdXuIXgVneSwYtcgRFb1Q1iFGULLzRCsM90GOrZghxkiKvthec0grLpFlxCu6cKh1w6cHUSbctPhx8YlEElu4+NSVfNpBBACtpyGlbsGmBOElRhMBDofgk4GobOjQXC5CRZiUC/VDtn4qLrBJZ3A2cNg+nE4P31PgSDBbImq5UNJejMQFqi7cCicZ3iZBTAAQVoTBI4DKKCVGBDHH6nrBRlWxWr7sljVIhlTIDLVoRkS1eH/SNIPgzyzFRZV9NnG++LqQcyoGQLQgfFEIFYpcueAzc6SSiMOtTYgH9CXr+WpTbxRBeKlqn9UktZkRoACZ5PlO81YgfMM4RX9EKAxTSjCdvTjELPYW17dD8rsdiBfEBclSY2POxQIHnlIknroEAJk6U2wpMLISF/aNQShWAV/tWlSEIK2VqBNsr200gRyGmLokyS18cTdFtA7AnFNbcxAACGMrQtDLAjqBT+1cVJBNsk2+bBQ1wOcX5K0xs12A8GyzXRNafgeAYFb3mEkrBI4I/mWGUeNQI1lyp2PoO9j4aDKcH4Ebe0E8g3xgyylcc6wgbimNjSSoFtWK1sTqLRh2BM+SOgIfDGLJL8IG3ZZjUX/ViyvGYLFOwdZn/ljYI7yzsee4TjcsV/IR3FqQ+tdAxEnNSjFyQeBEK7pgRVodEnVIPhsNzqEYK0ZluFsRnq3YjH22KJyA6z4yTmSpZ5zlH8RTvWkt1CrB85PYUqjzx2BuG6sPyfeeAA8sjtwphhiCFSbwXub0S7ISPiOAZvO4h048xSfBM+cDpDieCZOggSz6JHdBv5FJ3CN6LPJR1QMgO9204h2aALgdDxzjlp4kw8YaHKyBSJJPigWb6wHQiRmbxkKL0QDXkhgD94YxGKsGskTQkvfxVnlIHBcBNfkegziwB3HAnHDuGynRXcp/utXZhrRHiWM5CPLjbdwHVDYAhFt3J8rTtoPbpktSDrE4INZ8iw12kUYEpPs4kozeOW0A3EQIovbYcfxITj798vwxbfX4Or1H8B46ROo7fwbvKY9bpNzy2hmiSOOyMrBEe2RT5x/7tjHxCFK2l/4YyBJ+95HQABmibKzEJvRs9RgF4FqE5MleGS3AumLN+6D4lYjfIeOD/e5eROg7sz7oEg7wHRk6Y3Yi/2MJwT7bCS75BvJBuGsSvqID1ggaHyeaAMeQERgyajBg3BG8SgxDAsvJFxUOcBkg7d0Ml3XjfuhCyvg6Ofix1+Al6qB6fpueotxsckFh5A92+QbydHw4vymGJxEG+rWiRL3goJWcSwvwbPECO5bDcMiRGNmchS4a1I9kP62DhOM9tPad4npEhaUdTPOsPJ+u7bJN85PpaqJ6YoT6xKcRIl1pQjwxIukxXhyIY57N1Swh7DyASbrm38MSHdRUStc+/4GjOUTV32acbhlNjNO6pWR7FPTk6xX3lGmK0ys0zrhn0Zhwh7wK3ibnVyg6we3LQa7WFQxyGSpiqRbe/o8jPXTe+EK4xDjECHOxdYRYc8++UhyfgXHma5w/Z5mJ+H63T3ChN3Y6O/guMcxj8NGicLDgYyQ3CKcnsUbMBuoa7j48ZgD+erqdczqbsYTpulj3LSu2POBfCQ58pn0EH1OwoTafwvX1+JV2VmIxEwHlJlBsdkwLHy2mZjcgjI9kJ4Ynbh6/Xu4l09YfhPjCsSJg7hpIbbng/92M5Mjn0kPcdlJGF/7JQJCSrsgAseeHzoqL+4bFnSe5EJKzgHpeaTsg3v9rCrtYFz+hScZdzAGYs8HX84H9Jn0KAYnQfyuIQT4Y5mo0akiMhQeDh44tEguXGcE0iP845MvxxzEjRs3QZ5Ux3hCtnUxbqq6PR/8cRdAcuSz1YfzGEhNm2BdDfjkvw0LcTYKokCK+oaFAolIjiDFBYl02/oujDmQC1c+ZxzC+BoIp2t35HXHPrDnA/lIcuQz6SKOOAnWVqsRbHscjidDNf0gRWF7CNX2M1l3VTOQbmpd55gDqT01xDhkmBTiJMhGsB+isdrPbGe6wrU15RjIzkQEyHB3GqYbYCAiSeHwCMBmI7mAYiwt6grX7QT9h5dHHcQ/P/sKlEm7GYd37lHGGaLut2tbirD5iT6TriCuKsVJsLrCwyWuih2Yj/unMC2VFlfsgr5hodxsZHIEZVoTkP787APw7TXHZy/ac/25rJ3pSpP24tRrZnyeW012bbtZbS9AefKZ+b6mMtjJS6V6GP/zOR3wK+pkQn7bzHbJCCRDsqFlBpz+djHCV7a2wMUr/x0xiM++ugprq45bnFhbhdNoF+MKLOt32C75SvqIb7xUO3/Fdr/8uMqDLmsqwU3VipH2QzA2k3hTr11ICnqZHMn7F+HCFIfZQQ5JfDVUvW1mzv708/V316FV/wF4Je9hsgSv3GOMYz71Jg6bkezS0CN5N1WLhSOussW2jResrnzNZXUFm5PnW0nl2CciVLQHebHBJh9U0g1S3GYQD4eQjH2QWH0C0utw15DXAEIybD0nxoUsYPMZmz4N59HYE+K0SzyC2Mo3bIHw4zTT+Kt33ESAX/FZCMWovUtMIMzvHRFKJA9G+VAGvJ7IPsKGC3HdDYI4qnwzhJQZmQ5l2AODcMSWb6mJ6fgWn+H4bsxbWzX9tmt2l9Xl7fzYcpwJGhl5MI5XESoL8kaGKB9XWww8xOoYIXBrD3hvOgnK9BbEYdypHsctSBcGYLbJ+FMvbupz2AanJ01uAPLVJab88B03H1xidKH8WB0TCCq1KNEM4YgRDm7FRlys+m8L6G6gJLmPkpuqxhJU0st8JF8FMeV+dwTipFL9zDlGewmB1wYdzJh/qRlccntHDcqevBCv6NBZ3xIz+CGP5xYTKIoMIMZzo+UTIAK3WRKgULUB+egcrTs/7A06XpQ20Tlai+O4mm0DKLuSAgPwkWgqIcOkkC+BOBRdVlcC+ciL0kUNG4jodd3vnKM13yHAK/8UBG6nTBrBOUc/pfDBRZJ88cg9DuQbL1rzxdw3yx61exPbOUazi4Rd8VqYMhBIwyunF5yz9VMCUV6vxQ+ECJcH8s05SlMy4t145xi1jAkjfIu7GIESxzYPSacC1Gfkg3fhGbD6ddMlVvuCQz/0oHAfKclSmiAAK0JN75zdC/Oy9JMKanKyTxBvOGAJJEbd4fAvVrxo9UukxMfZwbu4hwWiKDLCXCSfTNAUTba9Cs5x1SD4OBwIm4qjNQOkKE1uBH+aQkssVZmbqZ8UCLAvyS5BnLDf2hvaE6P+MZQfpYngsuBd2A1+W7EqBUZ4MUM/KXAvMjGbHvm23gCXaI1yTD9Po7KezWBJB8EXp0ACD0s+J6NnQkGzJGdPlFDHBdI+5t/Z+dGaQC4bHpvOgg+uznJcIGereiYUykIjs+WW22mrBi9WLbqnJx9wlugkIlHifvBGcgLNKLPQ4ESA+pCzI4jfwy2Ajff8CAduWzy4rLjnnWEGqFdmpfdMCKgaZEOZc5qrxg3nWM28cXmohhetPcqqsn4veG02MczDmWVmWs+4wjmr18YvWFfLBVI3bk8HubxZ5spVRZHTyQzJsSovoPHxhAKrQdyKrFNcED/wo8pnjuvzWrgHayJyIY5bz2ITw1ycJp9P7R4X8LDCHK/L2l0sEH60tmrcHzzjRet4tM9hVck+xQzKNxnGLRDqO+KUZZ7gqnHdZY1mxoQ8QUfjlYwI1taCBy5YBKrKcynd9wTqNwufEfhrqq17Ko16wh4FpPFK45ZtKDNOgnshZjDfAH9M7r4nyPONjEua/hZXjav8NzTTJvThTF6UppJtF+JqwA2NE15U6eFZdGgsmJvRyziUeBXIX7PT2huazRP+lKkgavszeM18jW0oVcfBrYCqYoRnN3aPGlw1iMM17ai1Gtqvnd/Q/H5SnvvF7f12ljkcz0psUmWBpSoz0LnRgKpBugq6L8CuxSkQde6kPcAsWqN7Ao1+yzaUacdAsckI0jwDPJPU5TBmbOxi/UW64pQOrjc+5/1V/dtJfRIbrw0KWFVWV+Hw6GNDZE6aHp7e0OUQ5qTrmY48rw/4sRWW3ojSpk36I+Wzo7Y/7hyl+ZJtXVI7WJ+45hrgacz29A32QTISrCDpiJLbuWp8Oiuh8jGYiof8eTHqDEtVKkCGmZVZqzI9scsuSIZkZXTfKnYHt8NNmLK3FaQxpb9GJz5jVcHMclWhrD+VeHfQsJLkWqohTGrlqnFZ9LrukSl97YIXpU5kVcHMSvDKTppnhNmY8WkJXXcFnSMZSY6e3cO1ruKxU/7+CGUSnbnCti4bWjHbOAvlGOApdPrJ9beDjtE5khFsaOaq8dHzMaW/vC/e6KGMWm4flYMku4cNnVmpPej8udtA1aBzrll47RGjs/aG+vX75tUkyihl1lKVZnDFrIuy+2AaOv9EvAX0nY7ROZeEJq4aF+g3zPvqHStejOYvlvGuA1FmNxtCM1P18AcMgjALv9MxYWaX9WcBktWuuu9eFqPM4mbvAzbEEg5h9tHpLIOtP+g7HeMnNHLVeG/JkvF7YWxc33jDqqy0ZhoEKovzM1P0DPSdjtFvG5ZVXLP0vn19z3KrVTvIHF3fYHHeCvruHN/AbdNN3PO69+17iLgzjrRux8El/SwIMg0M9P3HG9HqsPv+hUrrJXEvczj+AAbRx+AcX88F0v1AvBnKAnlTG8Rln5/6LuLHW5/zorT+D0wg1qq8y5xfu88CSyCnH5h3dW/ZGXve8uOMZRWP0no8cIFY7+YfswURrT36QL09ffsMppHYegW/P7CBWHvlMOGBe5/9jtdjY7R8wkTb+R9meZA6n2oJWAAAAABJRU5ErkJggg==",
        shadowUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAYAAACoYAD2AAAC5ElEQVRYw+2YW4/TMBCF45S0S1luXZCABy5CgLQgwf//S4BYBLTdJLax0fFqmB07nnQfEGqkIydpVH85M+NLjPe++dcPc4Q8Qh4hj5D/AaQJx6H/4TMwB0PeBNwU7EGQAmAtsNfAzoZkgIa0ZgLMa4Aj6CxIAsjhjOCoL5z7Glg1JAOkaicgvQBXuncwJAWjksLtBTWZe04CnYRktUGdilALppZBOgHGZcBzL6OClABvMSVIzyBjazOgrvACf1ydC5mguqAVg6RhdkSWQFj2uxfaq/BrIZOLEWgZdALIDvcMcZLD8ZbLC9de4yR1sYMi4G20S4Q/PWeJYxTOZn5zJXANZHIxAd4JWhPIloTJZhzMQduM89WQ3MUVAE/RnhAXpTycqys3NZALOBbB7kFrgLesQl2h45Fcj8L1tTSohUwuxhy8H/Qg6K7gIs+3kkaigQCOcyEXCHN07wyQazhrmIulvKMQAwMcmLNqyCVyMAI+BuxSMeTk3OPikLY2J1uE+VHQk6ANrhds+tNARqBeaGc72cK550FP4WhXmFmcMGhTwAR1ifOe3EvPqIegFmF+C8gVy0OfAaWQPMR7gF1OQKqGoBjq90HPMP01BUjPOqGFksC4emE48tWQAH0YmvOgF3DST6xieJgHAWxPAHMuNhrImIdvoNOKNWIOcE+UXE0pYAnkX6uhWsgVXDxHdTfCmrEEmMB2zMFimLVOtiiajxiGWrbU52EeCdyOwPEQD8LqyPH9Ti2kgYMf4OhSKB7qYILbBv3CuVTJ11Y80oaseiMWOONc/Y7kJYe0xL2f0BaiFTxknHO5HaMGMublKwxFGzYdWsBF174H/QDknhTHmHHN39iWFnkZx8lPyM8WHfYELmlLKtgWNmFNzQcC1b47gJ4hL19i7o65dhH0Negbca8vONZoP7doIeOC9zXm8RjuL0Gf4d4OYaU5ljo3GYiqzrWQHfJxA6ALhDpVKv9qYeZA8eM3EhfPSCmpuD0AAAAASUVORK5CYII="
    }), i.Icon.Default.include({
        _getIconUrl: function(t) {
            return i.Icon.prototype._getIconUrl.call(this, t)
        }
    }), i.interpolatePosition = function(t, e, n, o) {
        var r = o / n;
        return r = r > 0 ? r : 0, r = r > 1 ? 1 : r, i.latLng(t.lat + r * (e.lat - t.lat), t.lng + r * (e.lng - t.lng))
    }, i.MovingMarker = i.Marker.extend({
        statics: {
            notStartedState: 0,
            endedState: 1,
            pausedState: 2,
            runState: 3
        },
        options: {
            autostart: !1,
            loop: !1,
            bCenter: !1
        },
        initialize: function(t, e, n) {
            i.Marker.prototype.initialize.call(this, t[0], n), this._latlngs = t.map(function(t, e) {
                return i.latLng(t)
            }), e instanceof Array ? this._durations = e : this._durations = this._createDurations(this._latlngs, e), this._currentDuration = 0, this._currentIndex = 0, this._state = i.MovingMarker.notStartedState, this._startTime = 0, this._startTimeStamp = 0, this._pauseStartTime = 0, this._animId = 0, this._animRequested = !1, this._currentLine = [], this._stations = {}
        },
        isRunning: function() {
            return this._state === i.MovingMarker.runState
        },
        isEnded: function() {
            return this._state === i.MovingMarker.endedState
        },
        isStarted: function() {
            return this._state !== i.MovingMarker.notStartedState
        },
        isPaused: function() {
            return this._state === i.MovingMarker.pausedState
        },
        start: function() {
            this.isRunning() || (this.isPaused() ? this.resume() : (this._loadLine(0), this._startAnimation(), this.fire("start")))
        },
        resume: function() {
            this.isPaused() && (this._currentLine[0] = this.getLatLng(), this._currentDuration -= this._pauseStartTime - this._startTime, this._startAnimation())
        },
        pause: function() {
            this.isRunning() && (this._pauseStartTime = Date.now(), this._state = i.MovingMarker.pausedState, this._stopAnimation(), this._updatePosition())
        },
        stop: function(t) {
            this.isEnded() || (this._stopAnimation(), void 0 === t && (t = 0, this._updatePosition()), this._state = i.MovingMarker.endedState, this.fire("end", {
                elapsedTime: t
            }))
        },
        addLatLng: function(t, e) {
            this._latlngs.push(i.latLng(t)), this._durations.push(e)
        },
        moveTo: function(t, e) {
            this._stopAnimation(), this._latlngs = [this.getLatLng(), i.latLng(t)], this._durations = [e], this._state = i.MovingMarker.notStartedState, this.start(), this.options.loop = !1
        },
        addStation: function(t, e) {
            t > this._latlngs.length - 2 || t < 1 || (this._stations[t] = e)
        },
        onAdd: function(t) {
            if (i.Marker.prototype.onAdd.call(this, t), this.options.autostart && !this.isStarted()) return void this.start();
            this.isRunning() && this._resumeAnimation()
        },
        onRemove: function(t) {
            i.Marker.prototype.onRemove.call(this, t), this._stopAnimation()
        },
        _createDurations: function(t, e) {
            for (var n = t.length - 1, i = [], o = 0, r = 0, s = 0; s < n; s++) r = t[s + 1].distanceTo(t[s]), i.push(r), o += r;
            var a = e / o,
                h = [];
            for (s = 0; s < i.length; s++) h.push(i[s] * a);
            return h
        },
        _startAnimation: function() {
            this._state = i.MovingMarker.runState, this._animId = i.Util.requestAnimFrame(function(t) {
                this._startTime = Date.now(), this._startTimeStamp = t, this._animate(t)
            }, this, !0), this._animRequested = !0
        },
        _resumeAnimation: function() {
            this._animRequested || (this._animRequested = !0, this._animId = i.Util.requestAnimFrame(function(t) {
                this._animate(t)
            }, this, !0))
        },
        _stopAnimation: function() {
            this._animRequested && (i.Util.cancelAnimFrame(this._animId), this._animRequested = !1)
        },
        _updatePosition: function() {
            var t = Date.now() - this._startTime;
            this._animate(this._startTimeStamp + t, !0)
        },
        _loadLine: function(t) {
            this._currentIndex = t, this._currentDuration = this._durations[t], this._currentLine = this._latlngs.slice(t, t + 2), this.fire("pointChange", {
                index: t,
                marker: this,
                p1: this._currentLine[0],
                p2: this._currentLine[1]
            })
        },
        _updateLine: function(t) {
            var e = t - this._startTimeStamp;
            if (e <= this._currentDuration) return e;
            for (var n, i = this._currentIndex, o = this._currentDuration; e > o;) {
                if (e -= o, void 0 !== (n = this._stations[i + 1])) {
                    if (e < n) return this.setLatLng(this._latlngs[i + 1]), null;
                    e -= n
                }
                if (++i >= this._latlngs.length - 1) {
                    if (!this.options.loop) return this.setLatLng(this._latlngs[this._latlngs.length - 1]), this.stop(e), null;
                    i = 0, this.fire("loop", {
                        elapsedTime: e
                    })
                }
                o = this._durations[i]
            }
            return this._loadLine(i), this._startTimeStamp = t - e, this._startTime = Date.now() - e, e
        },
        _animate: function(t, e) {
            this._animRequested = !1;
            var n = this._updateLine(t);
            if (!this.isEnded()) {
                if (null != n) {
                    var o = i.interpolatePosition(this._currentLine[0], this._currentLine[1], this._currentDuration, n);
                    this.options.bCenter && this._map.panTo(o), this.setLatLng(o)
                }
                e || (this._animId = i.Util.requestAnimFrame(this._animate, this, !1), this._animRequested = !0)
            }
        }
    });
    var O = i.Marker.prototype._initIcon,
        A = i.Marker.prototype._setPos,
        R = "msTransform" === i.DomUtil.TRANSFORM;
    i.Marker.addInitHook(function() {
        var t = this.options.icon && this.options.icon.options,
            e = t && this.options.icon.options.iconAnchor;
        e && (e = e[0] + "px " + e[1] + "px"), this.options.rotationOrigin = this.options.rotationOrigin || e || "center bottom", this.options.rotationAngle = this.options.rotationAngle || 0, this.on("drag", function(t) {
            t.target._applyRotation()
        })
    }), i.Marker.include({
        _initIcon: function() {
            O.call(this)
        },
        _setPos: function(t) {
            A.call(this, t), this._applyRotation()
        },
        _applyRotation: function() {
            this.options.rotationAngle && (this._icon.style[i.DomUtil.TRANSFORM + "Origin"] = this.options.rotationOrigin, R ? this._icon.style[i.DomUtil.TRANSFORM] = "rotate(" + this.options.rotationAngle + "deg)" : this._icon.style[i.DomUtil.TRANSFORM] += " rotateZ(" + this.options.rotationAngle + "deg)")
        },
        setRotationAngle: function(t) {
            return this.options.rotationAngle = t, this.update(), this
        },
        setRotationOrigin: function(t) {
            return this.options.rotationOrigin = t, this.update(), this
        }
    });
    var D = i.Layer.extend({
        options: {
            color: "rgba(250,113,122,0.8)",
            type: "circle",
            speed: .15,
            max: 20,
            latlng: null,
            name: ""
        },
        beforeAdd: function(t) {
            this._renderer = this._getRenderer(t), t.hasLayer(this._renderer) || t.addLayer(this._renderer)
        },
        onAdd: function(t) {
            this.update()
        },
        onRemove: function() {
            this._renderer.clear(), this.drawFrame && i.Util.cancelAnimFrame(this.drawFrame)
        },
        _getRenderer: function(t) {
            var e = t._paneRenderers.flashMarker;
            return e || (e = new o({
                pane: this.options.pane
            }), t._paneRenderers.flashMarker = e), e
        },
        initialize: function(t, e) {
            i.setOptions(this, e), this.latlng = t, this.name = this.options.name || "", this.size = 0
        },
        getEvents: function() {
            return {
                moveend: this.update,
                viewreset: this.update
            }
        },
        update: function() {
            var t = this;
            this._map && (this._renderer.clear(), this.drawFrame && i.Util.cancelAnimFrame(this.drawFrame), function e() {
                t.drawFrame = i.Util.requestAnimFrame(e), t.draw()
            }())
        },
        draw: function() {
            var t = this._renderer.ctx;
            t.fillStyle = "rgba(0,0,0,.93)";
            var e = t.globalCompositeOperation;
            switch (t.globalCompositeOperation = "destination-in", t.fillRect(0, 0, this._renderer.getContainer().width, this._renderer.getContainer().height), t.globalCompositeOperation = e, t.save(), t.beginPath(), this.options.type) {
                case "circle":
                    this._drawCircle(t);
                    break;
                case "ellipse":
                    this._drawEllipse(t)
            }
            t.closePath(), t.restore(), this.size += this.options.speed, this.size > this.options.max && (this.size = 0)
        },
        _drawCircle: function(t) {
            var e = this._map.latLngToLayerPoint(this.latlng);
            t.strokeStyle = this.options.color, t.arc(e.x, e.y, this.size, 0, 2 * Math.PI), t.stroke()
        },
        _drawEllipse: function(t, e) {
            var n = this._map.latLngToLayerPoint(this.latlng),
                i = n.x,
                o = n.y,
                r = this.size,
                s = this.size / 2,
                a = r / 2 * .5522848,
                h = s / 2 * .5522848,
                u = i - r / 2,
                l = o - s / 2,
                c = i + r / 2,
                p = o + s / 2;
            t.strokeStyle = this.options.color, t.moveTo(u, o), t.bezierCurveTo(u, o - h, i - a, l, i, l), t.bezierCurveTo(i + a, l, c, o - h, c, o), t.bezierCurveTo(c, o + h, i + a, p, i, p), t.bezierCurveTo(i - a, p, u, o + h, u, o), t.stroke()
        }
    });
    i.SVG.include({
        _updatecurve: function(t) {
            var e = this._curvePointsToPath(t._points);
            if (this._setPath(t, e), t.options.animate) {
                var n = t._path,
                    i = n.getTotalLength();
                t.options.dashArray || (n.style.strokeDasharray = i + " " + i), t._initialUpdate && (n.animate([{
                    strokeDashoffset: i
                }, {
                    strokeDashoffset: 0
                }], t.options.animate), t._initialUpdate = !1)
            }
            return e
        },
        _curvePointsToPath: function(t) {
            for (var e = void 0, n = void 0, i = "", o = 0; o < t.length; o++) e = t[o], "string" == typeof e || e instanceof String ? (n = e, i += n) : i += e.x + "," + e.y + " ";
            return i || "M0 0"
        }
    });
    var k = i.Path.extend({
            options: {},
            initialize: function(t, e) {
                t.mid && void 0 !== t.mid[0] || (t.mid = this.getMidPoint(t.from, t.to, t.from.deep ? t.from.deep : 4, t.from.slide)), i.setOptions(this, e), this._initialUpdate = !0, this.setPath(t)
            },
            onAdd: function(t) {
                this._renderer._initPath(this), this._reset(), this._renderer._addPath(this), t.on("zoom", function() {})
            },
            getPath: function() {
                return this._coords
            },
            setPath: function(t) {
                return this._setPath(t), this.redraw()
            },
            getBounds: function() {
                return this._bounds
            },
            getMidPoint: function(t, e, n) {
                var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "LEFT_ROUND",
                    o = 3.14;
                "RIGHT_ROUND" === i && (o *= -1);
                var r = [],
                    s = t,
                    a = e,
                    h = a.lng - s.lng,
                    u = a.lat - s.lat,
                    l = Math.sqrt(Math.pow(h, 2) + Math.pow(u, 2)),
                    c = Math.atan2(u, h),
                    p = o / (n || 4),
                    f = l / 2 / Math.cos(p),
                    d = c + p,
                    _ = f * Math.cos(d) + s.lng,
                    g = f * Math.sin(d) + s.lat,
                    m = [g, _];
                return r.push(s, m, a), m
            },
            _setPath: function(t) {
                this._coords = t, this._bounds = this._computeBounds()
            },
            _computeBounds: function() {
                var t = new i.LatLngBounds;
                return t.extend(this._coords.from), t.extend(this._coords.to), t.extend(this._coords.mid), t
            },
            getCenter: function() {
                return this._bounds.getCenter()
            },
            _update: function() {
                this._map && this._updatePath()
            },
            _updatePath: function() {
                this._renderer._updatecurve(this)
            },
            _project: function() {
                this._points = [], this._points.push("M");
                var t = this._map.latLngToLayerPoint(this._coords.from);
                this._points.push(t), this._coords.mid && (this._points.push("Q"), t = this._map.latLngToLayerPoint(this._coords.mid), this._points.push(t)), t = this._map.latLngToLayerPoint(this._coords.to), this._points.push(t)
            }
        }),
        F = Object.freeze({
            Label: x,
            FlashMarker: D,
            Bezier: k
        });
    L.GridLayer.include({
        _isValidTile: function(t) {
            var e = this._map.options.crs;
            if (!e.infinite) {
                var n = this._globalTileRange;
                if (this.options.noWrap && (t.x < 0 || t.x > n.max.x)) return !1;
                if (!e.wrapLng && (t.x < n.min.x || t.x > n.max.x) || !e.wrapLat && (t.y < n.min.y || t.y > n.max.y)) return !1
            }
            if (!this.options.bounds) return !0;
            var i = this._tileCoordsToBounds(t);
            return L.latLngBounds(this.options.bounds).overlaps(i)
        }
    }), L.TileLayer.mergeOptions({
        latOffset: 0,
        lngOffset: 0
    }), L.TileLayer.include({
        _getTilePos: function(t) {
            var e = this._getPixelOffset();
            return t.scaleBy(this.getTileSize()).subtract(this._level.origin).subtract(e)
        },
        _getTiledPixelBounds: function(t) {
            var e = this._map,
                n = e._animatingZoom ? Math.max(e._animateToZoom, e.getZoom()) : e.getZoom(),
                i = e.getZoomScale(n, this._tileZoom),
                o = e.project(t, this._tileZoom).floor(),
                r = e.getSize().divideBy(2 * i),
                s = this._getPixelOffset();
            return o = o.add(s), new L.Bounds(o.subtract(r), o.add(r))
        },
        _getPixelOffset: function() {
            var t = new L.Point(0, 0),
                e = this.options.lngOffset,
                n = this.options.latOffset;
            if (e || n) {
                var i = this._map,
                    o = i.getCenter(),
                    r = i.project(o, this._tileZoom),
                    s = i.project(new L.LatLng(o.lat + n, o.lng + e), this._tileZoom);
                t.x = s.x - r.x, t.y = s.y - r.y
            }
            return t
        }
    });
    var z = Object.freeze({}),
        B = {
            m_1: {
                iconUrl: "img/icon/m_1.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_1",
                label: "故障车"
            },
            m_0_10_0_1: {
                iconUrl: "img/icon/m_0_10_0_1.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_10_0_1",
                label: "普通车无灯光无刹车"
            },
            m_0_10_0_2: {
                iconUrl: "img/icon/m_0_10_0_2.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_10_0_2",
                label: "普通车无灯光刹车"
            },
            m_0_10_2_1: {
                iconUrl: "img/icon/m_0_10_2_1.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_10_2_1",
                label: "普通车左转灯无刹车"
            },
            m_0_10_2_2: {
                iconUrl: "img/icon/m_0_10_2_2.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_10_2_2",
                label: "普通车左转灯刹车"
            },
            m_0_10_3_1: {
                iconUrl: "img/icon/m_0_10_3_1.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_10_3_1",
                label: "普通车右转灯无刹车"
            },
            m_0_10_3_2: {
                iconUrl: "img/icon/m_0_10_3_2.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_10_3_2",
                label: "普通车右转灯刹车"
            },
            m_0_65_0_1: {
                iconUrl: "img/icon/m_0_65_0_1.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_65_0_1",
                label: "紧急车无灯光无刹车"
            },
            m_0_65_0_2: {
                iconUrl: "img/icon/m_0_65_0_2.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_65_0_2",
                label: "紧急车无灯光刹车"
            },
            m_0_65_2_1: {
                iconUrl: "img/icon/m_0_65_2_1.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_65_2_1",
                label: "紧急车左转灯无刹车"
            },
            m_0_65_2_2: {
                iconUrl: "img/icon/m_0_65_2_2.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_65_2_2",
                label: "紧急车左转灯刹车"
            },
            m_0_65_3_1: {
                iconUrl: "img/icon/m_0_65_3_1.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_65_3_1",
                label: "紧急车右转灯无刹车"
            },
            m_0_65_3_2: {
                iconUrl: "img/icon/m_0_65_3_2.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_65_3_2",
                label: "紧急车右转灯刹车"
            },
            m_0_30_0_1: {
                iconUrl: "img/icon/m_0_30_0_1.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_30_0_1",
                label: "危险车无灯光无刹车"
            },
            m_0_30_0_2: {
                iconUrl: "img/icon/m_0_30_0_2.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_30_0_2",
                label: "危险车无灯光刹车"
            },
            m_0_30_2_1: {
                iconUrl: "img/icon/m_0_30_2_1.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_30_2_1",
                label: "危险车左转灯无刹车"
            },
            m_0_30_2_2: {
                iconUrl: "img/icon/m_0_30_2_2.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_30_2_2",
                label: "危险车左转灯刹车"
            },
            m_0_30_3_1: {
                iconUrl: "img/icon/m_0_30_3_1.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_30_3_1",
                label: "危险车右转灯无刹车"
            },
            m_0_30_3_2: {
                iconUrl: "img/icon/m_0_30_3_2.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "m_0_30_3_2",
                label: "危险车右转灯刹车"
            },
            t_3: {
                iconUrl: "img/icon/t_3.png",
                iconSize: [26, 46],
                iconAnchor: [13, 23],
                name: "t_3",
                label: "虚化行人"
            },
            t_2: {
                iconUrl: "img/icon/t_2.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "t_2",
                label: "虚化非机动车"
            },
            t_1_1: {
                iconUrl: "img/icon/t_1_1.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "t_1_1",
                label: "虚化故障车"
            },
            t_1_0_10: {
                iconUrl: "img/icon/t_1_0_10.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "t_1_0_10",
                label: "虚化普通车"
            },
            t_1_0_65: {
                iconUrl: "img/icon/t_1_0_65.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "t_1_0_65",
                label: "虚化紧急车"
            },
            t_1_0_30: {
                iconUrl: "img/icon/t_1_0_30.png",
                iconSize: [26, 50],
                iconAnchor: [13, 25],
                name: "t_1_0_30",
                label: "虚化危险车"
            }
        },
        G = {
            CA: "CA",
            DV: "DV",
            YI: "YI",
            BA: "BA",
            BZ: "BZ",
            RE: "RE",
            DC: "DC",
            NO: "NO"
        },
        U = {
            NoBrake: "1",
            Brake: "2"
        },
        j = {
            NoLight: "0",
            LeftLight: "2",
            RightLight: "3"
        },
        q = {
            Unknown: 0,
            Motor: 1,
            Nomotor: 2,
            Pedestrian: 3
        },
        Z = {
            Danger: "37",
            FallRock: "15",
            Curve: "2",
            Construction: "38",
            Roadslippery: "17",
            Tunnel: "21",
            Limitheight: "82",
            Limitwidth: "81",
            LimitWeight: "84",
            Trafficjam: "47",
            Trafficaccident: "244",
            Avoidance: "2399"
        },
        V = {
            Red: 3,
            Yellow: 5,
            Yellow1: 7,
            Green: 6
        },
        H = {
            Normal: "0",
            Fault: "1"
        },
        Y = {
            Common: "10",
            Urgent: "60",
            Danger: "30",
            getShowName: function(t) {
                var e = "";
                switch (t) {
                    case this.Common:
                        e = "普通车辆";
                        break;
                    case this.Urgent:
                        e = "紧急车辆";
                        break;
                    case this.Danger:
                        e = "危险车辆"
                }
                return e
            }
        },
        W = i.Marker.extend({
            options: {
                id: "",
                isHome: !1,
                linkStyle: {
                    color: "rgb(30, 30, 30)",
                    dashArray: 8,
                    weight: "1"
                },
                circleStyle: {
                    radius: 50,
                    stroke: !1,
                    fillColor: "#00fff0",
                    fillOpacity: .3
                }
            },
            initialize: function(t, e) {
                i.setOptions(this, e), this.infos = t;
                var n = t[0].motion,
                    o = [n.latitude, n.longitude];
                i.Marker.prototype.initialize.call(this, o, e), this.targetLayers = [], this.circleMarker = null, this.reset(), this._changeData()
            },
            getMinTime: function() {
                return this.infos && 0 != this.infos.length ? this.infos[0].datetime : 0
            },
            getMaxTime: function() {
                return this.infos && 0 != this.infos.length ? this.infos[this.infos.length - 1].datetime : 0
            },
            addInfo: function(t) {
                this.infos.push(t)
            },
            addInfos: function(t) {
                if (t && 0 != t.length) {
                    var e = this;
                    t.forEach(function(t) {
                        e.addInfo(t)
                    })
                }
            },
            reset: function() {
                this._currentIndex = 0, this.clearTarget()
            },
            clearTarget: function() {
                if (this.targetLayers.length) {
                    for (var t = this.targetLayers.length, e = 0; e < t; e++) {
                        var n = this.targetLayers[e];
                        this._map.removeLayer(n.marker), this._map.removeLayer(n.link)
                    }
                    this.targetLayers = []
                }
            },
            _changeData: function() {
                var t = this._currentIndex || 0,
                    e = this.infos;
                if (e && !(e.length <= t)) {
                    var n = this.infos[t],
                        i = n.motion;
                    this._changeIcon();
                    var o = i.speedangle;
                    this.setRotationAngle(o), this._handleTarget(n.target);
                    var r = this._handleMessage(n);
                    this.options.isHome && this.fire("changeData", {
                        id: this.options.id,
                        target: this,
                        motion: n.motion,
                        tl: n.tl,
                        msgList: r
                    })
                }
            },
            _changeIcon: function() {
                var t = this._currentIndex || 0,
                    e = this.infos;
                if (e && !(e.length <= t)) {
                    var n = e[t].motion,
                        i = this.options.icon,
                        o = this._getIcon(n, "motion");
                    o && o.options.name != i.options.name && this.setIcon(o)
                }
            },
            _handleTarget: function(t) {
                if (this.clearTarget(), this.options.isHome && t && t.length)
                    for (var e = t.length, n = 0; n < e; n++) {
                        var o = t[n],
                            r = new i.LatLng(o.latitude, o.longitude),
                            s = this._getIcon(o, "target") || new i.Icon.Default,
                            a = new i.Marker(r, {
                                icon: s
                            });
                        a.setRotationAngle(o.heading);
                        var h = this.getLatLng(),
                            u = {
                                lat: h.lat,
                                lng: h.lng,
                                slide: "RIGHT_ROUND"
                            },
                            l = {
                                lat: r.lat,
                                lng: r.lng,
                                slide: "RIGHT_ROUND"
                            },
                            c = new k({
                                from: u,
                                to: l
                            }, this.options.linkStyle);
                        this._map.addLayer(a), this._map.addLayer(c), this.targetLayers.push({
                            marker: a,
                            link: c
                        })
                    }
            },
            _getIcon: function(t, e) {
                if (!t) return null;
                if ("motion" == e) {
                    var n = t.vehstate || H.Normal,
                        o = t.vehtype || Y.Common,
                        r = t.lightstate || j.NoLight,
                        s = t.brakestate || U.NoBrake,
                        a = "m_" + n;
                    n == H.Normal && (a = a + "_" + o + "_" + r + "_" + s);
                    var h = B[a];
                    if (!h) return null;
                    var u = new i.Icon(h);
                    return u
                }
                if ("target" == e) {
                    var l = t.ptctype || q.Motor,
                        n = t.vehstate || H.Normal,
                        o = t.vehtype || Y.Common,
                        a = "t_" + l;
                    l != q.Pedestrian && (a = a + "_" + n, n == H.Normal && (a = a + "_" + o));
                    var h = B[a];
                    if (!h) return null;
                    var u = new i.Icon(h);
                    return u
                }
                return null
            },
            clearCircleMarker: function() {
                this._map && this.circleMarker && (this._map.removeLayer(this.circleMarker), this.circleMarker = null)
            },
            addCircleMarker: function() {
                this.circleMarker || (this.circleMarker = new i.CircleMarker(this.getLatLng(), this.options.circleStyle), this._map.addLayer(this.circleMarker))
            },
            setCurrentPosition: function(t) {
                this.options.isHome ? this.addCircleMarker() : this.clearCircleMarker();
                var e = this.getMinTime(),
                    n = this.getMaxTime();
                if (!(t < e || t > n)) {
                    var i = this._currentIndex,
                        o = this.infos,
                        r = o.length;
                    if (!(r <= i)) {
                        for (var s = !1, a = i; a < r - 1; a++) {
                            var h = o[a],
                                u = o[a + 1],
                                l = u.datetime - h.datetime;
                            if (t >= h.datetime && t < u.datetime) {
                                var c = {
                                        lat: h.motion.latitude,
                                        lng: h.motion.longitude
                                    },
                                    p = {
                                        lat: u.motion.latitude,
                                        lng: u.motion.longitude
                                    },
                                    f = t - h.datetime,
                                    d = this.interpolatePosition(c, p, l, f);
                                this.setLatLng(d), this.options.isHome && (this._map.panTo(d), this.circleMarker.setLatLng(d));
                                break
                            }
                            s = !0, this._currentIndex++
                        }
                        s && this._changeData()
                    }
                }
            },
            interpolatePosition: function(t, e, n, o) {
                var r = o / n;
                return r = r > 0 ? r : 0, r = r > 1 ? 1 : r, i.latLng(t.lat + r * (e.lat - t.lat), t.lng + r * (e.lng - t.lng))
            },
            setIsHome: function(t) {
                this.options.isHome = t, t ? this.addCircleMarker() : this.clearCircleMarker()
            },
            _handleMessage: function(t) {
                var e = this,
                    n = [],
                    i = t.target,
                    o = t.rsi;
                return i && i.length > 0 && i.forEach(function(t) {
                    var i = e._handleTargetMsg(t);
                    i && n.push(i)
                }), o && o.length > 0 && o.forEach(function(t) {
                    var i = e._handleRsiMsg(t);
                    i && n.push(i)
                }), n
            },
            _handleTargetMsg: function(t) {
                var e = t.apptype,
                    n = t.ptctype,
                    i = (t.targetangle, ""),
                    o = "",
                    r = "";
                if (e != G.NO) {
                    n == q.Pedestrian ? (i = "行人预警", r = "t_persion") : (e == G.CA ? (i = "碰撞预警", o = "1") : e == G.DV ? i = "危险车辆预警" : e == G.YI ? i = "VIP车辆让行" : e == G.BA ? i = "前车紧急刹车预警" : e == G.BZ ? i = "盲区预警" : e == G.RE ? i = "追尾预警" : e == G.DC && (i = "异常车辆预警"), r = "t_" + e, o && (r = r + "_" + o));
                    return {
                        text: i,
                        apptype: e,
                        type: "target",
                        code: r
                    }
                }
            },
            _handleRsiMsg: function(t) {
                var e = t.type,
                    n = "";
                e == Z.Danger ? n = "危险预警" : e == Z.FallRock ? n = "注意落石" : e == Z.Curve ? n = "急弯预警" : e == Z.Construction ? n = "前方施工" : e == Z.Roadslippery ? n = "道路湿滑" : e == Z.Tunnel ? n = "隧道" : e == Z.Limitheight ? n = "限高" : e == Z.Limitwidth ? n = "限宽" : e == Z.LimitWeight ? n = "限重" : e == Z.Trafficjam ? n = "交通拥堵" : e == Z.Trafficaccident ? n = "交通事故" : e == Z.Avoidance && (n = "注意避让");
                var i = "r_" + e;
                return {
                    text: n,
                    rsitype: e,
                    type: "rsi",
                    code: i
                }
            }
        }),
        X = i.Layer.extend({
            statics: {
                notStartedState: 0,
                endedState: 1,
                pausedState: 2,
                runState: 3
            },
            options: {
                startTime: 0,
                endTime: 0
            },
            initialize: function(t, e) {
                if (i.setOptions(this, e), this._cars = {}, t && 0 != t.length) {
                    for (var n = t.length, o = 0; o < n; o++) {
                        var r = t[o];
                        this.addCar(r)
                    }
                    this._currentTime = this._getStartTime()
                }
            },
            isRunning: function() {
                return this._state === X.runState
            },
            isEnded: function() {
                return this._state === X.endedState
            },
            isStarted: function() {
                return this._state !== X.notStartedState
            },
            isPaused: function() {
                return this._state === X.pausedState
            },
            addCar: function(t) {
                var e = t.id,
                    n = t.dataitem,
                    i = null;
                this._cars[e] ? (i = this._cars[e], i.addInfos(n)) : (i = new W(n, {
                    id: e
                }), this._cars[e] = i, i.on("click", this.carClick, this), i.on("changeData", this._changeData, this), this._map && this._map.addLayer(i))
            },
            addData: function(t) {
                if (t && 0 != t.length)
                    for (var e = t.length, n = 0; n < e; n++) {
                        var i = t[n];
                        this.addCar(i)
                    }
            },
            carClick: function(t) {
                var e = t.target;
                for (var n in this._cars) {
                    this._cars[n].setIsHome(!1)
                }
                e.setIsHome(!0), this.start(), this.fire("homeChange", {
                    target: e,
                    id: e.options.id
                })
            },
            _changeData: function(t) {
                this.fire("changeData", t)
            },
            onAdd: function(t) {
                for (var e in this._cars) t.addLayer(this._cars[e])
            },
            onRemove: function(t) {
                for (var e in this._cars) t.removeLayer(this._cars[e]);
                this._stopAnimation()
            },
            eachCar: function(t, e) {
                for (var n in this._cars) t.call(e, this._cars[n]);
                return this
            },
            getCar: function(t) {
                return this._cars[t]
            },
            getCars: function() {
                var t = [];
                for (var e in this._cars) t.push(this._cars[e]);
                return t
            },
            getMinTime: function() {
                var t = 0;
                for (var e in this._cars) {
                    var n = this._cars[e],
                        i = n.getMinTime();
                    t ? i < t && (t = i) : t = i
                }
                return t
            },
            getMaxTime: function() {
                var t = 0;
                for (var e in this._cars) {
                    var n = this._cars[e],
                        i = n.getMaxTime();
                    t ? i > t && (t = i) : t = i
                }
                return t
            },
            _getStartTime: function() {
                var t = this.options.startTime;
                return t || (t = this.getMinTime()), t
            },
            _getEndTime: function() {
                var t = this.options.endTime;
                return t || (t = this.getMaxTime()), t
            },
            start: function() {
                this.isRunning() || (this.isPaused() ? this.resume() : (this._startAnimation(), this.fire("start")))
            },
            resume: function() {
                this.isPaused() && this._startAnimation()
            },
            pause: function() {
                this.isRunning() && (this._state = X.pausedState, this._stopAnimation())
            },
            stop: function(t) {
                this.isEnded() || (this._stopAnimation(), this._state = X.endedState, this.fire("end"))
            },
            _startAnimation: function() {
                this._state = X.runState, this._animId = i.Util.requestAnimFrame(function(t) {
                    this._startTimeStamp = t, this._animate(t)
                }, this, !0), this._animRequested = !0
            },
            _stopAnimation: function() {
                this._animRequested && (i.Util.cancelAnimFrame(this._animId), this._animRequested = !1)
            },
            _animate: function(t, e) {
                this._animRequested = !1, this._currentTime += t - this._startTimeStamp, this.fire("timeChange", {
                    time: this._currentTime
                }), this._startTimeStamp = t;
                var n = this._getEndTime();
                this._currentTime > n && this.stop();
                for (var o in this._cars) {
                    this._cars[o].setCurrentPosition(this._currentTime)
                }
                e || (this._animId = i.Util.requestAnimFrame(this._animate, this, !1), this._animRequested = !0)
            },
            getCurrentTime: function() {
                return this._currentTime
            },
            setCurrentTime: function(t) {
                this._currentTime = t;
                for (var e in this._cars) {
                    this._cars[e].reset()
                }
                this._stopAnimation(), this._startAnimation()
            }
        }),
        J = Object.freeze({
            Car: W,
            CarGroup: X,
            IconList: B,
            ApptypeEnum: G,
            BrakestateEnum: U,
            LightstateEnum: j,
            PtctypeEnum: q,
            RsitypeEnum: Z,
            TlightstateEnum: V,
            VehstateEnum: H,
            VehtypeEnum: Y
        });
    return i.extend(i, v, C, F, z, J), i.lVersion = i.version, i.version = "1.0.0", i
});